AcceptedAnswerId,Answer
"56214","<p>you'll have to do both the remove and ignore operation</p>

<ul>
<li>first make a backup of your local file (like @ibz said)</li>
<li>then remove the web.config from the repository.</li>
<li>then copy back the web.config to the same folder</li>
<li>finally use svn:ignore so that subversion does not try to add it again to the repository</li>
</ul>

<p>since i use tortoisesvn i can't really tell you what svn commands you have to use, but using tortoisesvn it would be:</p>

<ul>
<li>make backup</li>
<li>right click on web.config on the folder under source control, select TortoiseSVN | Delete</li>
<li>right click on web.config on the folder under source control, select SVN Commit => after this you will notice that the file is actually deleted from the file system</li>
<li>move up and right click on the folder under source control, select TortoiseSVN | Properties</li>
<li>on the properties window click new + property name ""svn:ignore""; property value ""web.config"". accept changes</li>
<li>commit changes</li>
</ul>

<p>on my .net projects i include the following exclusion with svn:ignore: bin, obj, *.suo, *.user</p>
"
"98021","<p>Several people misread this as a question about how to <strong>store</strong> passwords in a database.  That is wrong.  It is about how to store the password that lets you get <strong>to</strong> the database.</p>

<p>The usual solution is to move the password out of source-code into a configuration file.  Then leave administration and securing that configuration file up to your system administrators.  That way developers do not need to know anything about the production passwords, and there is no record of the password in your source-control.</p>
"
"157975","<p><a href=""https://docs.python.org/3/library/base64.html"" rel=""noreferrer"">Base64 encoding</a> is in the standard library and will do to stop shoulder surfers:</p>

<pre><code>&gt;&gt;&gt; import base64
&gt;&gt;&gt;  print(base64.b64encode(""password"".encode(""utf-8"")))
cGFzc3dvcmQ=
&gt;&gt;&gt; print(base64.b64decode(""cGFzc3dvcmQ="").decode(""utf-8""))
password
</code></pre>
"
"419418","<p>Do not EVER hard-code configuration data like file system paths and force multiple deployments to match.  That is the dark side, where there is much SUFFERING.</p>

<p>I find it useful and easy to build my systems to support multiple configurations easily, and I routinely commit configuration files into source control side-by-side, but production's is obfuscated (no real passwords) and development's is templated (so a checkout can't overwrite a developer's configuration).  The code is always packaged in a configuration-neutral manner--the same binary can be deployed anywhere.</p>

<p>Unfortunately, most language/development platforms do not readily support this (unlike Ruby on Rails).  Therefore, you have to build it yourself, to varying degrees.</p>

<p>In general, the basic principle is to incorporate indirection into your configuration:  specify not the configuration, but how to find the configuration, in your code.  And generally invoke several indirections:  user-specific, application-specific, machine-specific, environment-specific.  Each should be found in a well-defined place/manner, and there should be a very-well-defined precedence among them (usually user over machine over application over environment).  You will generally find that every configurable setting has a natural home in one location, but don't hard-code that dependency into your applications.</p>

<p>I find that it is VERY valuable to design applications to be able to report their configuration, and to verify it.  In most cases, a missing or invalid configuration item should result in aborting the application.  As much as possible, perform that verification (and abort) at startup = fail fast.  Hard-code defaults only when they can reliably be used.</p>

<p>Abstract the configuration access so that most of the application has no idea where it comes from or how it is processed.  I prefer to create <code>Config</code> classes that expose configurable settings as individual properties (strongly typed when relevant), then I ""inject"" them into application classes via IOC.  Do not make all your application classes directly invoke the raw configuration framework of your chosen platform; abstraction is your friend.</p>

<p>In most enterprise-class (Fortune 500) organizations, no one sees the production (or even test) environment configurations except the admin team for that environment.  Configuration files are never deployed in a release, they are hand-edited by the admin team.  The relevant configuration files certainly never get checked into source control side-by-side with the code.  The admin team may use source control, but it is their own private repository.  Sarbanes-Oxley and similar regulations also tend to strictly forbid developers from having general access to (near-)production systems or any sensitive configuration data.  Be mindful as you design your approach.</p>

<p>Enjoy.</p>
"
"559743","<p>If your plan is to store all the code and configuration information to run a production system directly from version control, and without human intervention, you're screwed.  Why?  This is all just a violation of the old security axiom ""never write your password down"".  Let's do a proof by negation.</p>

<p>First cut, you have plain text passwords in the configuration files.  That's no good, they can be read by anyone who can see the files.</p>

<p>Second cut, we'll encrypt the passwords!  But now the code needs to know how to decrypt the passwords, so you need to put the decryption key somewhere in the code.  The problem has just been pushed down a level.</p>

<p>How about using public/private keys?  Same problem as the passwords, the key has to be in the code.</p>

<p>The use of a local configuration file not stored in version control still puts the password, and the means to read them if they're encrypted, on disk and available to an attacker.  You can harden things a little by ensuring that configuration file's permissions are very limited, but should the box be rooted you're screwed.</p>

<p>Which brings us to why putting passwords on disk is a bad idea.  It violates the concept of a security firewall.  One compromised machine containing login information means other machines will be compromised.  One poorly maintained machine can tear down your whole organization.</p>

<p>At some point a human is going to have to inject the critical secret to start the chain of trust going.  What you could do is encrypt all the secrets in the code and then when the system starts up have a human manually enter the key to decrypt all the passwords.  This is like the master password system Firefox uses.  It is open to abuse since once that one password is compromised, many systems may be compromised, but it is convenient and probably more secure since users only have to remember one password and are less likely to write it down.</p>

<p>The final touch is to ensure that should the login information be compromised (and you should always assume that it will be) that A) the attacker can't do much with it and B) you can quickly shut down the compromised accounts.  The former means to only give the accounts as much access as they need.  For example, if your program only ever needs to read from a database have it log in on an account restricted to SELECT.  In general, remove all access and then add it only as necessary.  Be stingy about the rights to delete lest you get a visit from <a href=""http://xkcd.com/327/"" rel=""noreferrer"">little Bobby Tables</a>.</p>

<p>The latter means you give each user/organization/project their own login, even if they can have the exact same rights and privileges and access the same data.  It's a bit more of a hassle, but it means that if one system is compromised you can quickly shut down that account without shutting down your whole business.</p>
"
"658520","<p>Although my answer is not specific to source control, one thing you may want to consider is adding custom config sections to your web.config, and retrieving a different configuration depending on the location (server it is deployed on).</p>

<p>I do this currently to deal with deployment to staging, testing, production servers.  My configuration classes will determine what the server name is, and retrieve the configuration settings for that particular server.  That way, I don't have to worry about touching the web.config again, or excluding it and using different files.</p>

<p>Here is an article on how to do this.  Yes it is not exactly what you asked, but may be better than relying on source control and using different config files.</p>

<p><a href=""https://web.archive.org/web/20210802144254/https://aspnet.4guysfromrolla.com/articles/032807-1.aspx"" rel=""nofollow noreferrer"">https://web.archive.org/web/20210802144254/https://aspnet.4guysfromrolla.com/articles/032807-1.aspx</a></p>
"
"681265","<p>I second <em>Emil H</em> proposal with one addition:
you should ignore via <strong>svn:ignore</strong>-property the correct configuration file</p>

<p>eg your config-file should reside on:</p>

<pre><code>./config/app.conf
</code></pre>

<p>then you should ignore this file for subversion: </p>

<pre><code>svn propset svn:ignore ""app.conf"" ./conf
</code></pre>

<p>and copy the app.conf to app.conf.example and add this file to subversion:
   cp app.conf app.conf.example
   svn add app.conf.example</p>

<p>Now Subversion will never try to add your app.conf file to your repository(and also your colleagues cannot accidentially commit this file!)</p>
"
"706985","<p>You should place your config files in</p>

<pre><code>/path/to/deployed_app/shared
</code></pre>

<p>Then in a capistrano task, sym link to those files:</p>

<pre><code>namespace :deploy do
  task :symlink_shared do
    run ""ln -s #{shared_path}/database.yml #{release_path}/config/""
  end
end

before ""deploy:restart"", ""deploy:symlink_shared""
</code></pre>
"
"816751","<p>The ""standard"" procedure for this is something like this (forgiving the SVN syntax, I've been using <a href=""http://en.wikipedia.org/wiki/Bazaar_%28software%29"" rel=""nofollow noreferrer"">Bazaar</a> lately):</p>

<pre><code>echo config &gt; database.xml.template
svn add database.xml.template
svn ignore database.xml
svn commit
</code></pre>

<p>Then on each person's development machine:</p>

<pre><code>svn checkout
cp database.xml.template database.xml
...edit database.xml...
</code></pre>

<p>And when they commit,</p>

<pre><code>echo foo &gt; someotherfile
svn commit
</code></pre>

<p>the <code>database.xml</code> file won't be added to Subversion.</p>
"
"872700","<p>For all practical purposes, the <em>first</em> thing you should be worried about is <strong>CHANGING YOUR PASSWORDS!</strong> It's not clear from your question whether your git repository is entirely local or whether you have a remote repository elsewhere yet; if it is remote and not secured from others you have a problem. If anyone has cloned that repository before you fix this, they'll have a copy of your passwords on their local machine, and there's no way you can force them to update to your ""fixed"" version with it gone from history. The only safe thing you can do is change your password to something else everywhere you've used it.</p>

<hr>

<p>With that out of the way, here's how to fix it. <a href=""https://help.github.com/articles/remove-sensitive-data"" rel=""noreferrer"" title=""Remove sensitive data - GitHub Help"">GitHub answered exactly that question as an FAQ</a>:</p>

<p><strong>Note for Windows users</strong>: use double quotes ("") instead of singles in this command
</p>

<pre><code>git filter-branch --index-filter \
'git update-index --remove PATH-TO-YOUR-FILE-WITH-SENSITIVE-DATA' &lt;introduction-revision-sha1&gt;..HEAD
git push --force --verbose --dry-run
git push --force
</code></pre>

<p><strong>Update 2019:</strong></p>

<p>This is the current code from the FAQ:</p>

<pre><code>  git filter-branch --force --index-filter \
  ""git rm --cached --ignore-unmatch PATH-TO-YOUR-FILE-WITH-SENSITIVE-DATA"" \
  --prune-empty --tag-name-filter cat -- --all
  git push --force --verbose --dry-run
  git push --force
</code></pre>

<p>Keep in mind that once you've pushed this code to a remote repository like GitHub and others have cloned that remote repository, you're now in a situation where you're rewriting history. When others try pull down your latest changes after this, they'll get a message indicating that the changes can't be applied because it's not a fast-forward. </p>

<p>To fix this, they'll have to either delete their existing repository and re-clone it, or follow the instructions under ""RECOVERING FROM UPSTREAM REBASE"" in the <a href=""http://git-scm.com/docs/git-rebase"" rel=""noreferrer"">git-rebase manpage</a>.</p>

<p><strong>Tip</strong>: Execute <code>git rebase --interactive</code></p>

<hr>

<p>In the future, if you accidentally commit some changes with sensitive information but you notice <strong>before</strong> pushing to a remote repository, there are some easier fixes. If you last commit is the one to add the sensitive information, you can simply remove the sensitive information, then run:</p>

<pre><code>git commit -a --amend
</code></pre>

<p>That will amend the previous commit with any new changes you've made, including entire file removals done with a <code>git rm</code>. If the changes are further back in history but still not pushed to a remote repository, you can do an interactive rebase:</p>

<pre><code>git rebase -i origin/master
</code></pre>

<p>That opens an editor with the commits you've made since your last common ancestor with the remote repository. Change ""pick"" to ""edit"" on any lines representing a commit with sensitive information, and save and quit. Git will walk through the changes, and leave you at a spot where you can:</p>

<pre><code>$EDITOR file-to-fix
git commit -a --amend
git rebase --continue
</code></pre>

<p>For each change with sensitive information. Eventually, you'll end up back on your branch, and you can safely push the new changes.</p>
"
"963147","<p>We had the same problem and decided to solve it by setting up a second repository. </p>

<p>This originated when I needed to store our <a href=""http://wiki.opscode.com/display/chef/Home"" rel=""noreferrer"">configuration management</a> files in version control, which contained sensitive information. It made sense to store the sensitive data from our applications in there as well.</p>

<p>We originally used <a href=""http://svnbook.red-bean.com/en/1.0/ch07s03.html"" rel=""noreferrer"">svn externals</a> and <a href=""http://git-scm.com/docs/git-submodule"" rel=""noreferrer"">git submodules</a> to include the sensitive data, but later found it less troublesome to just simlink to another location. </p>

<p>I also find it helpful to add the proper ignores to prevent the same files ever getting checked in to the development repository. Since doing this we have not had anyone accidentally check in anything sensitive. </p>

<p>It helps try an keep the sensitive information contained in a concise set of config files -- I would not spread it out, put it one place and guard that place.</p>
"
"1015767","<ol>
<li>have a test account for your
development and give that to your
freelancers </li>
<li>you can encrypt the    sections of
web.config following the    steps
mentioned <a href=""http://odetocode.com/Blogs/scott/archive/2006/01/08/2707.aspx"" rel=""nofollow noreferrer"">here</a></li>
<li>you can    move the key into the
code and    compile the layer as a
dll and give    that to the
developers</li>
</ol>
"
"1379753","<p>By adding a new file to solution explorer, you will get the little plus sign indicating it is due to be added to source control.  Then, right-click and choose ""undo pending changes"".  This will cancel the add but leave the file in your project.</p>

<p>If that doesn't work I suggest one of the following methods:</p>

<ul>
<li>Use the Attrib task from the <a href=""http://msbuildtasks.tigris.org/"" rel=""noreferrer"">MSBuild
Community Tasks</a> project to remove
the read only flag.</li>
<li>Use the <a href=""http://msdn.microsoft.com/en-us/library/x8zx72cd.aspx"" rel=""noreferrer"">Exec
task</a> in MSBuild to invoke
<a href=""http://msdn.microsoft.com/en-us/library/56f7w6be.aspx"" rel=""noreferrer"">tf.exe</a> and checkout the file.</li>
</ul>
"
"1397180","<p>Have your program read a pair of configuration files for its settings. First, it should read a <code>config.defaults</code> file that would be included in the repository. Then, it should read a <code>config.local</code> file that should be listed in <code>.gitignore</code></p>

<p>With this arrangement, new settings appear in the defaults file and take effect as soon as it's updated. They will only vary on particular systems if they're overridden.</p>

<p>As a variation on this, you could have just a general <code>config</code> file that you ship in version control, and have it do something like <code>include config.local</code> to bring in the machine-specific values. This introduces a more general mechanism (versus policy) in you code, and consequently enables more complicated configurations (if that's desirable for your application). The popular extension from this, seen in many large-scale open-source software, is to <code>include conf.d</code>, which reads configuration from all the files in a directory.</p>

<p>Also <a href=""https://stackoverflow.com/questions/1974886/how-to-version-control-config-files-pragmatically/1976900#1976900"">see my answer</a> to a similar question.</p>
"
"1436337","<p>Environment-specific configuration properties I tend to put in, say, a properties file that isn't in source control and isn't part of the build process. When setting up a new environment, part of that setup is to put create that properties file that includes things like database addresses, credentials and names, names of relevant remote hosts and so on.</p>

<p>In Spring you use the <a href=""http://static.springsource.org/spring/docs/2.0.x/api/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.html"" rel=""noreferrer""><code>PropertyPlaceholderConfigurer</code></a> to load the properties file. It just needs to be findable by Spring, which usually just means putting it in an appropriate directory under the application server.</p>

<p>Alternatively, you use <a href=""http://wrapper.tanukisoftware.org/doc/english/download.jsp"" rel=""noreferrer"">wrapper</a> to run the application server and the JVM startup options include adding these properties files to the classpath so Spring can find them.</p>
"
"1629770","<p>In <code>settings.py</code>:</p>

<pre><code>try:
    from local_settings import *
except ImportError as e:
    pass
</code></pre>

<p>You can override what needed in <code>local_settings.py</code>; it should stay out of your version control then. But since you mention copying I'm guessing you use none ;)</p>
"
"1635286","<p>Like the others said, you can't both secure an API key and use it in your app. However, you can do simple obfuscation relatively easy and if the payoff to the cracker is low then you may not get burned.</p>

<p>One simple technique is to break your API key into several sub-strings. Make sure you put them in your code in some random order. For instance, if your API key is <em>12345678901234567890</em> you might break it up into 5 sub-strings like this:  </p>

<pre><code>static char *part1 = ""12345"";  
static char *part5 = ""7890"";    
static char *part3 = ""890123"";  
static char *part2 = ""67"";  
static char *part4 = ""456"";
</code></pre>

<p>If you run <code>/usr/bin/strings</code> on the resulting binary then you should not see the API key in order. Instead you'll see the API substrings in the order listed in your C file. With 5 substrings like this, that is 5*4*3*2*1=120 permutations. If you break it into 13 substrings you're looking at over 6 billion permutations.</p>

<p>However, that won't stop someone who knows what they're doing from getting your API key if they want it. Eventually you'll have to combine the strings together and pass it to one of your methods, at which point a cracker could use a debugger to set a breakpoint and inspect memory.</p>
"
"1636003","<p>Passwords and senstitive data are best not included the source file. If you look at the design of open-source software like PHPMyAdmin, a config file is provided to add in those information, and are usually stored in the root folder of the webhost (or anywhere outside www folder). </p>

<p>So the idea is that if your website use some info to link to a service, you should hide them away in a file as well and ask your user to provide the password and to create their own account. </p>
"
"1648600","<p>VS 2010 will provide you with a lot of control to manage web.config files for various configurations... <a href=""http://vishaljoshi.blogspot.com/2009/03/web-deployment-webconfig-transformation_23.html"" rel=""nofollow noreferrer"">Please check out</a>.</p>
"
"1862265","<p>You can </p>

<pre><code>git rm myConfigFile
echo myConfigFile &gt; .gitignore
git add .gitignore
git commit -m ""from now on, no more myConfigFile""
</code></pre>

<p>The other extreme approach (dangerous especially if you have already pushed your repo to a remote one) would be to entirely remove that file from the history of said repo:</p>

<pre><code>git filter-branch --index-filter 'git update-index --remove myConfigFile' HEAD
</code></pre>

<p>(to use with care, and with a backup first)</p>

<p>The question <a href=""https://stackoverflow.com/questions/872565/how-do-i-remove-sensitive-files-from-gits-history"">How do I remove sensitive files from git’s history</a> has more on that sensitive topic.  </p>

<p>The problems with this process are twofold:</p>

<ol>
<li>If your repo has already be cloned, you can never guarantee the confidential information will be really ""gone"" from every other repo.</li>
<li>When others try pull down your latest changes after this, they'll get a message indicating that the the changes can't be applied because it's not a fast-forward.<br>
To fix this, they'll have to either delete their existing repository and re-clone it, or follow the instructions under ""<code>RECOVERING FROM UPSTREAM REBASE</code>"" in the <a href=""http://schacon.github.com/git/git-rebase.html#_recovering_from_upstream_rebase"" rel=""nofollow noreferrer""><code>git-rebase</code> manpage</a>.<br>
In both case, your confidential information will not be ""quietly"" replaced or erased...</li>
</ol>
"
"1942920","<p>My preference is to not check in project specific configuration files to the source control but instead keep the contents of environment variables and other configuration aspects in a common folder (in source control).  The config files are then generated as part of the local build, build automation, or deployment scripts depending on what a given project, solution, environment might need at a given time.  This can be done with simple text files, xml templates, or something more complex like the spark view engine depending on your needs.  You can also do this by convention if templating is more complex than you need (and it normally is).  This way, no matter where you are deploying code too you can define an environment specific configuration.</p>

<p>An example of by convention is to define custom config sections in your primary config files (web config, app config, etc.).  You can then store a connection-strings-development.config, a connection-strings-integration.config, a connection-strings-testing.config, a connection-strings-pre-production.config, and a connection-strings-production.config in your primary source (or common folder).  The build process would then drop the appropriate connections string config file renaming it to simply connection-strings.config.</p>

<p>Generating by template you would also have custom config sections with the same environment specific config files but instead of renaming on deployment you can simply rewrite a section of the base config file directly with the appropriate config file name.</p>

<p>Keeping your config files chunked up by environment though provides you with a great deal of flexibility especially once you start managing many sites that use the same or similar style of configuration.  No matter what though, your configuration should be dictated by some aspect of your automated environment!</p>
"
"1976900","<p>Instead of version-controlling the actual configuration file, you could put a template or defaults file in version control, and a script that would ask for DB information and credential to generate the real config file, which would be excluded from (i.e. ignored by) version control. On checkout, developers could run this script to get a working environment. This script could also be invoked as part of any installation process that your application uses.</p>

<p>Also <a href=""https://stackoverflow.com/questions/1396617/git-committing-machine-specific-configuration-files/1397180#1397180"">see my answer</a> to a similar question.</p>
"
"1984006","<p>Don't know what language you are using, but for example in C/C++ you'd add a include file with the API keys, and then leave it out of source control, instead add a bogus file with <em>explicitly fake</em> API keys. Most languages have one or the other way to include files. </p>
"
"2175942","<p>Sorry, but you're stuck with running <code>git filter-branch</code> if you want to delete the credentials from the main repository. See <a href=""http://help.github.com/removing-sensitive-data/"" rel=""noreferrer"">Removing sensitive data</a>, written by the folks at GitHub.</p>

<p>Due to git's design, there's no way to force existing clones to delete the file from their respective histories.</p>

<p>You could sanitize a single branch and make it the basis for future development:</p>

<pre><code>$ git checkout -b old-master master
$ git filter-branch ... master
</code></pre>

<p>Now you'd need to push the sanitized master to a new repo that contains only the clean master:</p>

<pre><code>$ git push new-central master
</code></pre>

<p>Existing repos can add the new remote and <a href=""http://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html"" rel=""noreferrer""><code>git cherry-pick</code></a> changes from their old branches over to the new clean master if necessary.</p>

<p>For the new repository, put some sort of barrier in place to prevent someone pushing sensitive data to it so you don't have the same problem all over again. This barrier might be a human being who controls the new central repository and reviews all patches to decide what goes in.</p>
"
"2225546","<p>I wrote a script for this a little while ago.  You can find it here: <a href=""https://gist.github.com/dound/76ea685c05c4a7895247457eb676fe69"" rel=""nofollow noreferrer"">https://gist.github.com/dound/76ea685c05c4a7895247457eb676fe69</a></p>

<p>(original writeup viewable from archive.org: <a href=""https://web.archive.org/web/20160208235904/http://dound.com:80/2009/04/git-forever-remove-files-or-folders-from-history/"" rel=""nofollow noreferrer"">https://web.archive.org/web/20160208235904/http://dound.com:80/2009/04/git-forever-remove-files-or-folders-from-history/</a>)</p>

<p>The script builds on the <a href=""http://git-scm.com/docs/git-filter-branch"" rel=""nofollow noreferrer"">git-filter-branch</a> tool which comes with git.  If you're curious, you can read more about removing files from a git repo <a href=""http://kerneltrap.org/mailarchive/git/2007/10/7/331471"" rel=""nofollow noreferrer"">here</a>, but using the script from the link above should be easy and all you really need to accomplish removing that private information.</p>
"
"2250144","<blockquote>
  <p>But this causes the s3.yml and gitignore files from the master branch to get copied into the github branch</p>
</blockquote>

<p>You can avoid that with a <strong>custom merge driver</strong> which will make sure to the .gitignore file of the github branch will always retain its content over the one merged from master.</p>

<p>See <a href=""https://stackoverflow.com/questions/928646/how-do-i-tell-git-to-always-select-my-local-version-for-conflicted-merges-on-a-sp/930495#930495"">How do I tell git to always select my local version for conflicted merges on a specific file?</a></p>
"
"2392314","<p>You can't. All JS is public viewable.</p>

<p>Unless you want to base64 encode the key on the server side and modify the init function to decode it first thing. It's easily reversible, but it will obfuscate it a bit.</p>
"
"2541276","<h3>Enforce Security Policies for Private Keys</h3>
<p>Remember: a private key in conjunction with released signed binaries is your company's identity. Policies for handling such keys can't be strict enough.</p>
<p>Enforce that <strong>YOU</strong> are the only persion in your company who will be capable (and responsible) of signing executables.</p>
<p>If this is not an option then let all PKI-involved employees sign an explicit non-disclosure agreement with a high fine - a much higher sense of responsibility should be the result.</p>
<h3>Key Transfers</h3>
<ul>
<li>use portable media (like a dedicated USB stick or CD-ROM) - I'd prefer a read-only media</li>
<li>let the receipt be witnessed by another employee</li>
<li>let the recipient and the witness sign a form about the key-receipt</li>
</ul>
<h3>Storage of the Master Copy</h3>
<p>Store the master copy redundant on at least 3 drives at different geographical locations where you have exclusive access to. Also think about encrypting the copies with strong encryption algorithms like AES-256 (in a 7z file for example).</p>
"
"2968559","<p>I use Google Code as a svn repository and for any of my api keys I put a placeholder in strings.xml and make sure to blank them out if I check anything in.</p>
"
"3208547","<p>I recently went through this with one of my own apps. My solution was to store anything secret in a git-ignored YAML config file, and then to access that file using a simple class in the initializers directory. The config file is stored in the 'shared' folder for the Capistrano deployment and copied to config at each deploy.</p>

<p>Config store: <a href=""http://github.com/tsigo/jugglf/blob/master/config/initializers/juggernaut.rb"" rel=""noreferrer"">http://github.com/tsigo/jugglf/blob/master/config/initializers/juggernaut.rb</a></p>

<p>Example usage: <a href=""https://github.com/tsigo/jugglf/blob/6b91baae72fbe4b1f7efa2759bb472541546f7cf/config/initializers/session_store.rb"" rel=""noreferrer"">https://github.com/tsigo/jugglf/blob/6b91baae72fbe4b1f7efa2759bb472541546f7cf/config/initializers/session_store.rb</a></p>

<p>You may also want to remove from source control all history of the file that used these secret values. Here's a guide for doing this in Git that I used: <a href=""http://help.github.com/removing-sensitive-data/"" rel=""noreferrer"">http://help.github.com/removing-sensitive-data/</a></p>
"
"3214547","<p>Not sure why people think they can get away without some sort of install tool.  Git is about tracking source, not about deploying. You should still have a ""make install""-type tool to go from your git repo to the actual deploy, and this tool might do various things like template expansion, or selection of alternate files.</p>

<p>For example, you might have ""config.staging"" and ""config.production"" checked in to git, and when you deploy to staging, the install tool selects ""config.staging"" to copy to ""config"".  Or you might have a single ""config.template"" file, which will be templated to make ""config"" in the deploy.</p>
"
"3373581","<p>On Heroku you can use config vars to store configuration information.</p>

<p><a href=""http://docs.heroku.com/config-vars"" rel=""nofollow noreferrer"">http://docs.heroku.com/config-vars</a></p>

<p>This will keep it out of your repository.</p>
"
"3451091","<p>Make the API key a configuration item so that it can be specified by the person using the code rather than having it hard-coded within the source.</p>
"
"3502496","<p>Yes. You can rewrite history in git. As long as you control every clone of the repository, that is.</p>

<p>But it will be far more effective to simply <strong>change passwords</strong> and get over it.</p>
"
"3763329","<p>You could use a pair of <code>pre-commit</code> and <code>post-update</code> hooks to encrypt/decrypt as necessary.  See <a href=""http://hgbook.red-bean.com/read/handling-repository-events-with-hooks.html"" rel=""nofollow noreferrer"">http://hgbook.red-bean.com/read/handling-repository-events-with-hooks.html</a> for more details.</p>

<p>However, it's worth pointing out that if you're storing encrypted text in your repo you'll be unable to create meaningful diffs -- essentially everything will be like a binary file but also poorly compressible.</p>
"
"3867766","<p>Indeed, if one could rely on not serving the <code>.svn</code> / <code>.hg</code> directories by default, it would be no problem. As it is, someone (newbee / new develop / experienced on on a bad day) makes a little change that destroys those settings, and as 'nothing goes wrong' does not notice that the protection is gone. Voilà, your source code open to the world, with possibly even stored passwords &amp; secrets. It's not that something will go wrong with the proper settings, it's that with a minor, easily glossed over alteration, they could go wrong, so why not play it safe?</p>

<p>On a tightly controlled release process, I find it easier to <code>export</code> certain branches / tags to certain folders, and a switch to a newer branche / tag that has survived testing is just changing the document root from <code>/path/project/release-123</code> to <code>/path/project/release-124</code> (making it just as easy, maybe even quicker, to switch back to <code>release-123</code> may the need be there). If you have a release process with more a stream of small changes &amp; bugfixes, working with exports can indeed be a pain, but the added security is worth it in my opinion.</p>

<p>On development servers, everything is already filtered on (VPN-)IPs or certificates, so there I employ a checkout with 'the latest &amp; greatest` trunk version with the version control dirs without any problem.</p>

<p><strong>edit:</strong> </p>

<p><em>Both</em> Mercurial and Subversion nowadays keep there data in a single .hg/.svn dir in the top level. As one would normally make a checkout where most of the files are <em>outside</em> the document root (and the document root is likely a subdirectory further down), this is <em>fine</em>. Just make sure your version control directories are <em>not</em> in a reachable folder for the webserver inside the document root, and you can keep checkouts rather then exports there without much problems.</p>
"
"4101723","<p>You could remove the secret keys from the repository using a hammer like <code>git filter-branch</code>. There is a nice explanation on <a href=""http://help.github.com/removing-sensitive-data/"">GitHub's help pages</a>.</p>
"
"4114191","<p>Use this:</p>

<pre><code>git update-index --skip-worktree path/file.cfg
</code></pre>

<p>And to restore:</p>

<pre><code>git update-index --no-skip-worktree path/file.cfg
</code></pre>

<p>Lastly, if you want to list files that are marked with <code>skip-worktree</code>:</p>

<pre><code>git ls-files -v | grep ^S | awk '{print $2}'
</code></pre>

<p>To simplify, you can make an alias for that in your <code>$HOME/.gitconfig</code>:</p>

<pre><code>[alias]
    ls-ignored-changes = !git ls-files -v | grep ^S | awk '{print $2}'
</code></pre>

<p>Then you can type just <code>git ls-ignored-changes</code>. It even works with auto-completion if you have the <a href=""https://github.com/git/git/tree/master/contrib/completion"" rel=""noreferrer""><code>git-completion</code></a> in place (for bash, tcsh, zsh).</p>
"
"4148263","<p>I think the best solution is to add a sample database.yml somewhere in your project and .gitignore the existing one. Someone who checks out the project will need to create the database.yml (either from scratch or the sample).</p>
"
"4200395","<p>The basic method is put the information in a properties file and use the Properties class to load it at run time.  If you're using a J2EE server, database connections are configured in the server and the code references them by an abstract name.  </p>

<p>I think I should add that if you're using a server, how to configure it and how to get the connections to your code will vary by server and J2EE level so post your environment.  Using the Properties class is pretty obvious just by looking at the javadoc and the load() methods.</p>
"
"4315407","<p>The (only?) way to secure the file is to change its permissions to make it readable <em>only</em> to the user that runs the daemon.</p>

<p>Eg. if you are running the daemon as user 'foo' and group 'foo', you should:</p>

<pre><code>chown foo.foo my-conf-file
chmod 600 my-conf-file
</code></pre>

<p>(Or even chmod it to <code>400</code> to prevent accidental modification, but I guess in this case you'll lose the <code>-c</code> option functionality).</p>

<p><strong>NOTE:</strong> Also remember that it is quite dangerous to pass connection strings on the command line since they will be visible from the process listing!</p>

<p>You could also use some GPG stuff to encrypt the file, but I don't see the point there since then you have to protect the key you use to decript the file, and you get the exact same problem as before.</p>
"
"4319411","<p>There's no single ""silver bullet"" answer here and it would all greatly depend on details.</p>

<p>First of all, I consider best practice to separate all source code from configuration in separate repository. So, source code remains source code, but it's installation or deployment (with configuration, passwords, etc) is the whole other thing. This way you'll firmly separate developers' tasks from sysadmins' tasks and can ultimately build 2 distinct teams doing what's they're good at.</p>

<p>When you have separate source code repository + deployment repository, your best next bet is considering deployment options. Best way I see here is using deployment procedures typical for a chosen OS (i.e. building autonomous packages for a chosen OS the way that OS's maintainers do).</p>

<p>For example, Red Hat or Debian packaging procedures usually mean grabbing a tarball of software from external site (that would be exporting sources from your source code VCS), unpacking it, compiling and preparing packages ready for deployment. Deployment itself should ideally mean just doing a quick &amp; simple command that would install the packages, such as <code>rpm -U package.rpm</code>, <code>dpkg --install package.deb</code> or <code>apt-get dist-upgrade</code> (given that your built packages go to a repository where apt-get would be able to find them).</p>

<p>Obviously, to get it working this way, you'll have to supply all configuration files for all components of a system in a fully working state, including all addresses and credentials.</p>

<p>To get more concise, let's consider a typical ""small service"" situation: one PHP application deployed across <em>n</em> application servers running apache / mod_php, accessing <em>m</em> MySQL servers. All these servers (or virtual containers, that doesn't really matter) reside in a protected private network. To make this example easier, let's assume that all real internet connectivity is fronted by a cluster of <em>k</em> http accelerators / reverse proxies (such as nginx / lighttpd / apache) which have very easy configuration (just internal IPs to forward to).</p>

<p>What do we have for them to be connected and fully working?</p>

<ul>
<li>MySQL servers: set up IPs/hostnames, set up databases, provide logins &amp; passwords</li>
<li>PHP application: set up IPs/hostnames, create configuration file that will mention MySQL servers IPs, logins, passwords &amp; databases</li>
</ul>

<p>Note that there are 2 different ""types"" of information here: IPs/hostnames is something fixed, you'd likely want to assign them once and for all. Logins &amp; passwords (and even database names), on the other hand, are purely for connectivity purposes here - to make sure for MySQL that it's really our PHP application connecting to it. So, my recommendations here would be splitting these 2 ""types"":</p>

<ul>
<li>""Permanent"" information, such as IPs, should be stored in some VCS (different from source code VCS)</li>
<li>""Transient"" information, such as passwords between 2 applications, should be never stored, but generated during generation of deployment packages.</li>
</ul>

<p>The last and the toughest question remains here: how to create deployment packages? There are multiple techniques available, 2 main ways are:</p>

<ul>
<li>Exported source code from VCS1 + ""permanent"" configuration from VCS2 + building script from VCS3 = packages</li>
<li>Source code is in VCS1; VCS2 is a distributed version control (like git or hg) which essentially contains ""forks"" of VCS1 + configuration information + building scripts which can generate . I personally like this approach better, it's much shorter and ultimately easier to use, but learning curve may be a bit steeper, especially for admin guys who'll have to master git or hg for it.</li>
</ul>

<p>For an example above, I'd create packages like:</p>

<ul>
<li><code>my-application-php</code> - which would depend on mod_php, apache and would include generated file like <code>/etc/my-php-application/config.inc.php</code> that will include MySQL database IPs/hostnames and login / password generated as <code>md5(current source code revision + salt)</code>. This package would be installed on every of <em>n</em> application servers. Ideally, it should be able install on a cleanly installed OS and make a fully working application cluster node without any manual activity.</li>
<li><code>my-application-mysql</code> - which would depend on MySQL-server and would include post-install script that:
<ul>
<li>starts MySQL server and makes sure it will start automatically on OS start</li>
<li>connects to MySQL server</li>
<li>checks if required database exists</li>
<li>if no - creates the database, bootstraps it with contents and creates login with password (the same logins &amp; passwords as generated in <code>/etc/my-php-application/config.inc.php</code>, using md5 algorithm)</li>
<li>if yes - connects to the database, applies migrations to bring it up to the new version, kills all older logins / passwords and recreates the new login/password pair (again, generated using md5(revision + salt) method)</li>
</ul></li>
</ul>

<p>Ultimately, it should bring the benefit of upgrading your deployment using single command like <code>generate-packages &amp;&amp; ssh-all apt-get dist-upgrade</code>. Also, you do not store inter-applications passwords anywhere and they get regenerated on every update.</p>

<p>This fairly simple example illustrates a lot of methods you can employ here - but, ultimately, it's up to you to decide which solution is better here and which one is overkill. If you'll put more details here or as a separate question, I'll gladly try to get into details.</p>
"
"4760991","<p>You could use the special <code>App_Data</code> folder to store your settings file. Direct access to this folder is denied by ASP.NET. As far as the format of this file is concerned XML seems a good format. But whatever format you choose make sure you provide a strongly typed API that will allow you to access those settings so that you don't find yourself parsing XML in the middle of a controller action. In <code>Application_Start</code> you could parse it and store the values in some structure which will be accessible through the entire application. And because it is in Application_Start that you are doing this you could use it along with your favourite DI framework to pass those values to all classes that might need them such as controllers and repositories.</p>
"
"4761393","<p>You're on the right track using settings.php. You can <a href=""http://api.drupal.org/api/drupal/developer--globals.php/global/conf/6"" rel=""nofollow"">use the $conf variable in settings.php</a> to set variables that you can access in modules using <a href=""http://api.drupal.org/api/drupal/includes--bootstrap.inc/function/variable_get/6"" rel=""nofollow"">variable_get</a>.</p>
"
"4765966","<p>You could use PHP's md5 encryption libraries to encrypt the password and then store it in the text file.  Since md5 isn't reversible, the password would be secure.</p>

<p>You definitely do not want to store in plain text.</p>

<p>You could also store the password in the PHP file, but using the encrypted hash.  The advantage of the file is that the data is separated from the business logic, which can make adding a database or the ability to use multiple users/passwords slightly easier.</p>

<p><strong>UPDATE</strong>: If you store the password in plain text in the PHP script unencrypted, anyone who hacks your server or has access to the server can read the contents of your plain-text PHP files.</p>
"
"4766416","<p>See the previous answer: <a href=""https://stackoverflow.com/questions/872565/how-do-i-remove-sensitive-files-from-gits-history"">Remove sensitive files and their commits from Git history</a> </p>

<p>git filter-branch to the rescue: <a href=""http://git-scm.com/docs/git-filter-branch"" rel=""nofollow noreferrer"">http://git-scm.com/docs/git-filter-branch</a></p>

<p>Beware that this will change all of the SHA-hashes of your commits, but that's OK if it's a personal project.</p>
"
"4956788","<p>You need use the ENV variable from your heroku app.</p>

<p>If you do a heroku config you can have access to all of your ENV variable. You just add some and use it directly in your application.</p>

<p>With this trick you don't need update your code to change your configuration and the configuration if not define in your code base.</p>

<p>In your s3.yml you just need do :</p>

<pre><code>access_key_id: &lt;%= ENV['S3_ACCESS_KEY'] %&gt;
secret_access_key: &lt;%= ENV['S3_SECRET_KEY'] %&gt;
bucket: &lt;%= ENV['S3_BUCKET_NAME'] %&gt;
</code></pre>

<p>And add this ENV VARIABLE in your heroku app</p>

<pre><code>heroku config:add S3_ACCESS_KEY='your_key'
heroku config:add S3_SECRET_KEY='your_secret'
heroku config:add S3_BUCKET_NAME='your_nucket_name'
</code></pre>
"
"5048098","<p>I don't keep database.yml in git. I write it in a cap setup task. For email addresses and other things, I read them at app initialize from a file in the file-system. Again, not under source code management and written to the shared directory during cap setup.</p>

<p>Here's a sample:</p>

<pre><code>namespace :deploy do
  task :start do ; end
  task :stop do ; end

  task :setup do
    run &lt;&lt;-CMD
      mkdir -p -m 775 #{release_path} #{shared_path}/system #{shared_path}/media &amp;&amp;
      mkdir -p -m 777 #{shared_path}/log &amp;&amp;
      mkdir -p -m 777 #{shared_path}/pids &amp;&amp;
      mkdir -p #{deploy_to}/#{shared_dir}/config
    CMD

  end

  require 'erb'

  after deploy:setup do
    db_config = ERB.new &lt;&lt;-EOF
production:
  adapter: mysql2
  database: my_fine_database
  host: 127.0.0.1
  username: database_user
  password: database_password
EOF

    email_config = ERB.new &lt;&lt;-EOF
--- 
:user_name: me@mydomain.com
:password: verysecret
:port: 25
:address: mydomain.com
:domain: mydomain.com
:authentication: :login
EOF

    put db_config.result, ""#{shared_path}/config/database.yml""
    put email_config.result, ""#{shared_path}/config/creds.yml""
  end
</code></pre>

<p>and in my <code>environment.rb</code>, I put:</p>

<pre><code>credentials = File.join(Rails.root, 'config/creds.yml')

ActionMailer::Base.smtp_settings = YAML.load(File.open(credentials)) if File.exists?(credentials)
</code></pre>

<p>What other sensitive information might you be storing?</p>
"
"5086436","<p>In short, no - not really.  See this question <a href=""https://stackoverflow.com/questions/1161022/storing-my-amazon-credentials-in-c-desktop-app"">Storing My Amazon Credentials in C# Desktop App</a> which expands on why and what you can do about it.</p>
"
"6499463","<p>I would recommend that you factor this data out into a separate datafile provided as input to the application, then track that one datafile in a separate git repository. Git itself is not designed for masking out parts of a repository, and all kinds of madness will result if you try to force things to work that way.</p>
"
"6513473","<p>Not exactly an answer:</p>

<ul>
<li>If you keep keys in the model, anyone who can deploy can read the keys from the model, and deploy again to cover their tracks. While Google lets you download code (unless you disable this feature), I think it only keeps the latest copy of each numbered version.</li>
<li>If you keep keys in a not-checked-in config file and disable code downloads, then only people with the keys can successfully deploy, but nobody can read the keys without sneaking a backdoor into the deployment (potentially not that difficult).</li>
</ul>

<p>At the end of the day, anyone who can deploy can get at the keys, so the question is whether you think the risk is minimized by storing keys in the datastore (which you might make backups of, for example) or on deployer's machines.</p>

<p>A viable alternative might be to combine the two: Store encrypted API keys in the datastore and put the master key in a config file. This has some potentially nice features:</p>

<ul>
<li>Attackers need both access to a copy of the datastore and a copy of the config file (and presumably developers don't make backups of the datastore on a laptop and lose it on the train).</li>
<li>By specifying two keys in the config file, you can do key-rollover (so attackers need a datastore/config of similar age).</li>
<li>With asymmetric crypto, you can make it possible for developers to add an API key to the datastore without needing to read the others.</li>
</ul>

<p>Of course, then you're uploading crypto to Google's servers, which may or may not count as ""exporting"" crypto with the usual legal issues (e.g. what if Google sets up an Asia-Pacific data centre?).</p>
"
"6521540","<p>AppHarbor supports replacement of configuration variables on deploy to avoid the problem of committing usernames and passwords to source control (amongst other uses). It's <a href=""http://support.appharbor.com/kb/getting-started/managing-environments"" rel=""noreferrer"">documented in the knowledge-base</a>.</p>
"
"6547311","<p>You can use AES encryption to encrypt/decrypt your data and store/read it from file or shared preferences. The AES key can be hardcoded in the app, or you can use random generated key which will be stored at different place.</p>
"
"7219763","<p>You cannot version the file and hide it from others.  The ID of a commit is based in part on the ID of the commit file tree, which is based on the contents of that tree -- file names and contents.  If you change the contents of a file, you change its identity in Git.  When you change its identity, you change the identity of the tree it's contained in, all the way up to the commit.</p>

<p>In short, no.  The ID of every commit containing this file will be based upon the contents of that file.  The only way to hide the file from others who will have access to the repository is to <em>never add it to the repository in the first place.</em></p>

<p>(If you have not yet published the repository, you can rewrite history using <code>git filter-branch</code> to remove all occurrences of the file.  Note that this will, as described above, change the identity of many commits.)</p>
"
"7459113","<p><a href=""http://www.ezzylearning.com/tutorial.aspx?tid=8067328"" rel=""nofollow"">http://www.ezzylearning.com/tutorial.aspx?tid=8067328</a></p>

<p>Store it in App.Config File. </p>

<p>Check out above tutorial. </p>

<p>You can also check this good article by Microsoft which teach you how to encrypt and retrieve. </p>

<p><a href=""http://msdn.microsoft.com/en-us/library/ms254494.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/ms254494.aspx</a></p>

<h1>One of Previous Posts</h1>

<p>if you have installed Microsoft Enterprise Library, you can easily encrypt/decrypt using its tool as mentioned in this link</p>

<p><a href=""http://davidhayden.com/blog/dave/archive/2006/01/23/2744.aspx"" rel=""nofollow"">http://davidhayden.com/blog/dave/archive/2006/01/23/2744.aspx</a></p>

<p><a href=""http://davidhayden.com/blog/dave/archive/2006/03/02/2870.aspx"" rel=""nofollow"">http://davidhayden.com/blog/dave/archive/2006/03/02/2870.aspx</a></p>

<p>Also, after the installation, open the project in studio and right click on the web.config or app.config and you will see the option for the configuration though Enterprise Library.  This option is available in Visual Studio 2005 but I cannot see this in Visual Studio 2008 yet.  Not sure whether its not compatible with 2008 or I have to follow some installation sequences. I will let you guys know if I come across with any solutions.</p>

<p>This is the link which explains how to work with encryption within studio <a href=""http://www.pnpguidance.net/Post/EnterpriseLibrary3VisualStudioIntegratedConfigurationEditor.aspx"" rel=""nofollow"">http://www.pnpguidance.net/Post/EnterpriseLibrary3VisualStudioIntegratedConfigurationEditor.aspx</a> .  Read, read &amp; read...</p>

<p>Keep in mind that once you open the .config file you have luxuary of ecrypting each pieces/blocks seperately.  Thats the beatuy of it.</p>

<p>For your information I am using Enterprise Library 3.1 which is the latest version and has tonnes of tools that makes your life a breeze.  You can download this library at <a href=""http://msdn2.microsoft.com/en-us/library/aa480453.aspx"" rel=""nofollow"">http://msdn2.microsoft.com/en-us/library/aa480453.aspx</a>.  Also, look forward for 4.0 at <a href=""http://www.codeplex.com/entlib"" rel=""nofollow"">http://www.codeplex.com/entlib</a></p>

<hr>

<p>Bottom line you can search google along these lines and I am sure it will give you the whole process. </p>
"
"7742626","<p>ENV vars are generally considered the way to go, and the way Heroku do it themselves for database_urls and the like.</p>

<p>As you and your app are the only people with access to the env vars, you're generally OK security wise.</p>

<p>Putting credentials in Git or similar is a bad idea as it's another place that needs to be secured.</p>
"
"7843588","<p>Have you tried looking into <a href=""http://msdn.microsoft.com/en-us/library/dd465326.aspx"" rel=""nofollow"">web.config transformations</a>? They might be able to provide the functionality that you seek while still keeping everything in version control or needing any code changes. Plus it will work for more things than just connection strings, but also directories, etc.</p>
"
"7853139","<p>First advice is to <em>never</em> store anything sensitive in your code directly. You can <em>always</em> reverse engineer that, no matter how cleverly you try to obfuscate it.</p>

<p>I've read about things like breaking a password into several pieces, placing them at different places in the code and running them through a series of functions before finally using them... although this makes things harder, you can still always monitor the application using a debugger and ultimately you will be able to retrieve the secret information.</p>

<p>If I interpret your scenario correctly, what you have is code that is to be deployed at some client's premises and your code is connected to a database (which I suppose is also under the client's supervision), connecting to it requires a password. This password is known to that client, so trying to hide it from the client is rather useless. What you <em>do</em> want is to restrict access to that password from anybody who is not supposed to know it.</p>

<p>You typically achieve this by putting the sensitive information in a separate file in a folder that should have very restrictive permissions, only the application and a handful of selected people should have access. The application would then access the information when needed during runtime.</p>

<p>Additionally encrypting the separate file turns out to be a problem - if you do so then there is a key involved that again would have to be secured somehow - infinite recursion is on it's way :) Securing access to the file is often sufficient, but if you really require to be as secure as possible, then a solution is to use password-based encryption for the file. But the idea here is not to store the password in yet another location on the system, but rather as out-of-band information (e.g. in a physical vault) and entering the password when starting the application. This, too, has its problems: physical presence of a person is required for (re-)starting the application, and you could still retrieve the password from the RAM of the machine where the application is running on. But it is probably the best you can do without specialized hardware.</p>

<p>Another good alternative to password-based encryption would be to rely on OS-specific ""password vaults"" such as Windows' <a href=""http://msdn.microsoft.com/en-us/library/3ak841sy.aspx"">Isolated Storage</a>, it's sort of a trade-off between not encrypting at all and keeping the password out-of-band.</p>
"
"7869545","<p>The way I know works great (at least with regular TFS) is to put the unittests into a seperate folder structure and then to customize the permissions on the folder structure (or maybe this is only limited to some specific files) to not let contributors modify those folders. Then you have explicit control over the content of those assets that you need.</p>

<p>What you can also try is to have those credentials stored in files that are not under version control. For a contributor to mess up then involves an explicit add action which can be prevented, by exclusion of that specific file type or by a custom check-in policy, like forbidden-pattern.</p>
"
"7908720","<p>Heroku have some guidance on this -</p>

<p><a href=""http://devcenter.heroku.com/articles/config-vars"" rel=""noreferrer"">http://devcenter.heroku.com/articles/config-vars</a></p>
"
"8190507","<p>The standard is to put your configuration settings in one YAML file which isn't included in your repo.</p>

<p>Then you simply get the data from it.</p>

<p>Check Railscast ""<a href=""http://railscasts.com/episodes/85-yaml-configuration-file"" rel=""nofollow"">#85 YAML Configuration File</a>"" to see it in action.</p>
"
"8309450","<p>Check in the supersecretstoragecredentials.ini file with some placeholder values and then</p>

<pre><code>git update-index --assume-unchanged supersecretstoragecredentials.ini
</code></pre>

<p>Git will not track future changes to this file. </p>

<p>You can reset this using </p>

<pre><code>git update-index --no-assume-unchanged supersecretstoragecredentials.ini
</code></pre>
"
"8519041","<p>The canvas URL is not used to verify requests made to the Facebook API. A malicious user can write his own application that uses your app secret to get a session with the security permissions of your app. This allows the attacker to steal all the data that your users have authorised your app to have access to, and perform all actions (wall posts etc) that users have authorised your app to perform.</p>
"
"8563528","<p>Much later, I found a pretty good Node.js module for managing configuration: <a href=""https://github.com/flatiron/nconf"">nconf</a>.</p>

<p>A simple example:</p>

<pre><code>var nconf = require('nconf');

// First consider commandline arguments and environment variables, respectively.
nconf.argv().env();

// Then load configuration from a designated file.
nconf.file({ file: 'config.json' });

// Provide default values for settings not provided above.
nconf.defaults({
    'http': {
        'port': 1337
    }
});

// Once this is in place, you can just use nconf.get to get your settings.
// So this would configure `myApp` to listen on port 1337 if the port
// has not been overridden by any of the three configuration inputs
// mentioned above.
myApp.listen(nconf.get('http:port'));
</code></pre>

<p>It also supports storing settings in <a href=""http://redis.io/"">Redis</a>, writing configuration files, and has a fairly solid API, and is also backed by one of the more well-respected Node.js shops, <a href=""http://nodejitsu.com/"">Nodejitsu</a>, as part of the <a href=""http://flatironjs.org/"">Flatiron</a> framework initiative, so it should be fairly future-proof. </p>

<p>Check out <a href=""https://github.com/flatiron/nconf"">nconf at Github</a>.</p>
"
"9868624","<p>If you can rewrite the history of your private repo (because of the limited number of collaborators), it would be best to:</p>

<ul>
<li>remove completely from the all history those sensitive data</li>
<li>store them ""elsewhere"" (ie not in a Git repo but in an external source)</li>
<li>use content filter driver to manage your actual sensitive file content.<br>
See ""<a href=""https://stackoverflow.com/a/6826682/6309"">What's the easiest way to deal with project configuration files?</a>"" for instance:</li>
</ul>

<p><img src=""https://i.stack.imgur.com/JOexx.png"" alt=""content filter driver""></p>

<p>The idea is, on checkout, to generate the actual files based on:</p>

<ul>
<li>your environment</li>
<li>a template file</li>
<li>a value file (which can be, based on your current environment, dummy values store in a separate value file in your Git repo, or your actual sensitive value stored in your external source outside the Git repo)</li>
</ul>

<p>The more general idea is that sensitive data shouldn't be stored at all in a Git repo.</p>
"
"10204087","<p>I'd suggest that you rethink your security architecture. Anything shipped with the app is discoverable. (For instance, Android's license validation library is designed so that a public key is shipped with the app.)</p>

<p>One possibility is for the app to retrieve the key from a server (over a secure socket or https connection). This would obviously require that the app submit to the server some sort of identification/validation (probably based on user input).</p>

<p>If you're using the key for encryption, then take another look at how public key encryption is supposed to work. Your app should have the <em>public</em> key; the internet service can then decrypt with the matching private key.</p>
"
"10401249","<p>Create the files <code>config.php.sample</code> and <code>database.php.sample</code> that each of your developers will use that has a placeholder for the passwords and other sensitive information.   Add <code>config.php</code> and <code>database.php</code> to your <code>.gitignore</code></p>

<p>The first time you deploy to the production site, you'll create the <code>config.php</code> and <code>database.php</code> files.   Subsequent pushes won't overwrite <code>config.php</code> and <code>database.php</code> since they're not included in the git repository.</p>
"
"11197827","<p>Just don't include them in your code and use environment variables:</p>
<pre><code>$my_very_secret_key = getenv(&quot;MY_VERY_SECRET_KEY&quot;);
</code></pre>
<p>You'll define this key wherever your webserver will allow you to. For instance with nginx:</p>
<pre><code>env MY_VERY_SECRET_KEY='OhThatsAVerySecretKey'
</code></pre>
<p>This procedure is recommended by Heroku to <a href=""https://devcenter.heroku.com/articles/s3"" rel=""nofollow noreferrer"">store s3 credentials</a>, it's imho the best way to go.</p>
<p>If you're using a package manager(such as composer), you can install the <a href=""https://github.com/vlucas/phpdotenv"" rel=""nofollow noreferrer"">Dotenv</a> package, which allows you to use a <code>.env</code> file in the root of your project. Make sure this file isn't readable from the web though, otherwise your security keys will be exposed.</p>
"
"11300680","<p><strong>TLDR</strong>: Use environment variables!</p>

<p>I think @Bryce's <a href=""https://stackoverflow.com/questions/6113042/where-to-store-sensitive-data-in-public-rails-app/11300680#comment7130074_6113121"">comment</a> offers an answer, which I'll just flush out. It seems one approach <a href=""https://devcenter.heroku.com/articles/config-vars"" rel=""nofollow noreferrer"">Heroku recommends</a> is to use environment variables to store sensitive information (API key strings, database passwords). So survey your code and see in which you have sensitive data. Then create environment variables (in your .bashrc file for example) that store the sensivite data values. For example for your database:</p>



<pre><code>export MYAPP_DEV_DB_DATABASE=myapp_dev
export MYAPP_DEV_DB_USER=username
export MYAPP_DEV_DB_PW=secret
</code></pre>

<p>Now, in your local box, you just refer to the environment variables whenever you need the sensitive data. For example in database.yml :</p>

<pre><code>development:
  adapter: mysql2
  encoding: utf8
  reconnect: false
  database: &lt;%= ENV[""MYAPP_DEV_DB_DATABASE""] %&gt;
  pool: 5
  username: &lt;%= ENV[""MYAPP_DEV_DB_USER""] %&gt;
  password: &lt;%= ENV[""MYAPP_DEV_DB_PW""] %&gt;
  socket: /var/run/mysqld/mysqld.sock
</code></pre>

<p>I think database.yml gets parsed just at the app's initialization or restart so this shouldn't impact performance. So this would solve it for your local development and for making your repository public. Stripped of sensitive data, you can now use the same repository for the public as you do privately. It also solves the problem if you are on a VPS. Just ssh to it and set up the environment variables on your production host as you did in your development box. </p>

<p>Meanwhile, if your production setup involves a hands off deployment where you can't ssh to the production server, like Heroku's does, you need to look at how to remotely set up environment variables. For Heroku this is done with <code>heroku config:add</code>. So, per the same article, if you had S3 integrated into your app and you had the sensitive data coming in from the environment variables:</p>



<pre><code>AWS::S3::Base.establish_connection!(
  :access_key_id     =&gt; ENV['S3_KEY'],
  :secret_access_key =&gt; ENV['S3_SECRET']
)
</code></pre>

<p>Just have Heroku create environment variables for it:</p>



<pre><code>heroku config:add S3_KEY=8N022N81 S3_SECRET=9s83159d3+583493190
</code></pre>

<p>Another pro of this solution is that it's language neutral, not just Rails. Works for any app since they can all acquire the environment variables.</p>
"
"11667433","<p>Heroku pushes <a href=""https://devcenter.heroku.com/articles/config-vars"" rel=""noreferrer"">the use of environment variables</a> for settings and secret keys:</p>

<blockquote>
  <p>The traditional approach for handling such config vars is to put them under source - in a properties file of some sort. This is an error-prone process, and is especially complicated for open source apps which often have to maintain separate (and private) branches with app-specific configurations.</p>
  
  <p>A better solution is to use environment variables, and keep the keys out of the code. On a traditional host or working locally you can set environment vars in your bashrc. On Heroku, you use config vars.</p>
</blockquote>

<p>With Foreman and <code>.env</code> files Heroku provide an enviable toolchain to export, import and synchronise environment variables.</p>

<hr>

<p>Personally, I believe it's wrong to save secret keys alongside code. It's fundamentally inconsistent with source control, because the keys are for services <em>extrinsic to the the code</em>. The one boon would be that a developer can clone HEAD and run the application without any setup. However, suppose a developer checks out a historic revision of the code. Their copy will include last year's database password, so the application will fail against today's database.</p>

<p>With the Heroku method above, a developer can checkout last year's app, configure it with today's keys, and run it successfully against today's database. </p>
"
"11768872","<p>When you're dealing with sensitive values stored in JavaScript, you have two primary security concerns:</p>

<ol>
<li>The sensitive value is viewable as plain text in the source.</li>
<li>Another JS function on the page can reach into the object and pull those values (i.e., an XSS attack). </li>
</ol>

<p>The second item above becomes much more relevant when you have apps running from multiple sources on a single page (e.g., Facebook apps). In these instances, you would have to take pre-cautions not to expose sensitive variables by using closures to namespace. You are actually already doing this: your <code>user</code> object is declared inside a closure. This prevents any other JS function on the page from being able to access the <code>user</code> object.</p>

<p>In your case, I'm assuming that there isn't any other code on the page except for your own and the possibility for injection is minimal--your code is safe :)</p>

<p><strong>Edit:</strong> What makes storing the username and password in a cookie insecure is that it sits on your computer after you've closed the browser. If a hacker can access that cookie (through any number of ways) then you could be in trouble. What you've done above is safe because nothing is stored on the client side after the browser closes (and while the browser is open, other JS cannot access the values you've stored). If you want to put something in a cookie, it'd be better to store some sort of public/private authentication key. There's a lot of discussion on this, here is a thorough 'best practices' article on the topic: <a href=""http://jaspan.com/improved_persistent_login_cookie_best_practice"" rel=""nofollow"">http://jaspan.com/improved_persistent_login_cookie_best_practice</a></p>
"
"11853911","<p>What you want to do is stop Git from tracking the file changes.  </p>

<ol>
<li>Move any sensitive strings from <code>connect.php</code> into a new file called <code>config.php</code></li>
<li>Fill in with sample string</li>
<li>Include <code>config.php</code> in <code>connect.php</code></li>
<li>Commit to Git</li>
<li>Use <code>git update-index --assume-unchanged &lt;file&gt;</code> to stop tracking updates to this file.</li>
<li>Update the file with your production strings </li>
<li>If you ever need to track changes again use <code>git update-index --no-assume-unchanged &lt;file&gt;</code></li>
</ol>
"
"11965249","<p>The standard solution is to store it in a config file. Therefore everyone who wants to install and run the software needs to register his/her own password to use your software.</p>

<p>Generally, for server-based software, each installation is a separate service. For example NBC Universal, NPR and Huffington Post all use the same software but are considered different entities. Therefore this makes sense in general.</p>

<p>However, for desktop-based software this is not the case. The word processor used by NBC, NPR and Huffington Post are not considered different software but is just Microsoft Word. So for desktop-based software (or mobile App) the solution is similar except that you include the necessary private key/secret code during the build process. Again, keeping this all in config files makes life easier. Just make sure that the example/default config file that you upload to the public repo does not contain any secrets.</p>
"
"12134119","<p>Consider using configuration management tools like <a href=""http://puppetlabs.com/"" rel=""nofollow"">puppet</a> or <a href=""http://www.opscode.com/chef/"" rel=""nofollow"">chef</a> for managing all your application configuration files. Both tools use ""manifests"" or ""receipes"" which can placed under revision control and matched to each server deploying the application.</p>

<p>Another option is to consider is to develop an install package for your OS, see the following articles for more details:</p>

<ul>
<li><a href=""http://www.sonatype.com/people/2011/11/bringing-java-and-linux-together-on-the-way-to-continuous-live-deployment/"" rel=""nofollow"">http://www.sonatype.com/people/2011/11/bringing-java-and-linux-together-on-the-way-to-continuous-live-deployment/</a> </li>
</ul>

<p>The advantage of doing it this way is that the install can be configured to generate the correct configuration tailored for the environment it is deployed onto. A more important benefit is that it's simpler to manage and install.</p>
"
"12193696","<p><code>git filter-branch</code> alters existing commits, it won't work automatically with new commits.</p>

<p>What you want is a <a href=""http://git-scm.com/book/en/Customizing-Git-Git-Hooks"" rel=""nofollow"">hook</a>.</p>

<p>However, you can't completely ignore the values in that file, since you can't alter committed objects without creating a parallel timeline. You can at most mask them in the working tree, setting up hooks that will always ignore the masked lines on checkout and commit. But that is very complex, and it will make things harder for developers.</p>

<p>A better alternative is to put such configuration in a separate file that is <a href=""http://www.kernel.org/pub/software/scm/git/docs/gitignore.html"" rel=""nofollow"">ignored</a> by git, and each developer should maintain a local copy of that file with his own settings and passwords. It is never a good idea to put passwords on a public (or at least shared) repository. Passwords should always be private.</p>
"
"12290799","<p>This is the perfect for .config files. Depending on whether its a web or console application, you will have a web.config or app.config file in your project.</p>

<p>You can use the <code>appSettings</code> section to store your API key.</p>

<p>To make things even easier, you can actually have this section read from another file, ie: specialappsettings.config and then just ignore that single file from your repository.</p>

<p>Modify your <strong>web.config</strong> (or <strong>app.config</strong>):</p>

<pre><code>&lt;configuration&gt;
&lt;appSettings file=""specialappsettings.config""&gt;
&lt;/appSettings&gt;
&lt;system.web&gt;
&lt;!-- standard web settings go here --&gt;
&lt;/system.web&gt;
&lt;/configuration&gt;
</code></pre>

<p>Create a new <strong>specialappsettings.config</strong> file:</p>

<pre><code>&lt;appSettings&gt;
&lt;add key=""APIKey"" value=""YourApiKeyValue"" /&gt;
&lt;add key=""AnotherKey"" value=""AnotherValue"" /&gt;
&lt;/appSettings&gt;
</code></pre>

<p>This can be accessed in your code via:</p>

<pre><code>var apiKey = ConfigurationManager.AppSettings[""APIKey""];
</code></pre>

<p>Notes:</p>

<ul>
<li>You can keep your settings within the original web.config file as
well but this lets you ignore just the specific settings file from
your git repository without affecting the rest of the project's
necessary configuration details.</li>
<li>The same ""key"" can be saved in
either file however the external file will override the original
web.config file value.</li>
</ul>
"
"12390338","<p>As to why it does not work, have you tried echoing out the value read from the file? It might be something as simple as a space or new-line, so you could try:</p>

<pre><code>$obj-&gt;password = trim($pword);
</code></pre>

<p>An alternative would be to just add a example config file to github and not the real one, for example just add <code>config.php.example</code> with empty or example values.</p>
"
"12461944","<p>On a more theoretical level, I tend to think about levels for security in the following ways (in order of increasing strength) :</p>

<ul>
<li>No security.  Plain text.  Anyone that knows where to look, can access the data.</li>
<li>Security by Obfuscation.  You store the data (plaintext) someplace tricky, like an environment variable, or in a file that is meant to look like a configuration file.  An attacker will eventually figure out what's going on, or stumble across it.</li>
<li>Security provided by encryption that is trivial to break, (think caesar cipher!).</li>
<li>Security provided by encryption that can be broken with some effort.</li>
<li>Security provided by encryption that is impractical to break given current hardware.</li>
<li>The most secure system is one that nobody can use! :)</li>
</ul>

<p>Environment variables are <em>more</em> secure than plaintext files, because they are volatile/disposable, not saved;
   i.e. if you set only a local environment variable, like ""set pwd=whatever,"" and then run the script, 
   with something that exits your command shell at the end of the script, then the variable no longer exists. 
Your case falls into the first two, which I'd say is fairly insecure.  If you were going to do this, I wouldn't recommend deploying outside your immediate intranet/home network, and then only for testing purposes.</p>
"
"12734588","<p>Once someone gets access to your host, it's basically over.  Either approach, environment variables or a database.yml file, will still be retrievable if someone has access to your box.</p>

<p>I would recommend using environment variables in Heroku to store your database credentials.  As you know, you should never check in production credentials into any repository.</p>
"
"13271419","<p>You could use a <a href=""https://stackoverflow.com/questions/2316677/can-git-automatically-switch-between-spaces-and-tabs/2316728#2316728"">git attribute <strong>filter</strong> driver</a> and version:</p>

<ul>
<li><code>connectionStrings.basic.template</code> file</li>
<li><code>smudge</code> script in charge of creating the actual (not versioned) <code>connectionStrings.basic</code> if it doesn't exist, each time you checkout the repo (when the filter driver <a href=""https://stackoverflow.com/questions/2562523/using-git-to-work-with-subversion-ignoring-modifications-to-tracked-files/2562678#2562678"">detects the <em>content</em> of that template file</a>)</li>
<li>a clean script which would restore the original content of <code>connectionStrings.basic.template</code> (in the case of modifications to that template file) in order to keep the template file immutable.</li>
</ul>

<p><img src=""https://i.stack.imgur.com/VgbrX.png"" alt=""smudge on checkout""></p>

<p>See <strong><a href=""http://git-scm.com/book/ch7-2.html"" rel=""nofollow noreferrer"">git attributes</a></strong> for an example.</p>
"
"13542579","<p>You cannot hide just a part of the history if a Git repository; due to the way Git works, with each commit including the hash of previous commits, in order use a Git repository you need to have the full history.</p>

<p>However, you do have a few options. One would be to start a new repository with the current contents, and keep your old repository around. You can then give anyone who needs access to the old history the old repository. You can still view the full history across both repositories. You do this by adding remotes for each of the old and new, then using <a href=""http://www.kernel.org/pub/software/scm/git/docs/git-replace.html"" rel=""nofollow noreferrer""><code>git replace</code></a> to attach the last commit of the old repo to the first commit of the new. See the answer to <a href=""https://stackoverflow.com/questions/5724522/creating-github-repository-with-only-a-subset-of-a-local-repositorys-history"">this question</a> for more details. </p>

<p>Another option is to filter the history. You can use <a href=""http://www.kernel.org/pub/software/scm/git/docs/git-filter-branch.html"" rel=""nofollow noreferrer""><code>git filter-branch --tree-filter</code></a> to run a script on each commit in your history, which replaces all instances of your passwords with something like ""password"". This will preserve the full history, though all of your commits will get new commit IDs. See the answer to <a href=""https://stackoverflow.com/questions/2110595/redaction-in-git"">this question</a> for more details. </p>

<p>Both of these options will allow you to keep your full history, while not revealing your passwords. One thing to keep in mind if that they will change the actual commit IDs so you will need to make sure all of your working repositories are checked out from the new ones, not the old, or you could accidentally push the old history to one of your new repos. I would recommend changing any passwords that are in the old repo just in case, since once they are there, it may be easy to accidentally reveal them. </p>
"
"14058488","<p>If you consider your hosting environments to be secure, you could follow the approach of storing the login and pass in environment variables.  This is considered by some to be a best practice: <a href=""http://www.12factor.net/config"" rel=""nofollow"">http://www.12factor.net/config</a> (and it appears to be growing in popularity).</p>

<p>Then in your settings.py:</p>

<pre><code>  #If you want loud failures, usually the best
  EMAIL_HOST_USER = os.environ['EMAIL_USERNAME']
  EMAIL_HOST_PASSWORD = os.environ['EMAIL_PASSWORD']

  #If you want quiet failures, usually not a good idea
  EMAIL_HOST_USER = os.environ.get('EMAIL_USERNAME', None)
  EMAIL_HOST_PASSWORD = os.environ.get('EMAIL_PASSWORD', None)
</code></pre>

<p>How you set the environment variable depends on your setup, but it is usually very straight forward.</p>

<p>This approach has the advantage of keeping secrets out of the git repo, so you can add new collaborators to the project without fear that they're going to take over your AWS/email/etc account</p>
"
"14178004","<p>What I was looking for was guidance on how to deal with private keys.  Both @DrewV and @yfeldblum pointed me to the right direction.  I ended up turning my private key into a string and storing it in a Heroku config variables.</p>

<p>If anyone is looking to do something similar, here's a sample code snippit using paramiko:</p>

<pre><code>import paramiko, base64
import StringIO
import os

key = paramiko.RSAKey.from_private_key(StringIO.StringIO(str(os.environ.get(""AWS_PRIVATE_KEY""))))
ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
ssh.connect(str(os.environ.get(""EC2_PUBLIC_DNS"")), username='ec2-user', pkey=key)
stdin, stdout, stderr = ssh.exec_command('ps')

for line in stdout:
    print '... ' + line.strip('\n')
ssh.close()
</code></pre>

<p>Thanks to @DrewV and @yfeldblum for helping (upvote for both).</p>
"
"14235222","<p>You'll probably want to plug-in the access keys as a separate file in the source code, which you would avoid pushing to the public repository (or push with the actual keys deleted so someone wanting to use your application would need to plug-in their own key). That way everything is open source <em>except</em> your private keys themselves.</p>

<p>TL;DR: The only way to really avoid publishing your keys is not to make them part of the public source repo. Anything else means they are pretty trivially extractable by others.</p>
"
"14293659","<p>I found the answer after some Googling. In short, the answer is no.</p>

<p>And here's an excerpt from <a href=""https://developers.facebook.com/docs/concepts/login/access-tokens-and-types/"" rel=""nofollow"">Facebook</a>:</p>

<h1>Security Best Practices</h1>

<h2>App Secret and App Access Token</h2>

<p>The App Secret is used in some of the Login flows to generate access tokens and the Secret itself is intended to secure usage of your App to only those that are trusted. The secret can be used to easily create an App Access Token which can make API requests on behalf of any user of the app, which makes it extremely important that an App Secret is not compromised.</p>

<p>Therefore the App Secret or an App Access token should never be included in any code that could be accessed by anyone other than a developer of the app. This applies to all methods of code that are not secured like client-side code (such as HTML or Javascript) or native apps (such as iOS, Android or Windows desktop apps) that could be decompiled.</p>

<p>We recommend that App Access Tokens should only be used directly from your app's servers in order to provide the best security. For native apps, we suggest that the app communicates with your own server and the server then makes the API requests to Facebook using the App Access Token. For this reason, if your 'App Type' under Advanced Settings in the App Dashboard is set to Native/Desktop we assume that your native app contains the App Secret or an App Access Token in the binary, and we do not allow calls signed with an App Access Token to proceed. The API will behave as though no access token was provided.</p>

<p>If your App Secret is compromised, you should reset it immediately in the Basic Settings of your App Dashboard.</p>
"
"14551240","<p>One possible solution:</p>

<p>Commit and push a ""sample"" config file. Then, make the modifications you want to the local config file. It will now be marked as modified in Git.</p>

<p>Use <code>git update-index --assume-unchanged config</code> to permanently ignore future local modifications to the config file (use <code>--no-assume-unchanged</code> to resume tracking modifications).</p>

<p>This way, you will have a sample config in the upstream repo, a customized config in your repo, and you will not accidentally commit the changed config because Git will not mark it as modified.</p>
"
"14618156","<p>You don't have to handle this any differently than you do your database configuration files.</p>

<p>First, create <code>application/config/paypal.php</code>:</p>

<pre><code>// Change this information to match your settings
//$config['paypal_seekrit'] = '';
// whatever else
</code></pre>

<p>Note, create it <em>just</em> like that, as you're going to track it initially as a stub. Add it and commit it:</p>

<pre><code>git add application/config/paypal.php
git commit
</code></pre>

<p>Now, add it to <code>.gitignore</code> so it's no longer tracked locally. Add and commit <code>.gitignore</code>. Then, in your code, you need to then do something like this to make sure people remember to set things appropriately:</p>

<pre><code>$this-&gt;load-&gt;config('paypal');
$seekrit = $this-&gt;config-&gt;item('paypal_seekrit');
if ($seekrit === FALSE) {
    // config-&gt;item returns FALSE by default if item doesn't exist
    log_message('error', 'You need to configure config/paypal.php!');
    // bail out, if appropriate
    show_error('Paypal keys have not been configured');
}
</code></pre>

<p>At this point you can push. Everyone now has a stub of the file, and nothing anyone does on their end will be in danger of being pushed back. The drawback is, if you need to change the default stub to add or remove an option, you (and everyone else) will need to merge. But, it's such a trivial file, I don't consider that an issue.</p>

<p>Then, add your secret keys to the file without worrying about accidentally committing and pushing them. Note, if using it in a library you first have to call <code>get_instance()</code> to get at the framework super object (singleton), e.g:</p>

<pre><code>$CI = get_instance();
$CI-&gt;load-&gt;config('paypal');
$seekrit = $CI-&gt;config-&gt;item('paypal_seekrit');
...
</code></pre>

<p>One of the first things I do on a new CI project is commit <code>application/</code> and then stop tracking certain files in <code>application/config</code>.</p>

<p>You can also just make a catch all config file for site specific settings that overrides all previously loaded configurations and stick it in there (something like <code>config/appname.php</code>). Just be sure to do it in a way where the config / loader class work as someone would expect them to work.</p>
"
"15327779","<p>Although I wasn't able to come across anything Python-specific on stackoverflow, I did find a <a href=""http://opensourcehacker.com/2012/12/13/configuring-your-python-application-using-environment-variables/"" rel=""noreferrer"">website that was helpful</a>, and thought I'd share the solution with the rest of the community. </p>

<p>The solution: environment variables. </p>

<p>Note: Although environment variables are similar in both Linux/Unix/OS X and in the Windows worlds, I haven't tested this code on a Windows machine. Please let me know if it works. </p>

<p>In your bash/sh shell, type:</p>

<pre><code>export MYAPP_DB_USER='myapp'
export MYAPP_DB_PASSWORD='testing123'
</code></pre>

<p>And in your Django settings.py file:</p>

<pre><code>DATABASE_USER = os.environ.get(""MYAPP_DB_USER"", '')
DATABASE_PASSWORD = os.environ.get(""MYAPP_DB_PASSWORD"", '')
</code></pre>

<p>In this case, the username and password would default to an empty string if the environment variable didn't exist. </p>
"
"15601529","<p>There are a few methods to accomplish this. All of them require the cooperation of everybody who has cloned your repository or pulled changesets from it after the change was introduced.</p>

<p>Which method to use depends on the exact nature of the committed data and where it is in the history. All of them require the use of Mercurial extensions and cannot be accomplished with core Mercurial. Luckily, all the required extensions are shipped by default with Mercurial and simply have to be enabled.</p>

<p>I'm not going into detail about the methods here as there are several answers that give different methods in the question this is a dupe of. I just want to be clear that the accepted answer in that question is technically correct, but not useful. It is actually possible.</p>
"
"16240800","<p>The solution I eventually chose was to move all the sensitive strings inside a <strong>web.config</strong> file (or <strong>app.config</strong>), then encrypt the sensitive sections of it. I then let the operating system and the ASP.NET runtime to handle encryption/decryption. Not perfect (after all you do need to have the original app/web.config file holding the plaintext data - but at least it doesn't have to be on the production machine), but quite convenient.</p>
"
"16380148","<p>Putting that info in other file, for instance an YML, and referencing it on your Rakefile? The YML would be on you .gitignore to avoid committing personal information.</p>

<p>Example of .YML file:</p>

<pre><code>app:
  codesign_certificate: ""iPhone Developer: Name Goes Here (12SELC3456)""
</code></pre>

<p><strong>EDIT</strong></p>

<p>For more info how to read an YML file: <a href=""https://stackoverflow.com/questions/3877004/how-do-i-parse-a-yaml-file"">How do I parse a YAML file</a></p>
"
"16446566","<p>I looked into this a lot and played with a lot of different approaches. However, Pyramid is so flexible, and the <code>.ini</code> config parser is so minimal in what it does for you, that there doesn't seem to be a de facto answer.</p>

<p>In my scenario, I tried having a <code>production.example.ini</code> in version control at first that got copied on the production server with the details filled in, but this got hairy, as updates to the example didn't get translated to the copy, and so the copy had to be re-created any time a change was made. Also, I started using Heroku, so files not in version control never made it into the deployment.</p>

<p>Then, there's the encrypted config approach. Which, I don't like the paradigm. Imagine a sysadmin being responsible for maintaining the production environment, but he or she is unable to change the location of a database or environment-specific setting without running it back through version control. It's really nice to have the separation between environment and code as much as possible so those changes can be made on the fly without version control revisions.</p>

<p>My ultimate solution was to have some values that looked like this:</p>

<pre><code>[app:main]

sqlalchemy.url = ${SQLALCHEMY_URL}
</code></pre>

<p>Then, on the production server, I would set the environment variable <code>SQLALCHEMY_URL</code> to point to the database. This even allowed me to use the same configuration file for staging and production, which is nice.</p>

<p>In my Pyramid init, I just expanded the environment variable value using <a href=""http://docs.python.org/2/library/os.path.html#os.path.expandvars""><code>os.path.expandvars</code></a>:</p>

<pre><code>sqlalchemy_url = os.path.expandvars(settings.get('sqlalchemy.url'))
engine = create_engine(sqlalchemy_url)
</code></pre>

<p>And, if you want to get fancy with it and automatically replace all the environment variables in your settings dictionary, I made this little helper method for my projects:</p>

<pre><code>def expandvars_dict(settings):
    """"""Expands all environment variables in a settings dictionary.""""""
    return dict((key, os.path.expandvars(value)) for
                key, value in settings.iteritems())
</code></pre>

<p>Use it like this in your <code>main</code> app entry point:</p>

<pre><code>settings = expandvars_dict(settings)
</code></pre>
"
"16695626","<p>Set the secret as an environment variable, then when developers use your open source app they can replace it with their own Dropbox key.  </p>

<p>Then, exclude the file with the environment variables from your source control.</p>

<p>You could additionally put in some handling that raises a specific exception if the environment variable isn't set, so they know what's missing and what they have to do.</p>

<p>I doubt you need everyone who uses your app using your secret key, and most developers won't want to anyway, in case you ever remove it.</p>
"
"17483596","<p>You could use .gitatrributes to filter the contents:</p>

<ul>
<li><p>.gitattributes</p>

<pre><code>secrets.h filter=secret merge=keepMine
</code></pre></li>
<li><p>.git/config</p>

<pre><code>[filter ""secret""]
clean  = echo ""// replace the next line with the sensitive data""
smudge = cat

[merge ""keepMine""]
    name = always keep mine during merge
    driver = /bin/true %O %A %B
</code></pre></li>
</ul>

<p>I threw in a 'keepMine' merge to prevent accidental merges. However, AFAIK merge should not even kick in, as local changes would be effectively 'invisible' due to the <code>clean</code> filter step. Regardless of what's actually in <code>secrets.h</code>, the repo file will always contain:</p>

<pre><code>// replace the next line with the sensitive data
</code></pre>

<p>E.g.:</p>

<blockquote>
  <p><strong><code>/tmp/work$</code></strong> <code>echo '// agent 007 reporting for duty' &gt; secrets.h</code><br/>
  <strong><code>/tmp/work$</code></strong> <code>git status -s</code><br/>
      <code>M secrets.h</code><br/>
  <strong><code>/tmp/work$</code></strong> <code>git diff</code><br/>
  <strong><code>/tmp/work$</code></strong> <code>git cat-file -p HEAD:secrets.h</code><br/>
     <code>// secret contents not in repo</code><br/></p>
</blockquote>
"
"17889113","<h2>Use Config Vars with Heroku Toolbelt</h2>

<p>You can set environment variables via the command line with <a href=""https://toolbelt.heroku.com/"" rel=""nofollow"">Heroku Toolbelt</a>. The process is <a href=""https://devcenter.heroku.com/articles/config-vars"" rel=""nofollow"">described in detail</a> in the Heroku documentation, but as an example:</p>

<pre><code># Set FOO as an environment variable for your app.
$ heroku config:set FOO=bar

# Access FOO from inside your Heroku app.
puts ENV['FOO']
</code></pre>
"
"18090093","<p>I would recommend building an encryption system that encrypts the data before it gets sent to the xml file then instead of searching for the username or whatever you encrypt the name before you search. This way even if a person managed to get into the file the wont be able to read it without having the algorithm used for encrytion and knowing exactly what they wanted to find. Well theoretically they could brute force it, but they still need to know the algorithm to do that. An easy way to handle encrytion would be to learn how to use the bouncy castle libs at <a href=""http://www.bouncycastle.org/"" rel=""nofollow"">http://www.bouncycastle.org/</a> . They have a very easy to use/learn system.</p>
"
"18154433","<p>It really depends on how secret the keys are.</p>

<p>If they're tied to a user account like for AWS, then I would say to absolutely not include them in the SCM.  In that case, the app should check the environment variables to load a key file from the user's directory.</p>

<p>If they're more designed to be per app, then it would reasonable to include the key in the source tree.</p>

<p>Now, if you're developing a library.  It would reasonable to include your key in the source tree under the tests but not to include it the binary distributions.</p>

<p>One thing I will suggest, is that you put the key under different copyright terms than the rest of the library.  That way, if someone forks your code, you can force them to get their own key.</p>
"
"18168273","<p>You can move a single section of Web.config to a separate file.</p>

<p>In Web.config, <a href=""http://msdn.microsoft.com/en-us/library/system.configuration.sectioninformation.configsource"" rel=""noreferrer"">write</a></p>

<pre><code>&lt;connectionStrings configSource=""connectionStrings.config"" /&gt;
</code></pre>

<p>Then, move the original element to a separate <code>connectionStrings.config</code> (or any other filename) and add it to gitignore.</p>
"
"18391757","<p>I usually advise that people use the ""template"" pattern in this case.</p>

<p>For example, you have some <code>application.settings</code> file that contains things like database passwords, port bindings. etc.  Copy that file to <code>application.settings.template</code> and strip out all of the site-specific information, such as passwords and endpoints, leaving behind only the settings you want to be the default.</p>

<p>Then, add <code>application.settings</code> to your <code>.gitignore</code>.  Any time you introduce a new setting you will have to adjust both files, but this allows others to very easily see what has to be configured by looking for <code>*.template</code> files.  They would only need to copy those and remove the <code>.template</code> extension, then customize them as necessary.</p>

<p>This has some advantages:</p>

<ol>
<li>The deployed settings won't be clobbered if someone is foolish enough to <code>git reset --hard</code> in production, as the actual settings file is not tracked by Git.</li>
<li>A developer won't be prevented from checking out a different branch because of local configuration changes (normally one would have to <code>git stash &amp;&amp; git checkout other-branch &amp;&amp; git stash pop</code> if the target branch has a different settings file than the current branch, and the developer has made local changes to the settings file).</li>
<li>As the actual settings file is ignored, it is very difficult to accidentally push it to a remote repository by accident.</li>
</ol>

<p>A disadvantage is that new/modified settings in the template can't be merged in to a deployed setting file (but if you are in production you probably want to inspect the differences in the template file and apply those by hand anyway).  One will have to manually <code>git diff HEAD HEAD@{1} -- application.settings.template</code> after pulling or checking out a new branch to see what changed in the settings template.</p>
"
"18651069","<h2>try the BFG instead of git filter-branch...</h2>

<p>You can use a <em>much</em> more friendly substitution format if you use <a href=""http://rtyley.github.io/bfg-repo-cleaner/"" rel=""nofollow"">The BFG</a> rather than <code>git-filter-branch</code>. Create a <code>passwords.txt</code> file, with one password per line like this:</p>

<pre class=""lang-bsh prettyprint-override""><code>PASSWORD1==&gt;xXxXx      # Replace literal string 'PASSWORD1' with 'xXxXx'
ezxcdf\fr$sdd%==&gt;xXxXx # ...all text is matched as a *literal* string by default
</code></pre>

<p>Then <a href=""http://rtyley.github.io/bfg-repo-cleaner/#usage"" rel=""nofollow"">run the BFG</a> with this command:</p>

<pre><code>$ java -jar bfg.jar -fi '*.php' --replace-text passwords.txt  my-repo.git
</code></pre>

<p>Your entire repository history will be scanned, and all <code>.php</code> files (under 1MB in size) will have the substitutions performed: any matching string (that isn't in your <em>latest</em> commit) will be replaced.</p>

<h2>...no escaping needed</h2>

<p>Note that the only bit of parsing the BFG does with here with the substitution file is to split on the '<code>==&gt;</code>' string  - which probably <em>isn't</em> in your passwords - and all text is interpreted literally by default.</p>

<p>If you want to be even more concise, you can drop the '<code>==&gt;</code>' and everything that comes after it on each line (ie, <em>just have a file of passwords</em>) and The BFG will replace each password with the string '<code>***REMOVED***</code>' by default.</p>

<p>The BFG is typically <a href=""http://rtyley.github.io/bfg-repo-cleaner/#speed"" rel=""nofollow"">hundreds of times faster</a> than running <code>git-filter-branch</code> on a big repo and the options are tailored around these two common use-cases:</p>

<ul>
<li>Removing <strong>Crazy Big Files</strong></li>
<li>Removing <strong>Passwords, Credentials</strong> &amp; other <strong>Private data</strong></li>
</ul>

<p><em>Full disclosure: I'm the author of the BFG Repo-Cleaner.</em></p>
"
"18724759","<p>Create a new file called .gitignore at the root of your new project (e.g. next to the composer.json file) and paste the following into it. Files matching these patterns will be ignored by git:</p>

<pre><code>/web/bundles/
/app/bootstrap*
/app/cache/*
/app/logs/*
/vendor/
/app/config/parameters.yml
</code></pre>

<p>Copy <code>app/config/parameters.yml</code> to <code>app/config/parameters.yml.dist</code>. The <code>parameters.yml</code> file is ignored by git (see above) so that machine-specific settings like database passwords aren't committed. By creating the <code>parameters.yml.dist</code> file, new users can quickly clone the project, copy this file to <code>parameters.yml</code>, customize it, and start using it.</p>

<p>The code of your application can be licenced under any open source licence. Choose one, which you like. Also edit your <code>composer.json</code> reflecting the choosen licence, a propper package name and so on.</p>
"
"18830740","<p>You should only push a config- sample in the repo and gitignore the ""real"" config, because every instance will have its own config. After you deployed the repo on your production system you copy/create the config based on the sample, fill in your ""personal"" settings and you are done. </p>
"
"18863954","<p>You can go about this in at least two ways:</p>

<ul>
<li>track a sample, munged version of the configuration file, ignoring the actual version</li>
<li>commit a munged version of the configuration file and then ignore it from future tracking</li>
</ul>

<h3>Track munged sample version</h3>

<p>Put the configuration files explicitly in .gitignore (no wildcards, e.g. <strong>/config/database.php</strong>) and create a copy that has the same contents, except the keys and other sensitive data is replaced with NULLs or XXXs and save that into a file like <strong>/config/database-sample.php</strong> and track, commit and push that. </p>

<p>Maybe even <a href=""https://stackoverflow.com/questions/9342886/git-best-practice-for-config-files-etc/9343239#9343239"" title=""another case on config files"">using symbolic links between the two</a>.</p>

<h3>Ignore with munging</h3>

<p>Or you can commit a munged version, push that, then drop it <a href=""http://git-scm.com/docs/git-update-index"" rel=""nofollow noreferrer"">from the index with --assume-unchanged</a></p>

<pre><code>git update-index --assume-unchanged &lt;file&gt;
</code></pre>

<p>Any changes now to the file will not be seen by Git and you can then edit back in the keys.</p>

<p>In both methods you keep the structure of the project files (roughly) available for others to clone and edit as necessary for their local or development repo without having to guess that there are holes to fill.</p>
"
"18920852","<p>In Zend 2 There are  </p>

<ol>
<li>Global configuration file &amp;</li>
<li>Module level configuration file</li>
</ol>

<p>IF you want to know there use you can refer the link below </p>

<p><a href=""http://zf2.readthedocs.org/en/latest/tutorials/config.advanced.html"" rel=""nofollow"">How does configuration works in ZF2 </a></p>

<p>When I had a same scenario I   used the above link to understand and exploit Zend Config module which is really good to handle the situation like this  . </p>

<p>create two files  </p>

<p>production.php 
local.php</p>

<p>in both these files </p>

<p>return this array based on the environment  </p>

<pre><code>return array(
     ""dbname"" =&gt; ""yourdbname""
     ""dbhostname"" =&gt; ""dbhostname""
     ""dbusername"" =&gt; ""yourdbusername"",
     ""dbpassword"" =&gt; ""yourdbpassword""
 );
</code></pre>

<p>in config/autoload/ directory of your zend framewrok application </p>

<p>later edit your config/application.config.php file as per below instructions </p>

<p>// get the application env from Apache vhost file ( here you can set in your apache vhost file as production or local ) </p>

<pre><code>$applicationEnv = getenv('APPLICATION_ENV');
</code></pre>

<p>$environmentSpecificConfigPath = ""config/autoload/{,*.}{"".$applicationEnv."",local}.php"";</p>

<p>// Next with in the config array pass the environment specific configuration path </p>

<pre><code> 'config_glob_paths' =&gt; array($environmentSpecificConfigPath)
</code></pre>

<p>in any controller or action  </p>

<p>you can just use the below code </p>

<pre><code> $configArray = $this-&gt;getGlobalConfig(); 
</code></pre>

<p>Now $configarray has all your DB credentials to create a connection </p>

<pre><code>$adapter = new Zend\Db\Adapter\Adapter(array(
    'driver' =&gt; 'Mysqli',
    'database' =&gt; $configArray['dbname'],
    'username' =&gt; $configArray['dbusername'],
    'password' =&gt; $configArray['dbpassword']
 ));
</code></pre>

<p>If you use config array to connect the DB in your entire application 
you dont need to worry about environment changes just make sure you have an Apache APPLICATION_ENV entry in your vhost file </p>

<p>you can do that by adding below line in your apache vhost file </p>

<pre><code> SetEnv APPLICATION_ENV ""production"" // in your production server 

 SetEnv APPLICATION_ENV ""local""  // in your local 
</code></pre>

<p>Also Last but not least you can use the Zend Experts module ZeDB </p>

<p><a href=""https://github.com/ZendExperts/ZeDb"" rel=""nofollow"">https://github.com/ZendExperts/ZeDb</a></p>

<p>To manage your CRUD applications </p>

<p>Hope the above steps may help you in creating the environment </p>
"
"19331193","<blockquote>
  <p>The only solution I have in mind is to put all these sensitive variables in a class and simply not add that class to Git.</p>
</blockquote>

<p>Yes, that's how to do it.  Or better yet, leave credentials out of your code entirely, and put them in a configuration file (which you don't check into Git).  The key part of this is ""don't check it in to Git"", at least, not if you want to share your repository.</p>

<p>Be warned that if you ever did check in those credentials, and you publish the repository, someone can look through history to find them.  There are ways to scrub sensitive data from the repository history but it can be tricky to get it right.</p>
"
"19392065","<p>Here is what I did in the end for <a href=""https://github.com/amarchen/Wikipedia"" rel=""nofollow"">https://github.com/amarchen/Wikipedia</a> :</p>

<ol>
<li><p>Main public git project has a submodule pointing to a private git repository. This submodule is checked into something like ""settings/AppStoreKeys"" directory</p></li>
<li><p>If you do not have access to the private repo, component will fail to be checked out and you won't have any files inside the subdirectory. The rest of the public repo will work just fine without any git errors or whatever. 3rd party users of your code may not even notice there is a private settings submodule unless you use some other components.</p></li>
<li><p>If you do have access to the private repo, you fetch the component via ""git submodule init"" and ""git submodule update"". That creates your private files in settings/AppStoreKeys</p></li>
<li><p>At runtime your code checks for the existence of files in settings/AppStoreKeys and reads settings from there or falls back to something default</p></li>
</ol>

<p><em>Downsides</em>
For my purposes it works just fine. It's a demo app, I just don't want people studying the code to overuse the real app mixpanel keys (and whatever other keys). I also don't care about a potential need to use the other keys - it's a demo app, not for supported forks.</p>

<p>However, this approach exposes the address of my private repo to everybody and that's not very cool. For the more serious cases I would probably go the other way around and created a private project that would be just a wrapper (plus private keys) for the public library and maybe a public app wrapper.</p>
"
"19523601","<p>The answer is to not publish that information to GitHub in the first place.</p>

<p>When I worked with Twilio applications, I used a <code>localsettings.py</code> (Python, but should be the same for Ruby) file holding the sensitive information that I downloaded and distributed out-of-band.</p>

<p>A user-friendly interface could be a setup script to download this file from a server credentials.</p>

<p>Alternatively, if you <em>must</em> check it into github, encrypt it symmetrically with something like gnupg and decrypt it on your host machine.</p>

<p>In all these cases, you have to be careful not to accidentally check it in to git. Adding <code>localsettings.rb</code> to your <code>.gitignore</code> file is a great idea.</p>

<p>(If you've <em>already</em> pushed it to github, see <a href=""https://help.github.com/articles/remove-sensitive-data"" rel=""nofollow"">here</a> for how to undo that.)</p>
"
"19604260","<p>I stored the config files in a private S3 bucket and manage access via IAM. The configuration updates and revisions are handled by a small script using the AWS gem. That way anybody with sufficient privileges can access them, and we also can issue access credentials for each developer separately.</p>
"
"19623494","<p>Sensitive data should not be in source control - you should use Heroku config variables which will then be exposed as environment variables in your application. Read more on the Heroku site at <a href=""https://devcenter.heroku.com/articles/config-vars"" rel=""nofollow"">https://devcenter.heroku.com/articles/config-vars</a></p>
"
"19752873","<p>What I usually do in these cases is allow for a two layered configuration where the default set of properties is versioned and committed with the source, but then developers can supply an external file that will be used if discovered, and will replace the defaults on a per setting basis. This is not only useful for externalizing credentials, but it also lets you default things like thread count, connection pool size, etc.. that can be overridden if desired. Importantly, they can see the full structure always. You your self would have your own external overrides file with the real credentials you use. But the defaults are fake ones that you check in. </p>

<p>I know you are using PHP, for java as an example, it would look roughly like this:</p>

<pre><code>Properties defaultProps = loadDefaults();
Properties overrideProps = loadOverridesIfFound();
for(String name : overrideProps.keySet()) {
   defaultProperties.put(name,overrideProps.get(name));
}
</code></pre>

<p>I have found this technique to be very effective for many projects.</p>
"
"19916461","<blockquote>
  <p>My application is open source, but I do not want to have the key publicly visible in my repository.</p>
</blockquote>

<p>Put the key in a string resource, in a separate resource file (e.g., <code>res/values/omg_do_not_commit_this_to_the_repo.xml</code>). Then, do not commit that file to the repo (e.g., if you are using Git, add the file to <code>.gitignore</code>).</p>
"
"20418404","<p>One way is to store:</p>

<ul>
<li>one different configuration file per environment</li>
<li>one template file</li>
<li>one script able to detect the current environment the git repo is cloned in, and generate the actual configuration file (which isn't versioned) used for that local environment.</li>
</ul>

<p>That generation can be automated on checkout, with a smudge script declared as a <a href=""https://stackoverflow.com/a/11961257/6309""><strong>content filter driver</strong></a>.</p>

<p><img src=""https://i.stack.imgur.com/mFYak.png"" alt=""enter image description here""></p>
"
"20441056","<p>Try <code>git push -f</code> to force it, without pulling.  Note that this command is somewhat dangerous, and should not be used without thought.</p>
"
"20723814","<p>Solved with a bit of luck. The command I mention above must be spaced and lined as it appears on their 'Removing Sensitive Data' page. </p>

<p>So this:</p>

<pre><code>git filter-branch --force --index-filter \
'git rm --cached --ignore-unmatch php/initialize.php' \
--prune-empty --tag-name-filter cat -- --all
</code></pre>

<p>Is not the same as this:</p>

<pre><code>git filter-branch --force --index-filter \ 'git rm --cached --ignore-unmatch php/initialize.php' \ --prune-empty --tag-name-filter cat -- --all
</code></pre>
"
"21031713","<p>First, here's the important bit: <strong>Consider your credentials compromised. Change them. No matter what you do at this point, they are no longer secure.</strong></p>

<p>Now that yo've done that, you have a couple of options:</p>

<ul>
<li><p>If you really just want to start from scratch, overwrite what's there with new commits using <code>git push --force</code>. This is likely your easiest path forward.</p>

<pre><code>git init &lt;new-directory&gt;
$EDITOR README.md
git add README.md
git commit
git remote add origin https://github.com/user/repo.git
git push --force origin master
</code></pre></li>
<li><p>Alternatively, you can remove the credentials from the history with <code>filter-branch</code>, as outlined on the <a href=""https://help.github.com/articles/remove-sensitive-data"">GitHub help page on removing sensitive data</a>.</p>

<p>Your <code>ambiguous argument 'rm'</code> error is likely to do with quoting the command properly. Make sure to quote it as it shows in the article.</p></li>
</ul>
"
"21278686","<p>Maybe it's easier if you just don't use a key. It's an optional feature so Google can track your API usage for example if you need to purchase additional quota.</p>
"
"21450090","<p>The only way to purge that diff is with a force push. If multiple people are working on that same branch, you'd best let them know that you're rewriting history.</p>

<p>Assuming it was your last commit...</p>

<pre><code>git reset --soft HEAD~
(undo password changes)
git diff
(make sure there are no changes that display the passwords)
(stage/commit changes)
git push origin +branch_name
</code></pre>

<p>Following standard security precautions, I would also reset those passwords if they're linked to sensitive data...</p>
"
"21941683","<p>In short, no. If your GitHub repo is public, all its assets are public. You can make the repo private and it will still publish on GitHub Pages if named with the <code>username.github.io</code> convention or if it has a <code>gh-pages</code> branch. While that's an option, that's not necessarily the right thing to do.</p>

<p>If your key is in your GitHub Pages repo, it sounds like it's used for client-side API calls in JavaScript. If so, your auth token is publicly visible whether it's in your public repo or sent in your client-side files to the browser. This is usually fine. The third-party API might have generated the auth token based on your website's domain, and restrict calls using that token to pages originating on your domain. Otherwise, they might require the auth token only for logging requests and monitoring usage.</p>

<p>If the auth token is truly meant to be private, then you may need to write private server-side code to call the third-party API. Your GitHub Pages site could then hit your service for the data it needs. I've had to do that before where the web API had security concerns, but I still needed to retrieve non-sensitive data from the client-side.</p>
"
"22135304","<p>Put them in a external file that you never commit. that's most convenient IMO.</p>

<p>e.g. have a keys.plist and in the appDelegate, just read the keys.plist</p>

<hr>

<p>Of course another way that is quite error prone is to blank them using <em>*</em> before you commit your source but... nah.. :P</p>
"
"22348862","<p>Not sure whether this is the best practice, but personally I have a <code>config.json</code> file where I store my db connection information. Then I do the following:</p>

<pre><code>// options.js
var fs = require('fs'),
configPath = './config.json';
var parsed = JSON.parse(fs.readFileSync(configPath, 'UTF-8'));
exports.storageConfig=  parsed;
</code></pre>

<p>Then from a different file I do the following:</p>

<pre><code>var options = require('./options');

var loginData = {
        host: options.storageConfig.HOST,
        user: options.storageConfig.user,
        password: options.storageConfig.password
};
</code></pre>
"
"22672839","<p>This is really an SVC question, and from that point of view you want to simply add the configuration to a single file and have that file ignored by SVC.</p>

<p>Generally, I would add into the 'read me' file that this configuration file needs to be created at a specified location before the project will be valid.</p>

<p>Then, add the file to the project and give it target membership (so it's copied into the bundle at build time). Now, in the code, you can use something like:</p>

<pre><code>[[NSBundle mainBundle] pathForResource:@""accountConfig"" ofType:@""plist""];
</code></pre>

<p>to get the path to the file to load.</p>
"
"24469119","<p>In this case, you should use RUN@cloud <a href=""https://developer.cloudbees.com/bin/view/RUN/Configuration+Parameters"" rel=""nofollow"">configuration parameters</a>. These are encrypted and can be accessed using system properties.</p>
"
"25007495","<p>If you use this key <code>&lt;%= ENV[""SECRET_KEY_BASE'] %&gt;</code></p>

<p>On your local machine you can set environment vars in your shell, like (bash or zsh)</p>

<pre><code>export SECRET_KEY_BASE=""yourkeybasehere""
</code></pre>

<p>And simulate that you run on production (but at your local machine) like</p>

<pre><code>RAILS_ENV=production rails s
</code></pre>

<p>However, deploying on Heroku, you can use what they call config vars, by running <code>heroku config:set</code> command for your app.</p>

<pre><code>heroku config:set SECRET_KEY_BASE=yourkeybasehere
</code></pre>

<p>Then the Rails app will populate this config var into secret.yml</p>

<pre><code>production:
  secret_key_base: yourkeybasehere
</code></pre>

<p>Hope this explains thing you need to understand.</p>

<p>Though, if you would like to play and test.
One option is trying to edit your app/views/layouts/application.html.erb file and put the config var you want to display, for instance USERNAME config var</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;&lt;%= ENV['USERNAME'] %&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Then deploy to heroku and run</p>

<p><code>heroku config:set USERNAME=gwho</code></p>

<p>You should see 'gwho' at the page title.</p>

<p>More details about Heroku config vars: <a href=""https://devcenter.heroku.com/articles/config-vars"" rel=""nofollow"">https://devcenter.heroku.com/articles/config-vars</a></p>

<p>More details about Rails 4.1 secrets.yml: <a href=""http://edgeguides.rubyonrails.org/4_1_release_notes.html#config/secrets.yml"" rel=""nofollow"">http://edgeguides.rubyonrails.org/4_1_release_notes.html#config/secrets.yml</a></p>
"
"25038790","<p>You could create an initializer with your API constants and add it to <code>.gitignore</code>:</p>

<pre><code># config/initializers/secrets.rb

API_KEY = 'my_api_key'
API_SECRET_KEY = 'my_api_secret_key'
</code></pre>

<p>You could add them to <code>config/environments/development.rb</code> as suggested by @engineersmnky in the comments, but you typically <em>want</em> to add <code>development.rb</code> into version control.</p>
"
"26025030","<p>This is a situation of trust and exposure. Do you trust those that have access to the repository? Bear in mind that most compromises come from insiders.</p>

<p>My thinking is this:</p>

<ul>
<li>Don't store the deployed certificates at all. Generate them for those end systems. Sign them by a root certificate.</li>
<li>Configure your produce to trust connections made by certificates signed by that root. This way you can revoke certificates in mass if your root is compromised or selectively revoke endpoint certificates as necessary without revoking everything.</li>
<li>You can have your product reference the certificate from the system's certificate store using any public identifiers but don't store the private key.</li>
<li>Making the private key available should be a final deployment step with as minimal visibility as possible. Make it available to two or three users and use the platform's certificate management mechanisms for tying the public certificate to the private key.</li>
</ul>
"
"26085465","<ol>
<li>Do not store sensitive data in any code versioning system. Keep the variables empty.</li>
<li>After first checkout, set the variables locally.</li>
<li>In case of distributed/remote databases, simply create another access for that user to access that database and provide credentials.</li>
<li>Once you set the values, exclude these files from being updated later.</li>
</ol>
"
"26608418","<p>If it's on the client side, it's impossible to ever be 100% secure without server verification: you can't encrypt a decryption key, you have to leave it in plaintext somewhere.</p>

<p>At the same time it's normally sufficient to just add a verification to the licence - eg the certificate has a line which is the hash of the certificate, plus a salt hardcoded in your application. If the user tries to edit their licence, the hash will change and you can throw an error.</p>

<p>With decryption keys, you should look at public/private key pairs, but as above, you can't encrypt the decryption key (at least, not without storing another unencrypted key)</p>
"
"28242419","<p><strong>It is <em>vital</em> that you nullify the compromised OAuth information and generate new credentials. I recommend doing this even before you worry about cleaning up your history.</strong></p>

<p>Unfortunately, there are bots that look for this kind of stuff:</p>

<ul>
<li><a href=""http://www.devfactor.net/2014/12/30/2375-amazon-mistake/"" rel=""nofollow"">http://www.devfactor.net/2014/12/30/2375-amazon-mistake/</a></li>
<li><a href=""http://wptavern.com/ryan-hellyers-aws-nightmare-leaked-access-keys-result-in-a-6000-bill-overnight"" rel=""nofollow"">http://wptavern.com/ryan-hellyers-aws-nightmare-leaked-access-keys-result-in-a-6000-bill-overnight</a></li>
</ul>

<p>Your <code>filter-branch</code> command looks good¹. Once you get your history cleaned up locally, you'll need to force push to GitHub:</p>

<pre><code>git push origin --force --all
</code></pre>

<p>The offending commits will remain on GitHub until <code>git-gc</code> is run on the server. You could wait for this to happen, or you could <a href=""https://github.com/contact"" rel=""nofollow"">submit a support ticket</a> asking for it to be run on your repository.</p>

<p>¹Make sure that the full filename, including extension, matches the <code>... ""git rm --cached --ignore-unmatch config"" ...</code> part.</p>
"
"28258713","<p>The <code>sed</code> that comes with MacOS X is BSD sed, not GNU sed, and <s>it cannot change files in place without making a backup - the</s> its <code>-i</code> flag always takes an argument that is the suffix the backup file will have. In your call, <code>-i -e</code> is parsed as one flag, telling sed to edit the file in place and put a backup in <code>filename-e</code>. That is the reason you get a lot of <code>.rb-e</code> files.</p>

<p>The most practical solution, I believe, is to just delete the backup files afterwards. That is, </p>

<pre><code>git filter-branch --tree-filter ""find . -type f -exec sed -i.bak 's/password/REDACTED/g' {} \; -exec rm '{}'.bak \;""
</code></pre>

<p>I took the liberty of replacing <code>-e</code> with a more sensible filename extension (<code>.bak</code>). <strong>Make sure to use a suffix that does not clash with files that you want to preserve.</strong> You can put the <code>-e</code> back in there if you like, but it's not necessary in this case.</p>

<p>EDIT: @torek notes that BSD sed can edit files in place if its <code>-i</code> flag is given an empty string as argument (i.e., <code>''</code>); working mostly with GNU sed, I did not know that. Nevertheless, I feel that allowing sed to generate a backup file is better practice than using <code>-i ''</code>. In the above <code>find</code> call, the command in the second <code>-exec</code> will only be executed if the command in the first reported successful completion (because <code>-exec</code> is also a filter), so with it, you'll still have the backup file if sed comes back with an error. And when things go wahoonie-shaped, backups are nice to have.</p>
"
"28526199","<p>You have to be exceedingly careful to make sure your secret bits are not pushed to the remote repository.  For example, if you merge from <code>secret</code> to <code>master</code> or accidentally push <code>secret</code>, they get out. See <a href=""https://stackoverflow.com/q/13877469/123109"">How to disable git push when there are TODOs in code?</a> for implementing the policy with a hook, but a hook can fail its intended purpose too.</p>

<p>Even though, yes, it is technically possible to keep secret bits secluded in your own local git repository, I recommend leaving sensitive data out of your repository completely and instead placing them in configuration or source files, possibly excluded in <code>.gitignore</code> depending on their respective locations.</p>
"
"28606725","<p>Connection to production database from unit tests is not the best approach. You should have test database with the same schema. 
<a href=""https://stackoverflow.com/questions/145131/whats-the-best-strategy-for-unit-testing-database-driven-applications"">What&#39;s the best strategy for unit-testing database-driven applications?</a></p>

<p>Having connection string outside the code can not hide user and password. Developer can still debug unit tests and see connection string.</p>
"
"30534003","<p>You could create a new .env on your ec2 instance and add all the env vars in there. One option would be ssh-ing into the box and creating the file via vi or cat. Or you could write a script to remotely pull the .env in from an external location.</p>

<p>You could also ssh into the box and <code>export APP_ENV=production</code> all your env vars (assuming that's the right command for your OS).</p>

<p>Adding env vars to your environment will depend on the OS that your ec2 instance is running, so the solution will depend on that. ec2 has a concept of 'tags' which might be useful, but the docs show they limit the number of tags to 10, so you may have to do it manually and per ec2 instance :/</p>

<p>See <a href=""https://stackoverflow.com/questions/28643573/how-to-set-an-environment-variable-in-amazon-ec2"">here</a> for one method that uses tags to pull in and set env vars (non-laravel specific). </p>

<p>I just went through this yesterday while getting Laravel running on Elastic Beanstalk, the solution was clean. You can actually set the env vars directly via the aws console (EB app/environment -> Configuration -> Software Configuration -> Environment Properties).</p>

<p>Update: </p>

<p>The key concept to understand is that Laravel just uses <a href=""https://github.com/vlucas/phpdotenv"" rel=""noreferrer"">phpdotenv</a> to dump vars from the .env file into php's global <code>$_ENV</code>, whereas any already existing env vars are automatically included in <code>$_ENV</code> when php starts the server (<a href=""http://php.net/manual/en/reserved.variables.environment.php"" rel=""noreferrer"">docs</a>). So the .env file itself is unnecessary, really just a dev convenience. (unless I've just been spoiled by elastic beanstalk so far).</p>
"
"30673696","<p>You should be able to specify sensitive values as environment variables from eb web console: Your EB app -&gt; Your EB environment -&gt; Configuration -&gt; Software Configuration -&gt; Environment Properties</p>
<p>Alternatively, you can make use of this: <a href=""http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb3-setenv.html"" rel=""nofollow noreferrer"">http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb3-setenv.html</a></p>
<p>EDIT: While this was accepted answer in 2015, this should not be how you handle it. Now you can use AWS Secrets Manager for this purpose.</p>
"
"30821253","<p>If you’re using Python, you might consider using the <a href=""https://pypi.python.org/pypi/keyring"" rel=""nofollow""><code>keyring</code> module</a>. This allows you to store secret information in the system keychain, and then there’s no risk that it could be accidentally checked into Git.</p>

<p>Here’s a simple example for storing and retrieving an API key, based on the docs:</p>

<pre><code>&gt;&gt;&gt; import keyring
&gt;&gt;&gt; keyring.set_password(""my_api_key"", ""username"", ""ABC1234SEKRIT"")
&gt;&gt;&gt; keyring.get_password(""my_api_key"", ""username"")
'ABC1234SEKRIT'
</code></pre>
"
"30853642","<p>What you probably are looking for is a filter. You set these up in your <code>.gitattributes</code> file to run one substitution upon adding a file to the staging area, and another substitution upon checkout: </p>

<p><img src=""https://i.stack.imgur.com/48cjs.png"" alt=""enter image description here""></p>

<p>The image is from the .gitattributes section of the <a href=""http://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes"" rel=""nofollow noreferrer"">Git book</a>, which has details on how to create such a filter. </p>
"
"30950062","<p>Your intuition is correct! Definitely keep your keys/passwords/credentials out of your committed codebase.</p>

<p>Elastic Beanstalk provides environment variables in the control panel for just this purpose. The official documentation can be found here: <a href=""http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/command-options.html#command-options-ruby"" rel=""nofollow"">http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/command-options.html#command-options-ruby</a></p>

<p>These environment variables can be edited through the Elastic Beanstalk UI.</p>

<p>You can then reference these variables in your <code>.yml</code> config files, e.g. <code>password: &lt;%= ENV['PARAM1'] %&gt;</code>.</p>
"
"31921640","<p>For an Azure Web App, you can specify config values on the Configure tab in the portal (under ""app settings""). These will override values specified in your <code>Web.config</code> file.</p>

<p>This means you can leave these settings out of your public repository.</p>

<p>For developing locally, you can put the settings in a separate XML file. To do this, update the <code>appSettings</code> in your Web.config like this:</p>

<pre><code>&lt;appSettings file=""mysettings.xml"" /&gt;
</code></pre>

<p>Then create <code>mysettings.xml</code> and put your actual settings in a new <code>&lt;appSettings&gt;</code> element there.</p>

<p>You can then add <code>mysettings.xml</code> to your <code>.gitignore</code> file so it won't be checked in to your public repository.</p>

<p>Azure doesn't mind that your <code>mysettings.xml</code> file doesn't exist, and will pick up the settings you specify in the portal instead.</p>
"
"31923771","<p>I would suggest to leave the configuration outside your library; I've done something similar for the Mandrill mailing service, where I left to the developer the management of the configuration (I was working in a Symfony 2 project). For me there is no <code>Config</code> class, just the service constructor that accepts the API key and an (optional) array of options:</p>

<pre><code>public function __construct($api, $options = array())
{
    // My code
}
</code></pre>

<p>When I need to use my service inside the Symfony 2 application, I take the needed parameters and configuration from a place (Symfony's config files) external to my service; this way I can decouple the library from the configuration. Of course the service contructor throws an exception if the mandatory parameters are missing.</p>
"
"33924949","<p>There are several ways to do it.</p>
<h3><a href=""https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks"" rel=""nofollow noreferrer"">git hooks</a></h3>
<p>git hooks is a script that run in a different phases of the git life-cycle.</p>
<h3><a href=""https://github.com/gilesbowkett/git-smudge-and-clean"" rel=""nofollow noreferrer"">Smudge/clean</a></h3>
<p>Basically, smudge is equivalent to <strong>run this code whenever you check anything out</strong><br />
and clean is equivalent to <strong>run this code whenever you check anything in</strong>.</p>
<hr />
<p>Images are from this url:
<a href=""https://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes"" rel=""nofollow noreferrer"">https://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes</a></p>
<p><a href=""https://i.stack.imgur.com/21p5d.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/21p5d.png"" alt=""enter image description here"" /></a>
<a href=""https://i.stack.imgur.com/7vuXU.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7vuXU.png"" alt=""enter image description here"" /></a></p>
"
"33939156","<p>You can use <a href=""https://wiki.jenkins-ci.org/display/JENKINS/Mask+Passwords+Plugin"" rel=""nofollow noreferrer"">Mask Passwords Plugin</a> to mask those credentials. After installation, your job configuration pages should have an checkbox option in the <code>Build Environment</code> section just like this:</p>

<p><a href=""https://i.stack.imgur.com/i26lc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/i26lc.png"" alt=""enter image description here""></a></p>

<p>You can click the <strong>Add</strong> button to add as many key-value pairs as you want and the values are masked with asterisks.</p>

<p><strong>To use these defined parameters</strong>, you can use it like this: <code>${passwd}</code></p>

<p><a href=""https://i.stack.imgur.com/r7Zkn.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/r7Zkn.png"" alt=""enter image description here""></a></p>

<p>Please note, in your job console log, these parameters are also shown as asterisks, which is just as expected.</p>
"
"34837056","<p>There's a great Git feature called <a href=""https://git-scm.com/docs/git-filter-branch"" rel=""nofollow""><code>filter-branch</code></a>. It allows you to recreate a Git history, applying a command at each step. In this case, you'd use it to delete your sensitive file:</p>

<pre><code>git filter-branch --index-filter 'git rm -r --cached --ignore-unmatch my/sensitive/file' HEAD
</code></pre>

<p>It's worth pointing out that as with all such Git magic, the newly rewritten branch will have a different ""family tree"" to original, so you won't be able to merge back and forth. In other words, anyone who was working on the original repo will need to fetch the new branch before committing any work.</p>
"
"35137969","<p>Don't commit it. Seriously, it's that easy. You were on the right track with <a href=""https://devcenter.heroku.com/articles/config-vars"" rel=""nofollow"">heroku config variables</a>. In fact even from posting it here you're probably going to want to request a new key.</p>

<p>There's a suggestion to store whole config files in other places that may need credentials that you can store. S3 is a great place for that kind of thing. S3 has an amazing PHP component, too, for accessing S3 buckets.</p>
"
"35261091","<p>If it's sensitive data, you should not store it in source code as it will be checked into source control. The wrong people (inside or outside your organization) may find it there. Also, your development environment probably uses different config values from your production environment. If these values are stored in code, you will have to run different code in development and production, which is messy and bad practice.</p>

<p>In my projects, I put config data in the datastore using this class:</p>

<pre><code>from google.appengine.ext import ndb

class Settings(ndb.Model):
  name = ndb.StringProperty()
  value = ndb.StringProperty()

  @staticmethod
  def get(name):
    NOT_SET_VALUE = ""NOT SET""
    retval = Settings.query(Settings.name == name).get()
    if not retval:
      retval = Settings()
      retval.name = name
      retval.value = NOT_SET_VALUE
      retval.put()
    if retval.value == NOT_SET_VALUE:
      raise Exception(('Setting %s not found in the database. A placeholder ' +
        'record has been created. Go to the Developers Console for your app ' +
        'in App Engine, look up the Settings record with name=%s and enter ' +
        'its value in that record\'s value field.') % (name, name))
    return retval.value
</code></pre>

<p>Your application would do this to get a value:</p>

<pre><code>API_KEY = Settings.get('API_KEY')
</code></pre>

<p>If there is a value for that key in the datastore, you will get it. If there isn't, a placeholder record will be created and an exception will be thrown. The exception will remind you to go to the Developers Console and update the placeholder record.</p>

<p>I find this takes the guessing out of setting config values. If you are unsure of what config values to set, just run the code and it will tell you!</p>

<p>The code above uses the ndb library which uses memcache and the datastore under the hood, so it's fast.</p>

<hr>

<p><strong>Update:</strong></p>

<p><em>jelder</em> asked for how to find the Datastore values in the App Engine console and set them. Here is how:</p>

<ol>
<li><p>Go to <a href=""https://console.cloud.google.com/datastore/"" rel=""noreferrer"">https://console.cloud.google.com/datastore/</a></p></li>
<li><p>Select your project at the top of the page if it's not already selected.</p></li>
<li><p>In the <em>Kind</em> dropdown box, select <em>Settings</em>.</p></li>
<li><p>If you ran the code above, your keys will show up. They will all have the value <em>NOT SET</em>. Click each one and set its value.</p></li>
</ol>

<p>Hope this helps!</p>

<p><a href=""https://i.stack.imgur.com/cs0bV.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/cs0bV.png"" alt=""Your settings, created by the Settings class""></a></p>

<p><a href=""https://i.stack.imgur.com/Xx4C4.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/Xx4C4.png"" alt=""Click to edit""></a></p>

<p><a href=""https://i.stack.imgur.com/OrKxR.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/OrKxR.png"" alt=""Enter the real value and save""></a></p>
"
"35776938","<p>As Skelly notes, you can add API keys and the like as config vars via the Heroku Dashboard on the settings tab. You can also add/update etc <a href=""https://devcenter.heroku.com/articles/config-vars#setting-up-config-vars-for-a-deployed-application"" rel=""nofollow"">via the CLI</a>--e.g. <code>heroku config:set MY_API_KEY=12345</code>. Of course you have to have the <a href=""https://toolbelt.heroku.com/"" rel=""nofollow"">Heroku Toolbelt</a> installed to use the CLI.</p>

<p>If you want to know more about why Heroku is like this, you should read <a href=""http://12factor.net/config"" rel=""nofollow"">12factor.net</a> to understand the philosophy.</p>
"
"35968827","<p>Your intuition is correct.</p>

<p>Passing secrets in as an environment variable is just moving the problem outside the app. You have to have them somewhere anyway.</p>

<p>Passing them as an argument is less secure than a file, because any user on the server can <code>ps aux</code> and see them.</p>

<p>The only thing you did wrong in my opinion is overcomplicating it. I recommend dropping most of the code from the <code>sessionSecret.js</code> and instead of generating it on the fly, just get it from the config file. Shutdown the app if config file is not there.</p>

<p>Don't store the secrets in repository/SCM 
I put my secrets in a special folder in /etc/ of the server. If someone gets access to that, stealing sessions is the least they can do.</p>
"
"35974980","<p>The Heroku approach to this problem is based on their <a href=""http://12factor.net/config"" rel=""nofollow"">12factor App</a> config philosophy (see the paragraph that starts with ""The twelve-factor app stores config in environment variables""). So the way to do this is to move your configs from settings.json to config vars. This would be an example:</p>

<pre><code>heroku config:set MY_VAR=myValue MY_VAR2=myOtherValue -a myApp
</code></pre>

<p>It looks like the OP already knows this approach, he'll just have to take it for each key value pair in <code>settings.json</code>. The benefit of this approach is that if you bring more people onto the project, you don't have to find a way to securely transfer this info; authorized users can get the creds they need with <code>heroku config -a myApp</code>. You could also visit the <a href=""https://dashboard.heroku.com"" rel=""nofollow"">heroku dashboard</a> and add the settings via the web interface, if that's easier for you.</p>
"
"35987372","<p>That's the purpose of having a <code>config.js.sample</code> file with a base configuration which can be customized by anybody by renaming it to <code>config.js</code>. Which won't be committed if you put <code>config.js</code> on the ignore list.</p>
"
"36422400","<p>By looking at your configuration file the answer seems to be quite obvious.</p>

<p>In production Puma takes these values from two environment variables (<em>SECRET_KEY_BASE</em> and <em>SECRET_TOKEN</em>). You need to define these environment variables on your <em>production</em> server.</p>
"
"37161827","<p>Yes, storing a strongly encrypted Slack token in the travis.yml is accepted practice. Once you have added the Travis-CI integration into the Slack and have the token, it is necessary to use the cli command ""encrypt"" to insert a new section <code>notifications: slack: secure</code> into the travis.yml. </p>

<p>You run this command from your local git repo folder, with the token from Slack:- </p>

<pre><code>travis encrypt ""myaccount:aa1BBBBBcCCCC111122"" --add notifications.slack
</code></pre>

<p>See also : <a href=""https://docs.travis-ci.com/user/notifications/#Slack-notifications"" rel=""nofollow"">https://docs.travis-ci.com/user/notifications/#Slack-notifications</a></p>

<p>As you mentioned about a shared team, you can target the relevant channel/channels inside the team project, making sure these get encrypted with <code>travis encrypt ""account:token#channel"" --add notifications.slack.rooms</code> :-</p>

<pre><code>notifications:
  slack: '&lt;account&gt;:&lt;token&gt;#development'
</code></pre>

<p>The encryption private/public key is per repo.</p>

<p>For reference you can see how the encryption is being implemented as you can verify that it meets your organisation's security standard :- <a href=""https://github.com/travis-ci/travis.rb/blob/master/lib/travis/cli/encrypt.rb"" rel=""nofollow"">https://github.com/travis-ci/travis.rb/blob/master/lib/travis/cli/encrypt.rb</a></p>
"
"37205912","<p>The best answer to your question is use <code>ansible-vault</code>.</p>

<p>1- use <code>mysqlpassword</code> as variable <code>{{ mysqlpassword }}</code> inside your template <code>mysqlconnect.php.j2</code></p>

<p>2- create separate file like <code>my_very_secure.yml</code>(whatever name you want) with all the values of your secure username and password:</p>

<pre><code>---
mysqlpassword: very-secure-password-value
anothervariable: another-secure-value
</code></pre>

<p>After that you can encrypt this file with <code>ansible-vault</code>:</p>

<pre><code>ansible-vault encrypt my_very_secure.yml
</code></pre>

<p>Then you can store this file into source control server because it's encrypted or leave it on the ansible master server, but once you are ready to run the playbook just include the <code>--ask-vault-pass</code> option like this and path to your secure file:</p>

<pre><code>ansible-playbook -i yourhostfile yourplaybook.yml -e@/path-to-your-file/my_very_secure.yml --ask-vault-pass
</code></pre>

<p>Hope this will help you.</p>
"
"37214488","<p><strong>Do not store sensitive data under VCS</strong>. This is the best solution. Even if you gitignored the file it can be exposed accidentally, e.g. by a newcomer. And you must realize that any peace of data that was exposed in the Internet remains there. You cannot just <a href=""https://help.github.com/articles/remove-sensitive-data/"" rel=""nofollow"">clean up your history</a> and be sure that no one grabbed your passwords.</p>

<p>Personally I like the way <a href=""http://12factor.net/config"" rel=""nofollow"">proposed</a> by Adam Wiggins in his ""12 Factor App"". Basically, he says you should store any dynamic configuration, including passwords, on the environment the app is run. This may be either environment variables, that work with any programming language, or app-specific solutions like Java properties (<code>-Dprop=value</code>).</p>
"
"37359108","<p>A <a href=""https://firebase.google.com/docs/admob/android/google-services.json"" rel=""nofollow noreferrer""><code>google-services.json</code></a> file is, <a href=""https://firebase.google.com/support/guides/google-android#migrate_your_console_project"" rel=""nofollow noreferrer"">from the Firebase doc</a>:</p>
<blockquote>
<p>Firebase manages all of your API settings and credentials through a single configuration file.<br />
The file is named <code>google-services.json</code> on Android and <code>GoogleService-Info.plist</code> on iOS.</p>
</blockquote>
<p>It seems to make sense to add it to a <code>.gitignore</code> and not include it in a public repo.<br />
This was discussed in <a href=""https://github.com/googlesamples/google-services/issues/26#issuecomment-168869043"" rel=""nofollow noreferrer"">issue 26</a>, with more details on what <a href=""https://developers.google.com/android/guides/google-services-plugin#processing_the_json_file"" rel=""nofollow noreferrer""><code>google-services.json</code></a> contains.</p>
<p>A project like <a href=""https://github.com/googlesamples/google-services/"" rel=""nofollow noreferrer""><code>googlesamples/google-services</code></a> does have it <a href=""https://github.com/googlesamples/google-services/blob/0edda8fe963a9baf78f67de4e78311c33e38c397/.gitignore"" rel=""nofollow noreferrer"">in its <code>.gitignore</code></a> for instance.<br />
Although, as <a href=""https://stackoverflow.com/questions/37358340/should-i-add-the-google-services-json-from-firebase-to-my-repository/37359108?noredirect=1#comment77979395_42750187"">commented</a> by <a href=""https://stackoverflow.com/users/3873192/stepheaw"">stepheaw</a>, this <a href=""https://groups.google.com/forum/#!msg/firebase-talk/bamCgTDajkw/uVEJXjtiBwAJ"" rel=""nofollow noreferrer"">thread does mention</a></p>
<blockquote>
<p>For a library or open-source sample we do not include the JSON file because the intention is that users insert their own to point the code to their own backend.<br />
That's why you won't see JSON files in most of our firebase repos on GitHub.</p>
</blockquote>
<p>If the &quot;database URL, Android API key, and storage bucket&quot; are not secret for you, then you could consider adding the file to your repo.<br />
As mentioned in &quot;<a href=""https://stackoverflow.com/a/45508703/6309"">Is google-services.json safe from hackers?</a>&quot;, this isn't that simple though.</p>
<p><a href=""https://stackoverflow.com/users/2847310/baueric"">baueric</a> asks in <a href=""https://stackoverflow.com/questions/37358340/should-i-add-the-google-services-json-from-firebase-to-my-repository/37359108?noredirect=1#comment112734236_37359108"">the comments</a>:</p>
<blockquote>
<p>In that post he says:</p>
<blockquote>
<p>The JSON file does not contain any super-sensitive information (like a server API key)</p>
</blockquote>
<p>But the <code>google-services.json</code> does have entry called <code>api_key</code>.<br />
Is that a different api key than a &quot;<code>server api key</code>&quot;?</p>
</blockquote>
<p><a href=""https://stackoverflow.com/users/5742625/willie-chalmers-iii"">Willie Chalmers III</a> points to &quot;<a href=""https://stackoverflow.com/a/45508703/6309"">Is google-services.json safe from hackers?</a>&quot;, and adds:</p>
<blockquote>
<p>Yes, that API key isn't a server API key which should never be public, so it's fine if your <code>google-services.json</code> is visible by others.</p>
<p>In any case, you should still restrict how your client API key can be used in the Google Cloud console.</p>
</blockquote>
<hr />
<p>As noted by <a href=""https://stackoverflow.com/users/8841562/puzz"">Puzz</a> in <a href=""https://stackoverflow.com/questions/37358340/should-i-add-the-google-services-json-from-firebase-to-my-repository/37359108?noredirect=1#comment129376469_37359108"">the comments</a>, see also &quot;<strong><a href=""https://stackoverflow.com/a/37484053/6309"">Is it safe to expose Firebase apiKey to the public?</a></strong>&quot;</p>
<p>In that answer, <a href=""https://stackoverflow.com/users/209103/frank-van-puffelen"">Frank Van Puffelen</a> mentions:</p>
<p>Update (May 2021): Thanks to the new feature called <strong><a href=""https://firebase.google.com/docs/app-check"" rel=""nofollow noreferrer"">Firebase App Check</a></strong>, it is now actually possible to limit access to the backend services in your Firebase project to only those coming from iOS, Android and Web apps that are registered in that specific project.</p>
"
"37484053","<p>The <code>apiKey</code> in this configuration snippet just identifies your Firebase project on the Google servers. It is not a security risk for someone to know it. In fact, it is necessary for them to know it, in order for them to interact with your Firebase project. This same configuration data is also included in every iOS and Android app that uses Firebase as its backend.</p>
<p>In that sense it is very similar to the database URL that identifies the back-end database associated with your project in the same snippet: <code>https://&lt;app-id&gt;.firebaseio.com</code>. See this question on why this is not a security risk: <a href=""https://stackoverflow.com/questions/35418143/how-to-restrict-firebase-data-modification"">How to restrict Firebase data modification?</a>, including the use of Firebase's server side security rules to ensure only authorized users can access the backend services.</p>
<p>If you want to learn how to secure all data access to your Firebase backend services is authorized, read up on the documentation on <a href=""https://firebase.google.com/docs/rules"" rel=""noreferrer"">Firebase security rules</a>. These rules control access to file storage and database access, and are enforced on the Firebase servers. So no matter if it's <em>your</em> code, or somebody else's code that uses you configuration data, it can only do what the security rules allow it to do.</p>
<p>For another explanation of what Firebase uses these values for, and for which of them you <em>can</em> set quotas, see the Firebase documentation on <a href=""https://firebase.google.com/docs/projects/api-keys"" rel=""noreferrer"">using and managing API keys</a>.</p>
<hr />
<p>If you'd like to reduce the risk of committing this configuration data to version control, consider using the <a href=""https://firebase.google.com/docs/hosting/reserved-urls#sdk_auto-configuration"" rel=""noreferrer"">SDK auto-configuration of Firebase Hosting</a>. While the keys will still end up in the browser in the same format, they won't be hard-coded into your code anymore with that.</p>
<hr />
<p><strong>Update</strong> (May 2021): Thanks to the new feature called <a href=""https://firebase.google.com/docs/app-check"" rel=""noreferrer"">Firebase App Check</a>, it is now actually possible to limit access to the backend services in your Firebase project to only those coming from iOS, Android and Web apps that are registered in that specific project.</p>
<p>You'll typically want to combine this with the user authentication based security described above, so that you have another shield against abusive users that <em>do</em> use your app.</p>
<p>By combining App Check with security rules you have both broad protection against abuse, and fine gained control over what data each user can access, while still allowing direct access to the database from your client-side application code.</p>
"
"37718731","<p>Your bitbucket repo is private, so anything you store there is only visible to the people you explicitly authorize to access your repo, unless, of course, bitbucket get hacked...</p>

<p>You need to configure your environment variables for Heroku anyway via ""heroku config"", so the fact that they are also in your git repo doesn't really compromise them any further. Again, only people with explicit access permissions should be able to see your Heroku config vars or access your Heroku git repo.</p>
"
"37719391","<p>Similar open-source projects involving a Calendar have a different approach.<br />
See for instance &quot;<a href=""https://github.com/arvind-iyer/CourseSchedulerHKUST"" rel=""nofollow noreferrer""><code>arvind-iyer/CourseSchedulerHKUST</code></a>&quot;:</p>
<blockquote>
<p>Run <code>quickstart.py</code> with Python 2.7 after installing all the dependencies with the command <code>pip install -r requirements.txt</code>.<br />
<strong>Create a google dev app and obtain client secrets and store as client_secret.json in the directory before running <code>quickstart.py</code></strong></p>
</blockquote>
<p>In other words, each user needs to come up with his/her own client secrets, instead of you having to store and share yours.</p>
"
"38103010","<p>Instead of Version Controlling it, I would instead put it in a separate XML File, and put it in the <code>.gitignore</code>. You can reference the XML File in the String Resources file, and instead of using the hard coded API Key, use the String Resource that corresponds to the API Key, like <code>@string/API_KEY</code>. That is a much safer way to do this. This way, you are not opening your key up to public access, and the application still has the corresponding data it needs.</p>
"
"38154592","<p>First I would turn the customErrors off so you can find the real problem, but my guess is that you aren't including the AppSettingsSecrets.config in your solution.  This will cause a problem once deployed because the file isn't there - so you should remove the configSource or file attributes from the config using a web.config transform.</p>

<p>So in the Web.Release.config you can add the following inside the: </p>

<pre><code>&lt;configuration xmlns:xdt=""http://schemas.microsoft.com/XML-Document-Transform""&gt;
...
    &lt;connectionStrings xdt:Transform=""RemoveAttributes(configSource)""/&gt;
    &lt;appSettings xdt:Transform=""RemoveAttributes(file)""/&gt;
</code></pre>

<p>When you do a publish of the release build, this will remove those file paths from the config so it won't fail at startup once deployed.</p>

<p><strong>Update</strong></p>

<p>Now you'll need to add all the appSettings that were in the AppSettingsSecrets.config file to the appSettings in the portal.  This will keep your published site credentials only in Azure. </p>

<p>All The appSettings in the Web.config and any other files get merged into the same listing (meaning your code doesn't need to know the appSetting is coming from the web.config, AppSettingsSecrets.config or being configured from the azure portal.  Here is a good article on appSettings: <a href=""https://buildazure.com/2015/11/30/azure-web-app-application-settings/"" rel=""nofollow"">https://buildazure.com/2015/11/30/azure-web-app-application-settings/</a></p>

<p>The good things about your setup is:</p>

<ol>
<li>the AppSettingsSecrets.config has the secrets needed only for
developers and is not included in source control or published</li>
<li>the published site credentials are only in Azure and available to
    only those with access to the Azure account.</li>
</ol>
"
"38776997","<p>After few things I have tried, the best solution I found is to use Environment Variables on Windows system. Not sure how that will work once I will deploy to the Azure, but for now it is working as expected. In my ASP.NET Core in the Startup.cs I add AddEnvironmentVariables:</p>

<pre><code>    public Startup(IHostingEnvironment appEnv)
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(appEnv.ContentRootPath)
            .AddJsonFile(""config.json"")
            .AddEnvironmentVariables();


        Configuration = builder.Build();
    }
</code></pre>

<p>Here is the connection string:</p>

<p><a href=""https://i.stack.imgur.com/L0bS4.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/L0bS4.png"" alt=""enter image description here""></a></p>

<p>To consume it:</p>

<pre><code>string connStr= Startup.Configuration[""Data:WorldContextConnection""];
</code></pre>

<p>In that case I can check every single file into GitHub, the only thing is that I would need to always add those Environmental Variables into a system I will be working on.</p>
"
"39111318","<p>You could add your keys to a plist, which is added to your .gitignore file. </p>

<p>That way you don't have to keep resetting those swift variables every time you want to commit, it just pulls from the local plist. Most of my projects also use this plist driven approach to target different schemes. I'll create a 'debug' dictionary for my pre-production api keys, and a 'release' dictionary for my production api keys. This has the added bonus that you can keep production api keys from temp workers if you really wanted to. Works for me, and is very neat.</p>

<p>Yes, you still have to get the other developer that plist file somehow; but there are plenty of ways to do that in an encrypted fashion... it's just a text file.</p>
"
"39542892","<p>If you remove the sensitive information (by replacing it with environment variables) then you can commit the file. It's not just <code>secrets.yml</code>. Any encryption keys, API keys, credentials, should not be committed to Git.</p>

<p>If you've already pushed this information to Git, it can be removed by doing a Rebase, but that doesn't guarantee that every copy is removed. It would be better to change the secret.</p>

<p>This would mean using an environment variable, setting the existing value in the environment, then at a certain point generating a new value for the secret and changing the environment variable.</p>

<p>Changing the secret would invalidate any existing user sessions, so it would be best to inform users ahead of time and do it during time where the fewest users are using the site.</p>

<p>Until you change the secret value, your site is vulnerable.</p>
"
"39625963","<p>For the Google Maps Javascript API v3 the keys <strong>must</strong> be public on you page.
The applicable text is:</p>

<blockquote>
  <p><strong>Restrict your API keys to be used by only the</strong> IP addresses, <strong>referrer URLs</strong>, and mobile apps <strong>that need them</strong></p>
</blockquote>

<p>Go to the Google API Console and generate a key, restricting it to URLs that you own (or want to put maps on) to prevent quota ""theft"". </p>
"
"39827451","<p>You should not.</p>

<p><code>Release keystore</code> is the most sensitive data.</p>

<p>In my team, there is only one people can sign the release package. (And may be one for backing up).</p>

<p>All sensitive info <strong>MUST</strong> be ignored and we make a reference to these info.</p>

<p>In my team, we config like that:</p>

<p>On <code>Android Studio</code>:</p>

<p><code>/local.properties</code> file:</p>

<pre><code>storeFile=[path/to/keystore/file]
keyAlias=[alias's key]
keyPassword=[alias's password]
storePassword=[key's password]
</code></pre>

<p><code>/app/build.gradle</code>, <code>config</code> scope:</p>

<pre><code>signingConfigs {
  release {
    Properties properties = new Properties()
    properties.load(project.rootProject.file('local.properties').newDataInputStream())
    storeFile file(properties.getProperty('storeFile'))
    keyAlias properties.getProperty('keyAlias')
    storePassword properties.getProperty('storePassword')
    keyPassword properties.getProperty('keyPassword')
  }
}

buildTypes {
  release {
    minifyEnabled false
    proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
    signingConfig signingConfigs.release
  }
  .
  .
  .
}
</code></pre>

<p>See my complete demo config:</p>

<pre><code>apply plugin: 'com.android.application'

android {
    compileSdkVersion 21
    buildToolsVersion ""22.0.1""

    defaultConfig {
        multiDexEnabled = true

        applicationId ""com.appconus.demoapp""
        minSdkVersion 16
        targetSdkVersion 21
        multiDexEnabled = true
        versionCode 18
        versionName ""1.3""
    }

    signingConfigs {
        release {
            Properties properties = new Properties()
            properties.load(project.rootProject.file('local.properties').newDataInputStream())
            storeFile file(properties.getProperty('storeFile'))
            keyAlias properties.getProperty('keyAlias')
            storePassword properties.getProperty('storePassword')
            keyPassword properties.getProperty('keyPassword')
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }
        debug {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
        applicationVariants.all { variant -&gt;
            appendVersionNameVersionCode(variant, defaultConfig)
        }
    }
}
dependencies {
    compile 'com.google.android.gms:play-services:8.1.0'
}
</code></pre>
"
"40866036","<p><code>git filter-branch</code> <strong>is</strong> the way to go. It has various filters and you can remove files from the history, but you can also modify the files as you like. In your case you want to use the <code>--tree-filter</code> option with a command that replaces the String in your file. Something like <code>git filter-branch --tree-filter ""sed -i 's/243248324293938243/putYaOwnApiKeyBrothar/' your/file/here"" --tag-name-filter cat --all</code></p>

<p>(if you are on macOS (or any *BSD) add <code>'' after sed -i</code>) </p>
"
"40970523","<p>The most secure way to store this info is using <a href=""https://cloud.google.com/compute/docs/storing-retrieving-metadata"" rel=""nofollow noreferrer"">project metadata</a>. On a Flexible/ManagedVM environment you can access the metadata via a <a href=""https://medium.com/google-cloud/service-discovery-and-configuration-on-google-cloud-platform-spoiler-it-s-built-in-c741eef6fec2"" rel=""nofollow noreferrer"">simple http request</a>.</p>

<p>From the google blog post:</p>

<blockquote>
  <p>With Compute Engine, Container Engine, and <strong>Managed VMs</strong>, there is a magic URL you can CURL to get metadata.</p>
</blockquote>

<p>ManagedVMs are the old name for what is now called 'AppEngine Flexible Environment'. Since you say you are using Ruby on App Engine you must be using Flexible/ManagedVMs. Therefore you should be able to use these 'magic URLs'.</p>

<p>So to get an application secret called <code>mysecret</code> in Ruby you might do:</p>

<pre><code>Net::HTTP.get(
    URI.parse('http://metadata.google.internal/computeMetadata/v1/project/attributes/mysecret'))
</code></pre>

<p>(For @joshlf) Here's how to access <em>project</em> metadata on AppEngine Standard Environment in Python:</p>

<pre><code># Note that the code will not work on dev_appserver, 
# you will need to switch to some other mechanism 
# for configuration in that environment
# Specifically the project_id will resolve to something
# compute engine API will treat as invalid

from google.appengine.api import app_identity
from googleapiclient import discovery
from oauth2client.client import GoogleCredentials

compute = discovery.build(
    'compute', 'v1', credentials=GoogleCredentials.get_application_default())

def get_project_metadata(metadata_key):
    project_id = app_identity.get_application_id()
    project = compute.projects().get(project=project_id).execute()
    for entry in project['commonInstanceMetadata']['items']:
        if entry['key'] == metadata_key:
            return entry['value']
    return None

get_project_metadata('my_key')
</code></pre>
"
"42247646","<p>After reading your comments I think what you really need here is lock file feature, that exists (as far as I know) <strong>only</strong> on gitlab. But... this requires central server so it's actually against git main idea.</p>

<p>In most cases - as Stony said - you should create template file like <code>config.template.php</code> or <code>config.dev.php</code>, add <code>config.php</code> to .gitignore and make each developer rename/recreate config.php.</p>

<p>Another way would be to create deploy script with transformation instructions that'll automatically adjust paths inside config file, maybe automatically deploy entire application, and run it at each deploy.</p>

<p>Or simply exclude config file every time you commit changes.</p>
"
"42690271","<p>I based my solution on the advice from <a href=""https://stackoverflow.com/users/6067741/4c74356b41"">4c74356b41</a>'s answer.</p>

<h2>Step 1: Add keys to your Web.config file</h2>  

<p>Leave the value's empty.</p>

<pre><code>  &lt;appSettings&gt;
    &lt;add key=""webpages:Version"" value=""3.0.0.0"" /&gt;
    &lt;add key=""webpages:Enabled"" value=""false"" /&gt;
    &lt;add key=""ClientValidationEnabled"" value=""true"" /&gt;
    &lt;add key=""UnobtrusiveJavaScriptEnabled"" value=""true"" /&gt;

    &lt;add key=""EmailAccount"" value=""""/&gt;
    &lt;add key=""EmailPassword"" value=""""/&gt;
  &lt;/appSettings&gt;
</code></pre>

<h2>Step 2: Use the keys in your code</h2>  

<p>With <code>ConfigurationManager</code> you can call <code>AppSettings</code> and retrieve the value based on the key name.</p>

<pre><code>       using (var smtp = new SmtpClient())
        {
            var credential = new NetworkCredential
            {
                UserName = ConfigurationManager.AppSettings[""EmailAccount""],  
                Password = ConfigurationManager.AppSettings[""EmailPassword""]  
            };
            smtp.Credentials = credential;
            smtp.Host = ""smtp-mail.outlook.com"";
            smtp.Port = 587;
            smtp.EnableSsl = true;
            await smtp.SendMailAsync(message);
            return RedirectToAction(""Sent"");
        }
</code></pre>

<h2>Step 3: Add your Key Value's to your App settings on Azure</h2>  

<p>In your Web App, go to Application Settings under the Settings and add your key/value's</p>

<p><a href=""https://i.stack.imgur.com/ECLBb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ECLBb.png"" alt=""enter image description here""></a></p>
"
"43019129","<p><a href=""https://www.vaultproject.io/"" rel=""nofollow noreferrer"">Vault</a> is a popular choice for allowing access with better security than environment variables.</p>
"
"43161563","<p>What's wrong with setting up <a href=""https://stackoverflow.com/questions/6942600/multi-line-config-variables-in-heroku"">multi-line environment variables in Heroku</a> (as suggested by the other question that you have linked to)?</p>

<p>If you're on Rails 5.1, there is now another option though - <a href=""http://edgeguides.rubyonrails.org/5_1_release_notes.html#encrypted-secrets"" rel=""nofollow noreferrer"">encrypted secrets</a>. This allows you to commit an encrypted version of your private key file to version control, and just have the master key in Heroku. This appears to be based on the <a href=""https://github.com/ahoward/sekrets"" rel=""nofollow noreferrer"">sekrets gem</a>, which could be an option for older Rails versions - but you'll want to read the docs and do some research there, if that's your preferred route.</p>
"
"43711823","<p>The rule is: keep sensitive data out of version control.</p>

<p>I see nothing sensitive in the file, and therefore it <strong>should</strong> be checked into version control.</p>
"
"44053557","<p>You would use private environment variables. This would be loaded into CircleCI via the webapp or API, and then injected into a running build. This way, sensitive information won't have to be stored in your repository.</p>

<p>Here's a doc on Environment Variables in <a href=""https://circleci.com/docs/1.0/environment-variables/"" rel=""nofollow noreferrer"">CircleCI 1.0</a> and <a href=""https://circleci.com/docs/2.0/env-vars/"" rel=""nofollow noreferrer"">CircleCI 2.0</a>.</p>
"
"44221307","<p>Rails by default uses browser cookies as its session store. This means that as opposed to the traditional way of storing session data on the server and only a session id in the cookie, Rails stores the whole session data in the cookie.</p>

<p>This of course would not be very secure in many cases, any user could just see and modify his session contents. So the cookie in Rails is encrypted and signed. The key used for this (encryption and integrity verification) is in <code>secret_key_base</code>.</p>

<p>What this practically means is if this <code>secret_key_base</code> is compromised, any user can decrypt, modify and reencrypt his session cookie (all the data in the session). In some applications this causes no problem as there is nothing interesting stored in the session anyway. But in most cases, it leads to all kinds of problems depending on the actual business logic. For example if privileges were stored in the session, a user could change his privileges in the application, probably an unintended result.</p>

<p>Note that if you use a different session store (like for example Redis), you don't need this secret. Afaik it's only used to encrypt cookies if the cookie store is used for sessions. Using a server-side session store is a good idea and the best practice anyway as it is more secure.</p>
"
"44342348","<p>You should consider using <code>.env</code> files and read the keys from the environmental variables. How to do so depends on the language and tools you use (for <a href=""https://github.com/motdotla/dotenv"" rel=""noreferrer"">node.js</a>, <a href=""https://github.com/vlucas/phpdotenv"" rel=""noreferrer"">php</a>, etc.).</p>

<p>You can exclude <code>.env</code> file from commits by adding <code>.env</code> to the <code>.gitignore</code>. You can also upload an example configuration <code>.env.example</code> with dummy data or blanks to show the schema your application requires.</p>
"
"44596399","<p>You're right to store the cloudformation template in <code>git</code>, since it's something that will change and you need to keep track of those changes. But secrets of course have no place in source control! My preferred option in this case is to keep the cloudformation template with the code under source control, and store the secrets in a secure location, like S3 or a private database. </p>

<p>In this situation, you can have the CI system pull the code from your GitLab repository to build the application and run the tests, and then pull the configuration from the chosen location in order to get ready for the deployment. </p>

<p>If you store the secrets in a file in S3, for example, you use a scripts that reads those values and substitutes them in the correct fields in the json (or yaml) file for the task definition. That way you keep the code completely separate from the configuration, and you can manage them independently. </p>
"
"44661281","<p>As @davidism suggested, Config files are never meant to be tracked since these are your secret keys and anybody with access to your code will have access to your keys if tracked.</p>

<p>But, there is no hard and fast rule in Flask to keep your settings file in a specific location. You can keep them anywhere and name them anything.
But, when adding the config to the app, the correct file path must be given.</p>
"
"44704472","<p>This typically happens when your settings are not being loaded (or found) by Django. Make sure your <code>DJANGO_SETTINGS_MODULE</code> <a href=""https://docs.djangoproject.com/en/1.11/topics/settings/#designating-the-settings"" rel=""nofollow noreferrer"">environment variable is set</a> (correctly).</p>
"
"44756922","<p>You can use your server environment to hide your properties. Just store on your production server application.properties with real credentials and protect access, so only your application will have access to the property file. </p>
"
"44792812","<p>2 is the most sensible option. Problem with 1 and 3 is, once they have access to the ""encrypted"" string, all they have to figure out how are you decrypting it (You anyway have to do it, to make use of it).</p>

<p>Have you looked at <a href=""https://cloud.spring.io/spring-cloud-config/"" rel=""nofollow noreferrer"">Spring Cloud Config</a>, I don't know whether this is an option for your or not.</p>
"
"45519115","<p>You can edit the file now to remove the offending content in a new commit, then interactively rebase that commit.  A step-by-step guide is here: <a href=""https://stackoverflow.com/a/21353994/4323"">https://stackoverflow.com/a/21353994/4323</a> but the gist is:</p>

<pre><code>make sure you have a backup
edit thefile
git commit thefile -m ""remove details""
git rebase -i --root
</code></pre>

<p>Now you will see a list of commits.  Change the last one (""remove details"") from ""pick"" to ""fixup"", and move it to be after the first commit.</p>

<p>You'll probably need to <code>git push -f</code> after this, to rewrite history at your origin server.</p>
"
"45717603","<p>You could have own config file for each environment:</p>

<pre><code>- environments
  - index.js
  - deveplopment.json
  - staging.json
  - production.json
</code></pre>

<p>To use appropriate config file, run the app with required <code>NODE_ENV</code>:</p>

<pre><code>NODE_ENV=production node index
</code></pre>

<p>In <code>environments/index.js</code> determinate the current <code>NODE_ENV</code> and use config:</p>

<pre><code>process.env.NODE_ENV = process.env.NODE_ENV || 'development';
module.exports = require('./' + process.env.NODE_ENV);
</code></pre>

<p>If config file doesn't include secret info (apiKeys, etc), it can be pushed to repo. Otherwise add it to .gitignore and use environment variables on the server.</p>

<p><strong>Note:</strong></p>

<p>For advanced configuration use such packages as <a href=""https://github.com/indexzero/nconf"" rel=""nofollow noreferrer"">nconf</a>.</p>

<blockquote>
  <p>It allows to create hierarchical node.js configuration with files, environment variables, command-line arguments, and atomic object merging.</p>
</blockquote>
"
"46613994","<p>Commonly, people put these keys/secrets in as an environmental variable and in the code write <code>process.env.SKILL_KIT_KEY</code> to retrieve it.</p>

<p>I would <em>strongly</em> recommend, if you make the switch, to deactivate the key you've used and that lives in plain-text in the repo's history and obtain a new one.</p>
"
"46829114","<p>By shear luck, I believe that simply repeating my original actions has solved the problem, i.e. running <code>filter-branch</code> again on my repo has cleaned up the 'duplicate' commits.</p>

<p>Since my filtering process was simply to remove specific files from every commit, running the same filter again on my modified repo (B) has no effect (B' = B) whereas running it on the commits in repo A results in commits that are identical to B.</p>

<p>Since commit hashes are calculated by the contents of the changes and the hashes of its ancestors, and because the ancestors in A and B are now effectively identical, I end up with identical commit hashes on both sides of the tree... therefore the duplicates magically disappear! My new repo now contains just over 3000 commit object as before.</p>

<p>Further reading:</p>

<p><a href=""https://stackoverflow.com/a/25128596/534406"">How does git assure that commit SHA keys for identical operations/data are still unique?</a></p>

<p><a href=""https://stackoverflow.com/a/4061706/534406"">How to get the git commit count?</a></p>
"
"47387723","<p>A file is either tracked or not, you can't have it both ways.</p>

<p>What you can do is ignore it, but add an <em>example</em> file, named e.g. ""secret.properties.example"" and then make your program refuse to run if ""secret.properties"" doesn't exist.</p>

<p>This is a very common practice with configuration files.</p>
"
"47797907","<p>Option 1: If you commit your file as a separate commit.</p>

<pre><code>git rebase -i commit_hash of one less than needed and remove that commit.
</code></pre>

<p>Lets say: This is your commit history</p>

<pre><code>commit 5347819473b66359e8324004470040bee0892447 (HEAD -&gt; master)
Author: XXXX
Date:   Wed Dec 13 21:43:29 2017 +0530

    third commit

 blah2.h | 1 +
 1 file changed, 1 insertion(+)

commit d88e9dc5aadfad5872a2cc8214ba5295e2668526
Author: XXXX
Date:   Wed Dec 13 21:42:56 2017 +0530

    second commit

 blah1.h | 1 +
 1 file changed, 1 insertion(+)

commit 2419b28fee57a6923ce37e2e144c12d88fb75183
Author: XXXX
Date:   Wed Dec 13 21:42:33 2017 +0530

    first commit

 blah.h | 1 +
 1 file changed, 1 insertion(+)
</code></pre>

<p>And you want to remove second commit. </p>

<pre><code>git rebase -i 2419b28fee57a6923ce37e2e144c12d88fb75183 - Commit hash of first commit. And then interactively remove the line containing the second commit and save. 
</code></pre>

<p>Option 2: If you commit your file with other changes as well, then </p>

<pre><code>git reset commit_hash of one less than needed. 
</code></pre>

<p>Add that file to git ignore and commit all the changes from then as a new commit. In this, you will lose the history of the project from that point you commit that file to now. </p>
"
"48802638","<p>If as a general rule, you would like to ignore the publish profiles from being committed, then add the following lines to the <code>.gitignore</code> file of your solution</p>

<pre><code>*.[Pp]ublish.xml
*.azurePubxml
*.pubxml
*.publishproj
</code></pre>

<p>On the other hand, it may be worthwhile to spend some time removing database config from publish profile by using Web Deploy Parameters and setting up a small release cycle to avoid publishing directly from VS.</p>
"
"48833255","<p>I would say the security for both methods are the same. Written down in a file (which is not committed to the source code repository) or as a environment variable would have the same effect.</p>

<p>If your system is compromised in a way someone got access the server, both methods would expose your security key. So, it wouldn't make much difference.</p>

<p>Now, I would say using environment variable is a better strategy. Not related to security though. But usually it is not a good idea to rely on uncommitted files to run a project. It's one of the causes of the famous <em>in my machine it works</em> problems. And it also make initial setup of a project difficult for newcomers.</p>

<p>For this kind of settings and configuration management, there is a great python library called <a href=""https://pypi.python.org/pypi/python-decouple"" rel=""nofollow noreferrer"">Python Decouple</a>. It's worth checking it out. I use it in every Django project I work with.</p>
"
"48913870","<p>Came up with a solution: keep the connection strings in web.config since they are referenced by other sections of the web.config, but update the values at application startup.</p>

<pre><code>protected void Application_Start()
{
    /* ... */

    var configurationReadOnlyField = typeof(ConfigurationElement).GetField(""_bReadOnly"", BindingFlags.Instance | BindingFlags.NonPublic);

    var connection = ConfigurationManager.ConnectionStrings[connectionName];
    s_configurationReadOnlyField.SetValue(connection, false);

    connection.ConnectionString = newValue;

    /* ... */
}
</code></pre>
"
"49125774","<p>You need to use bracket notation for non default exports.</p>

<p>Try:</p>

<pre><code> import { GOOGLE_API_KEY } from '../../credentials.js';
</code></pre>

<p>or make the export default.</p>

<p>Docs:</p>

<p><a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import"" rel=""nofollow noreferrer"">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import</a>
<a href=""https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export"" rel=""nofollow noreferrer"">https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export</a></p>
"
"49237095","<p>As you have already set the API_KEY on Heroku env using the command you mentioned, in order to use it you need to do something like:</p>

<pre><code>const API_KEY = process.env.API_KEY;
</code></pre>

<p>This way you'll be able to read from Heroku env. You can see more info <a href=""https://nodejs.org/api/process.html#process_process_env"" rel=""nofollow noreferrer"">here</a>.</p>
"
"50096873","<p>Any API keys for any external API  you are using.</p>

<p>MD5 hashes or Google play store strings.</p>

<p>Keystore files.</p>

<p>.idea files which might have your name or computer name.</p>

<p>Can't really think of anything else.</p>
"
"50182143","<p>You would have to remove it from the history in your repo, i.e. history rewritting. The <a href=""https://rtyley.github.io/bfg-repo-cleaner/"" rel=""nofollow noreferrer"">BFG repo cleaner</a> might help you. Or you change your password ;)</p>
"
"50311504","<p>You can try with <code>git rebase -i</code>.</p>

<p>Following the example you used in your question and assuming A is in the remote repo but B, C, D and E are not, after using git rebase you will get an screen like this:</p>

<pre><code>pick 67a8df7 B
pick 47a6947 C
pick a55540f D
pick 68b51d5 E
</code></pre>

<p>Then you will need to edit commit E line like this:</p>

<pre><code>pick 67a8df7 B
pick 47a6947 C
pick a55540f D
edit 68b51d5 E
</code></pre>

<p>Finally, remove the line that you want, commit your changes and use <code>git rebase --continue</code> to go on.</p>

<p>More info at <a href=""https://git-scm.com/docs/git-rebase"" rel=""nofollow noreferrer"">git rebase documentation</a>.</p>
"
"51229024","<p>The general way to do this is read from enviroment variable:</p>

<pre><code>import os

application.secret_key = os.getenv('SECRET_KEY', 'for dev') 
</code></pre>

<p>Note it also set a default value for development.</p>

<p>You can set the enviroment variable <code>SECRET_KEY</code> manually:</p>

<pre><code>$ export SECRET_KEY=you_key_here  # use $ set ... in Windows
</code></pre>

<p>Or you can save it in a <code>.env</code> file at project root:</p>

<pre><code>SECRET_KEY=you_key_here
</code></pre>

<p>Add it into <code>.gitignore</code>:</p>

<pre><code>.env
</code></pre>

<p>Then you can use <a href=""https://github.com/theskumar/python-dotenv"" rel=""noreferrer"">python-dotenv</a> or something similar to import the variable:</p>

<pre><code># pip install python-dotenv
import os
from dotenv import load_dotenv

load_dotenv()

application.secret_key = os.getenv('SECRET_KEY', 'for dev') 
</code></pre>
"
"51624231","<p>Yes. It's safe to out <strong>encrypted</strong> environment variables in your <code>.travis.yml</code>. The encryption/decryption key is generated by Travis on a per-repo basis, so when others fork your repo or even if you rename it, the encrypted variable is invalidated and you have to encrypt it again.</p>

<p>According to Travis CI, nobody except the automated Travis process may decrypt the value.</p>

<p>The only possible leak is when one of your cooperators goes nuts and decides to reveal it by modifying build script. But since you have a trust system, this isn't going ti be an issue.</p>
"
"51829890","<blockquote>
  <p>I'm trying to use .gitignore to prevent GitHub from committing changes to a file in my project (file contains API key and secret for accessing a web service)</p>
</blockquote>

<p>The <code>.gitignore</code> file does not do this. Git will not ignore changes to files that are in the repository. A file is always either managed by Git (all changes tracked) or ignored by Git (the file is not even present in the repo).</p>

<p>If you want to ignore changes to the file, you have to both remove the file from the repo with <code>git rm</code> <em>and</em> add it to <code>.gitignore</code>. You can make a template copy of the file and write a post-checkout hook to copy it in the right location if the destination file does not exist, if you like.</p>

<p>There are various ways to store secret data needed by an application:</p>

<ol>
<li><p>Secure the Git repo (this is a bit hard to do correctly).</p></li>
<li><p>Store the secret data in a separate, secure Git repo.</p></li>
<li><p>Encrypt the secret data (like with git-secret).</p></li>
<li><p>Use a configuration manager or key store to store the secret data (like Apache ZooKeeper or HashiCorp Vault).</p></li>
</ol>
"
"51923031","<p>You'd better heed the advice. Storing the key is bad but can sometimes be defended if no other options are available. There is however generally no reason to use a static IV. You can just prefix the IV (which is 16 bytes for most modes of operation) to the ciphertext instead.</p>

<p>Anyway, to store them as static values, just take a look at the following code; note that you should generate them as random values in advance, not the static values you're seeing here:</p>

<pre><code>private static final byte[] KEY_DATA = {
    (byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03,
    (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07,
    (byte) 0x08, (byte) 0x09, (byte) 0x0A, (byte) 0x0B,
    (byte) 0x0C, (byte) 0x0D, (byte) 0x0E, (byte) 0x0F,
};

private static final byte[] IV_DATA = {
    (byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03,
    (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07,
    (byte) 0x08, (byte) 0x09, (byte) 0x0A, (byte) 0x0B,
    (byte) 0x0C, (byte) 0x0D, (byte) 0x0E, (byte) 0x0F,
};

public static void main(String[] args) throws Exception {
    Cipher aes = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

    SecretKey key = new SecretKeySpec(KEY_DATA, ""aes"");
    IvParameterSpec iv = new IvParameterSpec(IV_DATA);

    aes.init(Cipher.ENCRYPT_MODE, key, iv);

    ...
}
</code></pre>

<p>Note that <code>SecretKeySpec</code> implements the interface <code>SecretKey</code> for easy usage.</p>
"
"52294083","<p>Depending on what you're trying to achieve you could choose one of those methods:</p>

<ul>
<li>keep file in the tree managed by git but ignore it with entry in <code>gitignore</code></li>
<li>keep file content in environment variable,</li>
<li>don't use file with key at all, keep key content elsewhere (external systems like hashicorp's vault, database, cloud (iffy, I wouldn't recommend that), etc.)</li>
</ul>

<p>First approach is easy and doesn't require much work, but you still has the problem of passing the secret key to different location where you'd use the same repository in a secure manner. Second approach requires slightly more work, has the same drawback as the first one.</p>

<p>Third requires certainly more work then 1st and 2nd, but could lead to a setup that's really secure.</p>
"
"52499822","<h2>Security</h2>

<p>Making public the <code>.git</code> directory is just like make public your repo. If there's no sensitive information in your repo (keys written to hooks or remote-paths what contains secrets, files with plain-text passwords) then it is ok to share.</p>

<h2>Debugging</h2>

<h3>answer taken from @kenorb at <a href=""https://stackoverflow.com/questions/6178401/how-can-i-debug-git-git-shell-related-problems"">How can I debug git/git-shell related problems?</a></h3>

<p>Git has a fairly complete set of traces embedded which you can use to debug your git problems.</p>

<p>To turn them on, you can define the following variables:</p>

<ul>
<li><code>GIT_TRACE</code> for general traces,</li>
<li><code>GIT_TRACE_PACK_ACCESS</code> for tracing of packfile access,</li>
<li><code>GIT_TRACE_PACKET</code> for packet-level tracing for network operations,</li>
<li><code>GIT_TRACE_PERFORMANCE</code> for logging the performance data,</li>
<li><code>GIT_TRACE_SETUP</code> for information about discovering the repository and environment it’s interacting with,</li>
<li><code>GIT_MERGE_VERBOSITY</code> for debugging recursive merge strategy (values: 0-5),</li>
<li><code>GIT_CURL_VERBOSE</code> for logging all curl messages (equivalent to <code>curl -v</code>),</li>
<li><code>GIT_TRACE_SHALLOW</code> for debugging fetching/cloning of shallow repositories.</li>
</ul>

<p>Possible values can include:</p>

<ul>
<li><code>true</code>, <code>1</code> or <code>2</code> to write to stderr,</li>
<li>an absolute path starting with <code>/</code> to trace output to the specified file.</li>
</ul>

<p>For more details, see: <a href=""https://git-scm.com/book/en/v2/Git-Internals-Environment-Variables#Debugging"" rel=""nofollow noreferrer"">Git Internals - Environment Variables</a></p>

<hr>

<h3>SSH</h3>

<p>For SSH issues, try the following commands:</p>

<pre><code>echo 'ssh -vvv $*' &gt; ssh &amp;&amp; chmod +x ssh
GIT_SSH=""$PWD/ssh"" git pull origin master
</code></pre>

<p>or use <code>ssh</code> to validate your credentials, e.g.</p>

<pre><code>ssh -vvvT git@github.com
</code></pre>

<p>or over HTTPS port:</p>

<pre><code>ssh -vvvT -p 443 git@ssh.github.com
</code></pre>

<p><sup>Note: Reduce number of <code>-v</code> to reduce the verbosity level.</sup></p>

<hr>

<h3>Examples</h3>

<pre><code>$ GIT_TRACE=1 git status
20:11:39.565701 git.c:350               trace: built-in: git 'status'

$ GIT_TRACE_PERFORMANCE=$PWD/gc.log git gc
Counting objects: 143760, done.
...
$ head gc.log 
20:12:37.214410 trace.c:420             performance: 0.090286000 s: git command: 'git' 'pack-refs' '--all' '--prune'
20:12:37.378101 trace.c:420             performance: 0.156971000 s: git command: 'git' 'reflog' 'expire' '--all'
...

$ GIT_TRACE_PACKET=true git pull origin master
20:16:53.062183 pkt-line.c:80           packet:        fetch&lt; 93eb028c6b2f8b1d694d1173a4ddf32b48e371ce HEAD\0multi_ack thin-pack side-band side-band-64k ofs-delta shallow no-progress include-tag multi_ack_detailed symref=HEAD:refs/heads/master agent=git/2:2.6.5~update-ref-initial-update-1494-g76b680d
...
</code></pre>
"
"52525766","<p>Instead of adding it in code, or in an application.config folder, it should be stored either in User Secrets, an Environment Variable (which stores it in plaintext so beware), or something like <a href=""https://azure.microsoft.com/en-us/services/key-vault/"" rel=""nofollow noreferrer"">Azure Key Vault</a></p>

<p>See <a href=""https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-2.1&amp;tabs=windows"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-2.1&amp;tabs=windows</a> for options for storing secrets during development.</p>
"
"53035348","<p>As <a href=""https://www.tomfaltesek.com/azure-functions-local-settings-json-and-source-control/"" rel=""noreferrer"">described here</a>, you can add another config file (<code>secret.settings.json</code>) for your secrets.</p>

<pre><code>{
    ""ConnectionStrings"": {
        ""SqlConnectionString"": ""server=myddatabaseserver;user=tom;password=123;""
    },
    ""MyCustomStringSetting"": ""Override Some Name"",
    ""MailSettings"": {
        ""PrivateKey"": ""xYasdf5678asjifSDFGhasn1234sDGFHg""
    }
}
</code></pre>

<p>Add your new settings file to the <code>.gitignore</code>. Then remove <code>local.settings.json</code> from the <code>.gitignore</code> and redact any secret values.</p>

<pre><code>{
    ""IsEncrypted"": false,
    ""Values"": {
        ""AzureWebJobsStorage"": ""UseDevelopmentStorage=true"",
        ""FUNCTIONS_WORKER_RUNTIME"": ""dotnet""
    },
    ""ConnectionStrings"": {
        ""SqlConnectionString"": ""--SECRET--""
    },
    ""MyCustomStringSetting"": ""Some Name"",
    ""MyCustomNumberSetting"": 123,
    ""MailSettings"": {
        ""FromAddress"": ""local-testing123@email.com"",
        ""ToAddress"": ""receiver@email.com"",
        ""MailServer"": ""smtp.mymailserver.com"",
        ""PrivateKey"": ""--SECRET--""
    }
}
</code></pre>

<p>Then make sure that your extra config file is included.</p>

<pre><code>var config = new ConfigurationBuilder()
    .SetBasePath(context.FunctionAppDirectory)
    .AddJsonFile(""local.settings.json"", optional: true, reloadOnChange: true)
    .AddJsonFile(""secret.settings.json"", optional: true, reloadOnChange: true)
    .AddEnvironmentVariables()
    .Build();
</code></pre>

<p>With this technique, at least all settings are being tracked in source control. Any secret values are safely redacted.</p>
"
"53244852","<blockquote>
<p>More fundamentally, are there best practices to keep deployment secrets secret for public repositories?</p>
</blockquote>
<p>Yes, don't have any sensitive data in it. Ever.</p>
<p>At the GCP level, the <a href=""https://cloud.google.com/kms/docs/secret-management"" rel=""nofollow noreferrer"">secret management options are listed here</a>.</p>
<p>When connecting a GitLab-CI to GCP, you can see the <a href=""https://docs.gitlab.com/ee/user/project/clusters/#security-implications"" rel=""nofollow noreferrer"">security implication here</a>, which uses <code>kubectl get secret &lt;secret name&gt; -o jsonpath=&quot;{['data']['ca\.crt']}&quot; | base64 -D</code>, with the right account and <strong><a href=""https://kubernetes.io/docs/reference/access-authn-authz/rbac/"" rel=""nofollow noreferrer"">RBAC</a></strong>.</p>
<blockquote>
<p>The whole cluster security is based on a model where <a href=""https://docs.gitlab.com/ee/user/permissions.html"" rel=""nofollow noreferrer"">developers</a> are trusted, so only trusted users should be allowed to control your clusters.</p>
</blockquote>
<hr />
<p>Note that <a href=""https://about.gitlab.com/2019/01/22/gitlab-11-7-released/#configure-kubernetes-app-secrets-as-variables-for-auto-devops-pipelines"" rel=""nofollow noreferrer"">GitLab 11.7</a> (January 2019) allows for:</p>
<blockquote>
<h2>Configure Kubernetes app secrets as variables for Auto DevOps pipelines</h2>
<p>Operators and administrators require that the configuration of secrets takes place outside the application’s repository to reduce risk and exposure of sensitive data.<br />
To address this need, GitLab now offers the ability to configure secrets as environment variables that are made available to the Auto DevOps application running in your Kubernetes cluster.</p>
</blockquote>
<p><a href=""https://i.stack.imgur.com/ML7b7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ML7b7.png"" alt=""https://about.gitlab.com/images/11_7/autodevops-secrets.png"" /></a></p>
<blockquote>
<p>Simply prepend your variable with <code>K8S_SECRET_</code> and the relevant Auto DevOps CI pipeline will take your application secret variable to populate a Kubernetes secret.</p>
</blockquote>
"
"53687633","<p>Secrets have no place in a source version control hosting service like GitHub.</p>

<p>Regarding OpenShift, it includes <a href=""https://docs.openshift.com/container-platform/3.11/dev_guide/secrets.html?extIdCarryOver=true&amp;sc_cid=701f2000001Css5AAC"" rel=""nofollow noreferrer"">Secrets</a>, an encoded-64 configmap in which you can inject confidential information.</p>

<p>But that long-term confidential information storage (to be injected in OpenShift secrets) ought to be stored in a proper Vault.</p>

<p>Like, for instance, the <a href=""https://www.vaultproject.io/"" rel=""nofollow noreferrer"">Hashicorp Vault</a>, as described by the article ""<a href=""https://blog.openshift.com/managing-secrets-openshift-vault-integration/"" rel=""nofollow noreferrer""><strong>Managing Secrets on OpenShift – Vault Integration</strong></a>""</p>

<p>The rest describes that solution, but even if you don't use that particular host, the general idea (an external vault-type storage) remains:</p>

<p><a href=""https://i.stack.imgur.com/zqRkt.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zqRkt.png"" alt=""https://i2.wp.com/blog.openshift.com/wp-content/uploads/vault-1.png?w=1486&amp;ssl=1""></a></p>

<blockquote>
  <ol>
  <li>An <a href=""https://docs.openshift.com/container-platform/latest/architecture/core_concepts/containers_and_images.html"" rel=""nofollow noreferrer"">Init Container</a> (run before the main container of a pod is started) requests a <a href=""https://www.vaultproject.io/docs/concepts/response-wrapping.html"" rel=""nofollow noreferrer"">wrapped token</a> from the Vault Controller over an encrypted connection.<br>
  Wrapped credentials allow you to pass credentials around without any of the intermediaries having to actually see the credentials.</li>
  <li>The Vault Controller retrieves the pod details from the Kubernetes API server.</li>
  <li>If the pod exists and contains the vaultproject.io/policies annotation, the Vault Controller calls Vault and generates a unique wrapped token with access to the Vault policies mentioned in the annotation. This step requires trust on pod author to have used to right policies. The generated token has a configurable TTL.</li>
  <li>The Vault Controller “calls back” the Init Container using the pod IP obtained from the Kubernetes API over an encrypted connection and delivers it the newly created wrapped token. Notice that the Vault Controller does not trust the pod, it only trusts the master API.</li>
  <li>The Init Container unwraps the token to obtain a the Vault token that will allow access to the credentials.</li>
  <li>The Vault token is written to a well-known location in a volume shared between the two containers (emptyDir) and the Init Container exits.</li>
  <li>The main container reads the token from the token file. Now the main container can use the token to retrieve all the secrets allowed by the policies considered when the token was created.</li>
  <li>If needed, the main container renews the token to keep it from expiring.</li>
  </ol>
</blockquote>
"
"54480657","<p>No, this is not ok. You should never add sensitive values to your GIT repository.<br>
Unfortunately, Heroku doesn't give any way to send secure/encrypted values when using heroku.yml files.<br>
So if this is something you need to do, you will not be able to use that feature.</p>
"
"54601890","<p>Short answer: Don't put secrets in configuration files.</p>

<p>If all your resources reside in Azure, use Managed Service Identities so that you don't need to bother with connection strings.</p>

<p>If not, use <a href=""https://docs.microsoft.com/en-us/azure/app-service/app-service-key-vault-references"" rel=""noreferrer"">ARM templates and key vault-linked parameters</a> to manage your Azure infrastructure. Azure Web Apps allow you to override configuration files with app settings/connection strings <em>within the web app</em>. So simply use key vault to manage that stuff, and tell the web app to pull the values from key vault.</p>
"
"54893051","<p>The <code>appsettings.json</code> file should never be used for secrets simply because it's committed to source control. That alone makes it a bad choice. However, there is also no capability to encrypt anything in <code>appsettings.json</code>. You could, I suppose, encrypt your secrets via some other means and merely place the ciphertext in <code>appsettings.json</code> manually after the fact, but then you would need some facility to decrypt the secret later, when then means exposing your means of encryption (i.e. your private key), which kind of defeats the entire point. Long and short, don't use <code>appsettings.json</code>.</p>

<p>Environment variables are a compromise solution. Since you manually set them on the server (not in your source control) and they can be made to only be accessible to certain users (restricted access), you get a modicum of security. However, they are also stored plaintext, which means if someone is able access the server to view them, all security is out the window. Environment variables can also be set as part of your CI\D pipeline in DevOps (formerly VSTS), so direct access to the server is not necessarily a prerequisite as long as the service account doing the deploy has the necessary access.</p>

<p>Azure Key Vault is the recommended approach because it's the only built-in config provider that supports encryption, meaning your secrets are encrypted at rest and pretty much secure end-to-end. However, there's nothing uniquely special about Azure Key Vault other than its ready availability. You can conceivably use any type of service that lets store secrets securely; you may just have to write your own config provider to target it.</p>
"
"55022429","<p>You have used the <em>dotenv</em> package, because it creates a file and saves it into your process, whereas <em>config.js</em> will not save in the process.</p>
<p>But why do I have to save in the process?</p>
<p>The first thing: credentials will never be pushed to <a href=""https://en.wikipedia.org/wiki/Git"" rel=""nofollow noreferrer"">Git</a> or any other version control system. If we don't push this file to Git, and if I clone it after some later time, the program will crash. But in this case, if I use the <em>Process.env</em> property, the program will not crash.</p>
<p>And second, if we have big team, we can also put extra security on the process file and but put extra security on the JavaScript file, because the developing team should have access to these file for editing and other stuff.</p>
<p>This is useful for more information:
<em><a href=""https://medium.com/@sherryhsu/managing-configurations-in-node-js-apps-with-dotenv-and-convict-d74070d37373"" rel=""nofollow noreferrer"">Managing Configurations in Node.js applications with dotenv and convict</a></em></p>
"
"55066667","<p>It's not clear in your question whether you're storing this sensitive data on Angular's side or Electron's side.
In any case, you're not supposed to store sensitive data such as API keys and whatnot inside Angular or any front-end framework, as all of these files are going to be visible by the browser once built.</p>

<p>What you need to do is make sure you store such files in your back-end (e.g. <code>.env</code> file), or in the case of ElectronJS, there's <a href=""https://electronjs.org/docs/api/environment-variables"" rel=""nofollow noreferrer"">this simple technique</a> explained by Electron's DOCs.</p>
"
"55083965","<p>While the question was specifically about management of env.yml files, the bigger underlying question is how to manage sensitive environment variables. The link in the comment from Alex is all I needed. Our solution is so AWS-oriented that the AWS Parameter Store is worth exploring.</p>

<p><a href=""https://serverless.com/blog/serverless-secrets-api-keys/"" rel=""nofollow noreferrer"">Alex DeBrie's article</a></p>

<p><a href=""https://hackernoon.com/you-should-use-ssm-parameter-store-over-lambda-env-variables-5197fc6ea45b"" rel=""nofollow noreferrer"">Yan Cui's article on referencing parameter store values at runtime</a></p>
"
"55115291","<p>Storing an API key in an app is problematic. You can obfuscate it or hide it in a computation, but if the secret is valuable enough, someone will extract it.</p>

<p>You are on a good track thinking about sending your key from a server. That keeps the key out of the app package itself. You must protect that communication, so TLS is a must, and you should go further and <a href=""https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning"" rel=""nofollow noreferrer"">pin the connection</a> to avoid man-in-the-middle attacks.</p>

<p>Rather than sending the key itself, I would send a time-limited token signed by your API key. You'll need to send different tokens over time, but the API key is never directly exposed on the app, and you can change the signing key without requiring an app field upgrade. If a token is stolen, at least it is only valid for a limited period of time.</p>

<p>You still need to make sure you don't send tokens to a tampered app or even a bot who has reverse engineered your protocol. You need to authenticate the installed app package/code as well as check for a safe run time environment (not running in a debugger, no frameworks like frida or xposed, etc.). You could add tamper-detection to your app, but since you're already sending tokens to your app, I think it is a better approach to set up a challenge-response protocol which will cryptographically attest the app. That way you and not the app makes the actual authenticity decision.</p>

<p>For additional background on user and app authenticity, check out a 3 part blog post, starting with <a href=""https://hackernoon.com/mobile-api-security-techniques-682a5da4fe10"" rel=""nofollow noreferrer"">Mobile API Security Techniques</a>, or if you prefer video, check out <a href=""https://hackernoon.com/a-tour-of-api-underprotection-2ad86fc5ce48"" rel=""nofollow noreferrer"">A Tour of Mobile API Underprotection</a>. You can also look at <a href=""https://approov.io"" rel=""nofollow noreferrer"">approov.io</a> for a commercial implementation of challenge-response attestation and JWT tokens.</p>
"
"55474534","<p>Heroku let you set some environment variables, more details <a href=""https://devcenter.heroku.com/articles/config-vars"" rel=""nofollow noreferrer"">here</a>, and you can get them with <code>process.env.MY_ENV_VAR</code>.<br>
This is a recommended way for building applications referring to the <a href=""https://12factor.net/"" rel=""nofollow noreferrer"">Twelve-Factor App</a>.  </p>
"
"55744715","<p>Secrets management <strong>should</strong> be done outside the app, preferably with help of third party products / API, as it could be cumbersome to create our very own robust secret management system.</p>

<p>One such popular &amp; robust product for secret management is <a href=""https://www.vaultproject.io/"" rel=""nofollow noreferrer"">HashiCorp Vault</a>. </p>

<p>Since you are already using Spring do refer to <a href=""https://spring.io/blog/2016/06/24/managing-secrets-with-vault"" rel=""nofollow noreferrer"">this excellent article</a> on how vault can be utilized for the secrets management.</p>
"
"55777154","<h1>Update</h1>

<p>If you want to deploy to Heroku, a better approach would be to use an environment variable.</p>

<p>Change:</p>

<pre><code>TOKEN = None

with open(""token.txt"") as f:
    TOKEN = f.read().strip()
</code></pre>

<p>to:</p>

<pre><code>import os

TOKEN = os.environ[""TOKEN""]
</code></pre>

<p>Then, use the command <code>heroku config:add TOKEN=…</code> to set the environment variable.</p>

<p>To run your bot locally, use:</p>

<pre><code>TOKEN=… python3 bot.py
</code></pre>

<p>I hope that helps!</p>

<hr>

<h1>Original answer</h1>

<p><code>.gitignore</code> cannot be used to ignore lines of code, only whole files.</p>

<p>However, you could read the token from a file, and put <em>that</em> in your <code>.gitignore</code>.</p>

<p>Here's how I'd do it:</p>

<ol>
<li><p>To be safe, first revoke your token by sending the <code>/revoke</code> command to <a href=""https://t.me/botfather"" rel=""noreferrer"">@BotFather on Telegram</a>.</p></li>
<li><p>Put <code>token.txt</code> in your <code>.gitignore</code> and commit.</p></li>
<li><p>Create a file <code>token.txt</code> next to your bot code and put your
new token in it.</p></li>
<li><p>After that, change the the line that says <code>TOKEN = …</code> to:</p>

<pre><code>TOKEN = None

with open(""token.txt"") as f:
    TOKEN = f.read().strip()
</code></pre>

<p>This will read the <code>token.txt</code> file you created earlier, and store
it in the <code>TOKEN</code> variable, so your token stays private.</p></li>
</ol>
"
"56337260","<p>revoke the current key and create a new one (for safety reasons)</p>

<p>you can remove it by filtering the branch you are working on by using
<code>git filter-branch</code> </p>

<p>you can find about it in details here</p>

<p><a href=""https://help.github.com/en/articles/removing-sensitive-data-from-a-repository"" rel=""nofollow noreferrer"">https://help.github.com/en/articles/removing-sensitive-data-from-a-repository</a></p>
"
"56370226","<p>There are lots of answers about <em>how</em> to remove sensitive commits, e.g., <a href=""https://stackoverflow.com/q/872565/1256452"">Remove sensitive files and their commits from Git history</a>.  Any good answer warns you that it's probably too late anyway, which is true.  Not too many go into details about <em>when and why</em> it is too late, but the answer is pretty straightforward: it's not not a lot of <em>use</em>.  The rest of this answer is about when and why it's too late, and why just deleting the commit with an interactive rebase is not sufficient.</p>

<p>The heart of the problem is that commits cannot be changed, and Git is wired to add <em>new</em> commits.  Removing old / dead commits (and other dead objects) happens as a side effect, with little control on your part.  When you do virtually anything—no matter what: <code>git commit --amend</code>, <code>git rebase -i</code>, <code>git reset --hard</code>, none of this matters—any <em>existing</em> commit remains in your database of commits, unchanged, undisturbed, and still available by its hash ID.  Nonetheless, it <em>is</em> possible to remove a commit for real.  It's just hard to do it in a controlled and correct manner.</p>

<h3>Representing and finding commits</h3>

<p>Each commit—in fact, each object<sup>1</sup> in Git's main database—is accessed by its hash ID.  The hash ID of the <em>last</em> commit in a branch is found in a second, smaller database.  Essentially, a branch name like <code>master</code> says: <em>the tip commit of <code>master</code> is <code>a123456...</code></em>, which provides the hash ID of the commit object so that you—or Git—can go back to the main database and say: <em>Get me object <code>a123456...</code></em>.</p>

<p>Every commit can list the hash ID(s) of some previous, or <em>parent</em>, commits.  That is, having obtained object <code>a123456...</code>, you can then fish around inside it for the parent hash IDs.  If the (single) parent hash ID of <code>a123456...</code> is <code>9876543...</code>, you then go back to the main database and say: *Get me object <code>9876543...</code> and you have the previous commit.  That's how you—and Git—can start from <em>end</em> of a branch and work backwards, one commit at a time:</p>

<pre><code>... &lt;-grandparent &lt;-parent &lt;-last-commit   &lt;--branchname
</code></pre>

<p>If we use single uppercase letters to stand in for hash IDs, and just <em>remember</em> that the arrows (from child to parent) always point backwards, we get something that's easier to draw when you have multiple branches:</p>

<pre><code>...--E--F--G   &lt;-- master
         \
          H  &lt;-- develop
</code></pre>

<p>But in all cases, whenever you do something to ""change"" your history—for instance, if we decide commit <code>G</code> is bad and must be replaced—you don't actually <em>change</em> anything.  Instead, Git in effect just moves the bad commit out of the way:</p>

<pre><code>          G
         /
...--E--F--I   &lt;-- master
         \
          H  &lt;-- develop
</code></pre>

<p>The main object database is <em>not</em> cleaned out immediately, and if you have <em>any</em> way to remember the hash ID of commit <code>G</code>, you can ask Git for <code>G</code> by that hash ID.  Git will present it to you, because <em>it's in the database!</em></p>

<p>This same description is true regardless of how you ""delete"" or ""change"" a commit: Git just ends up making copies of every <em>other</em> commit, so that the ""deleted"" or ""changed"" commit (here, <code>G</code> is to be deleted) is now on a different branch-line:</p>

<pre><code>...--o--F--G--H--J--...   &lt;-- branch
</code></pre>

<p>becomes:</p>

<pre><code>          G--H--J--...   [previous branch, now abandoned]
         /
...--o--F--H'-J'-...   &lt;-- branch
</code></pre>

<p>where <code>H'</code> is a copy of <code>H</code> adapted to come after <code>F</code> instead of <code>G</code>, <code>J'</code> is a copy of <code>J</code> adapted to come after <code>H'</code>, and so on.  Again, <code>G</code> isn't really <em>gone</em>, it's just shoved up out of the way, along with all of its descendants.  All of its descendants are replaced by slightly-altered copies, with new, different hash IDs.</p>

<hr>

<p><sup>1</sup>There are four types of objects.  <em>Commit</em>, <em>tree</em>, and <em>blob</em> objects work together to store files in commits, with <em>annotated tag</em> objects making the fourth type.  Each commit refers to one tree; that tree refers to additional sub-trees if needed, and to blobs to hold the files that go with that commit.</p>

<hr>

<h3>Removing commits</h3>

<p>So, when—and how and why—do commits eventually go away?  The answer is that Git has a maintenance command, <code>git gc</code>, whose job is to walk the entire main database of <em>every</em> object, while also walking the other database of all names by which one can <em>find</em> objects.  If there is <em>no</em> name by which we can find commit <code>G</code>, after an operation like the above, <code>git gc</code> will determine that this is the case, and—eventually—kick <code>G</code> out of the main database, using whatever the operating system's normal deletion functions are for deleting a file.<sup>2</sup></p>

<p>More formally, for <code>git gc</code> to delete an object from the main database, the object must be <em>unreachable</em>.  For a pretty through discussion of the notion of reachability, see <a href=""http://think-like-a-git.net/"" rel=""noreferrer"">Think Like (a) Git</a>.  Unfortunately for your particular use case, the set of names by which we can reach commits includes any commit in any <em>reflog</em>.</p>

<hr>

<p><sup>2</sup>Typically this is an <em>insecure</em> delete, so that if you have control of the underlying storage media, you can still get the data back that way, but now it's obviously that much harder.  In any case, now no one can just ask that Git repository for commit <code>G</code> by hash ID.  Beware of file systems that support snapshots, though: you can just wind back to a previous snapshot and recover the entire repository as it was at the time of the snapshot!</p>

<hr>

<h3>Finding commits part 2: the reflogs</h3>

<p>There is a reflog for every branch name, such as <code>master</code>, plus one for <code>HEAD</code>.  (There are probably additional reflogs, but these are the two important ones here.)  In the example above, commit <code>G</code> is no longer reachable from the name <code>master</code>, but there are still two reflog entries, <code>master@{1}</code> and <code>HEAD@{1}</code>, both of which server to find commit <code>G</code>.  So <code>git gc</code> will not delete commit G—not yet, anyway.</p>

<p>The reflog entries that do find <code>G</code> <em>will</em> be deleted, eventually.  In particular, <code>git reflog expire</code> automatically deletes sufficiently-old and therefore <em>expired</em> reflog entries.  How old is sufficiently old is something you can configure, but it defaults to either 30 or 90 days,<sup>3</sup> and in this case, to 30 days.</p>

<p>What <em>this</em> means is that by default, <code>G</code> will stick around until a <code>git gc</code> uses <code>git reflog</code> to delete the reflog entries, once they're sufficiently old—i.e., at least 30 days from now.  You can use <code>git reflog</code> (see <a href=""https://git-scm.com/docs/git-reflog"" rel=""noreferrer"">the documentation</a>) to delete or expire the entries for <code>G</code> sooner, if you want to speed that part up; or see cloning below.</p>

<p>Once the reflog entries are gone, so that <code>G</code> really is (globally) unreachable, <code>git gc</code> will remove it.  You can tell that this has happened because <code>git show <em>hash</em></code> and <code>git rev-parse <em>hash</em></code> will tell you that they have no idea what hash ID you are talking about.</p>

<p>Remember, too, that if your Git has contacted another Git, your Git may have given that other Git commit <code>G</code>.  In particular, when you run <code>git push</code>, you have your Git call up another Git and feed them commits.  If you've given <em>them</em> commit <code>G</code>, nothing you do in your own repository can take that back.  If you allow other users to <code>git fetch</code> from your repository, they may have taken a copy of <code>G</code>, and again, nothing you do in your own repository can take that back: you must convince <em>them</em> to discard the commit.</p>

<p>Reflogs are not copied by <code>git clone</code>, so another way to get rid of <code>G</code>, without waiting, is to clone your own repository.  What <code>git clone</code> does is to make a <em>new</em> repository, then fetch from the original repository.  The commits a fetch gets are those that are reachable from the names the source repository exposes.  So, rather than manually expiring some reflog entries and then running <code>git gc</code>, you can just clone your own repository.  There's a drawback here: you lose the safety net of all of your reflogs, and your own branch names become your new repository's <code>origin/*</code> names.<sup>4</sup></p>

<hr>

<p><sup>3</sup>The choice between 30 and 90 days here depends on whether the value in the reflog is reachable from the commit to which the reference itself points.  In this case, the name <code>master</code> points to commit <code>I</code>, for instance, and it's not possible to walk back from <code>I</code> to <code>G</code>, so the value in <code>master@{1}</code>, which points to <code>G</code>, is not reachable from the value on <code>master</code>.  This means the expiration is <code>gc.reflogExpireUnreachable</code>—the one that defaults to 30 days—rather than <code>gc.reflogExpire</code>, which defaults to 90 days.</p>

<p>Note that once again, we depend on the concept of <em>reachability</em> through a directed graph.  This is one of the keys to understanding Git.</p>

<p><sup>4</sup>You can use <code>git clone --mirror</code>, but that gets you a <em>bare</em> repository, and one with an inappropriate default <code>fetch</code> setting.  You can then fix those two, but if you know how to do all this, you'll probably want to use something other than <code>--mirror</code> anyway. 😀</p>

<hr>

<h3>Summary</h3>

<p>If:</p>

<ul>
<li>you haven't shared the unwanted commits with anyone (no fetches or pushes), <em>and</em></li>
<li>you remove all references to the commits, or wait 30 days, and then run <code>git gc</code></li>
</ul>

<p><em>then</em> the commit will be truly gone, absent any sort of resurrection through file-system level snapshots.  You can feed the hash ID to <code>git show</code> or <code>git rev-parse</code> to verify that it is gone.  But if the commit might have been copied anywhere else, you no longer have any control over that.</p>

<p>The safe default is to assume that if the commit was visible to anyone else for any period of time, it <em>has</em> been copied, and the secrets that were in it, are no longer secret.</p>
"
"56411567","<p>Put the application with a the required profile under configuration management (git) and ignore any (local) overriding file.</p>

<p>For example, put a file named <code>.env.dist</code> under version control, while the file <code>.env</code> is in the <code>.gitignore</code> file of the same project (in that same path):</p>

<pre><code># dot env
/.env
</code></pre>

<p>Make your utility/bot load any <code>.env.dist</code> file by default and <code>.env</code> file overriding that <code>.env.dist</code> file. This allows you to document, plan and define required environment variables while allowing a user to keep a local copy with all the production credentials (if needed).</p>

<p>Then give your bot another parameter to load a different name environment (dot env) file taking the lead. This allows you to run the bot with any different configuration.</p>

<p>If you follow the syntax of environment files as used by the <a href=""https://docs.docker.com/engine/reference/commandline/run/#set-environment-variables--e---env---env-file"" rel=""nofollow noreferrer"">Docker CLI utility</a>, you are most likely pretty inter-operable and can reach far by so w/o giving up much of your freedoms.</p>

<p>So take this as a suggestion.</p>

<p>Another one: If you would like to use diff-utilities to quickly compare between environment files, one tip I can provide is that if you create sections (as otherwise you should order the environment parameter (variable) names by name), give each section a header with (if not on top of the file) an empty line, a singe <code>#</code> comment, another comment with the section name <code># name of section</code> and another single <code>#</code> line. This gives text-base diff tools enough food to keep sections apart of each other (and apart from other single-line comments).</p>

<pre><code>#
# DISCORD API
#
DISCORD_ID
DISCORD_KEY

#
# MYSQL DATABASE
#
MYSQL_HOST
MYSQL_PASS
MYSQL_PORT
MYSQL_USER
</code></pre>

<p>(exemplary <code>.env.dist</code> file hinting required parameter while not providing any secrets)</p>

<pre><code>#
# DISCORD API
#
DISCORD_ID=42
DISCORD_KEY=aefdcd8d71d200efaefdcd8d71d200ef


#
# MYSQL DATABASE
#
MYSQL_HOST=example.com
MYSQL_PASS=root
MYSQL_PORT=34732
MYSQL_USER=root
</code></pre>

<p>(exemplary <code>.env</code> file containing secrets and excluded (do not add!) via <code>.gitinore</code> in the git project directly).</p>

<p>Add more ""dot env"" files into <code>.git/info/exclude</code> and/or if you adopt this pattern to your whole development system into your <em>global <code>.gitignore</code></em>. Read the description in the <a href=""https://git-scm.com/docs/gitignore"" rel=""nofollow noreferrer"">Git gignore Documentation</a> how the (multilevel) gitignore is used and when it does not ignore any of the files even if specified.</p>
"
"56488610","<p>Storing credentials/sensitive information in source code is a bad practice. It could be avoided by storing them in external location. Depending on requirements/security level external location could be:</p>

<ul>
<li>environment variable</li>
<li>configuration file not stored in version control</li>
<li>database</li>
<li>dedicated system like Hashicorp's Vault</li>
</ul>

<p>Regarding your other part of the question – removing already pushed credentials. First disable leaked credentials (there are bots looking for them, both from Github and malicious users).</p>

<p>When credentials are disabled you need to rewrite history. This could be done with <code>git rebase</code>. Please be informed that rewriting public history is considered a bad practice and should be avoided. I would rather disable credentials and add commits that adds modification described in first part of the answer.</p>

<p>Doing the change automatically is possible with using pre-commit hook on your side, but that is not the best idea. After that change <code>git status</code> will always show you that workspace differs from index.</p>

<p>Other option would be to use filters, but that sound like overengineering to me. With this you'll fix the problem, but not the root cause (storing credentials in plain text in source code).  </p>
"
"56589973","<p>According to this Github <a href=""https://help.github.com/en/articles/removing-sensitive-data-from-a-repository"" rel=""nofollow noreferrer"">documentation</a>, the only truly secure way to remove your keys / passwords from git is to regenerate the keys / passwords, as @max630 pointed out. </p>

<p>This is the path I have taken. </p>

<p>Regarding storing keys elsewhere, I have, for the time being, just decided to store them in S3. This might not be secure enough for you, but it works for my purposes now. </p>
"
"56825233","<p>Personally, I use <a href=""https://www.npmjs.com/package/config"" rel=""nofollow noreferrer"">config</a> for public app configuration/constants and <code>.env</code> file and <a href=""https://www.npmjs.com/package/dotenv"" rel=""nofollow noreferrer"">dotenv</a> package for secrets.</p>

<p>Then add <code>.env</code> in <code>.gitignore</code>.</p>

<p>So example project would be</p>

<pre><code>config // app configuration/constants
 - prod.json
 - dev.json
 - test.json
.env // secrets
src/
 - models
 - app.js
 ...
</code></pre>

<p>----- added -----</p>

<p>Why don't you put the config in the src dir?</p>

<p>A: Of course it's totally up to you where to put your <code>config</code> folder.
It's just a matter of preference.</p>

<p>What about staging config? </p>

<p>A: Like question#1, you can add <code>staging.json</code> under <code>config</code>.</p>

<p>If you don't provide any placeholder file for .env, how do I know which passwords should I fill in this file?</p>

<p>A: Typical <code>.env</code> file looks like below.</p>

<pre><code>API_CREDENTIAL=your api credentials
DB_PASSWORD=your db password
</code></pre>

<p>How do you lazyload the prod/dev config files to the node app?</p>

<p>A: I don't see much benefit for lazyloading small json files.
If you're asking specific how to guide for <code>config</code> and <code>dotenv</code> library,
please refer to their Github repository.(<a href=""https://github.com/lorenwest/node-config"" rel=""nofollow noreferrer"">config</a>, <a href=""https://github.com/motdotla/dotenv"" rel=""nofollow noreferrer"">dotenv</a>)</p>
"
"56830196","<p>You are correct. You should put your <code>.env</code> file in <code>.gitignore</code> and create <code>.env</code> file on server manually - either by connecting to server (SSH) and creating file or transfer file using one of secure transfer protocols (SCP, SFTP).</p>
"
"57238436","<p>One common way is to store secrets in an external vault like e.g. Azure Key Vault. There is good documentation on how to do that on Microsoft docs <a href=""https://docs.microsoft.com/en-us/aspnet/core/security/key-vault-configuration?view=aspnetcore-2.2#use-application-id-and-x509-certificate-for-non-azure-hosted-apps"" rel=""nofollow noreferrer"">here</a>. It does require come local configuration like e.g. a certificate to provide credentials to the vault.</p>

<p>It will be merged with your other configuration parameters in the order that you self chose (by calling <code>config.AddAzureKeyVault</code>).</p>

<p>To avoid setting this up for local development environment you can use local secrets (<code>dotnet user-secrets</code> command and adding it to configuration the same way). There is documenation on the same URL about that as well. Be aware that it is no secure store, it's just a file on disk in plain text in practice.</p>

<p>P.S. It is possible to something that won't involve external provider. In the previous .Net ecosystem it was called <code>web.config</code> encryption. Basically you encrypted sections of web.config and the key was stored in windows with only given accounts who had access to it. It was quite a nightmarish experience, but no external provider was used. You can do something similar to that approach, but I don't know if there is something out of the box for .net core for that.</p>
"
"57316462","<p>What I would do is:</p>

<pre><code>git checkout revision-where-the-file-was-added
git rm the-file-with-the-password
git commit --amend --no-edit # fix the revision
git cherry-pick revision-where-the-file-was-added..the-branch # replay all later revision
# if you like the result
git branch -f the-branch
git push -f origin the-branch
git checkout the-branch
</code></pre>

<p>This assumes there's a single line of revisions after the file was added. If there are merges involved in later history, you might have to need to play with options in cherry-pick.</p>
"
"57756108","<p>While it's possible to put secrets in your repository if you're using a custom solution like git-secrets or TravisCI's encrypted secrets, in general you don't want to do that, since anyone with a copy of your repository can access them.  Source code leaks more often than you might imagine, and even if it doesn't, an ordinary developer shouldn't have access to production credentials without a need to access them.</p>

<p>What you generally <em>do</em> want to do is pass your secrets into your code through the environment.  For CI, most CI systems have an encrypted, access-restricted tool that shares secrets only through the environment, and for deployment, many people use a similar tool such as Vault.  Most of these systems store credentials only in an encrypted state and use secret sharing such that it's very difficult to get credentials out of them without authorization, as well as ensure that credentials are accessible only in the proper environment: it isn't possible for developers to get access to these credentials just by having the repo.</p>

<p>And just to avoid any doubt, this isn't about trusting or not trusting people, it's about making sure that people don't accidentally leak information or do the wrong things with it (like use the production credentials when dropping a database).</p>
"
"58087631","<p>You can create another local branch that will not be tracking a remote branch and commit your sensitive files on that local branch.</p>

<pre><code>git checkout -b localOnly
git add sensitiveFile
git commit
git checkout originalBranch
git push (this pushes originalBranch but not localOnly)
</code></pre>

<p>You can also use a .gitignore file to help ensure you don't accidentally add the sensitive files to a branch that will be pushed.</p>

<p>Note that git may remove the sensitiveFile from your worktree when you switch back to originalBranch.  In this case you can get it back into your worktree:</p>

<pre><code>git checkout localOnly sensitiveFile
</code></pre>
"
"60067488","<p>As everyone said in comments, you want to rewrite history.  The usual tool for this is <code>git filter-branch</code>, which is a bit complicated to use because it has so many options.  See any number of existing StackOverflow postings for the many ways to use it (and some alternatives).</p>

<h3>What history rewriting is about</h3>

<p>Remember, a Git repository is primarily two databases:</p>

<ul>
<li><p>The big database consists of Git <em>objects</em>.  There are four kinds of objects which we'll note a bit more about below.  Each object has its own unique hash ID, specific to that one object.</p></li>
<li><p>The smaller database consists of names: branch names, tag names, and other such names.  Each name holds one object hash ID.</p></li>
</ul>

<p>Cloning a Git repository consists of copying some or all of its objects from the big database, as found by looking up hash IDs in the smaller database; and copying some of the names from the smaller database.</p>

<p>History, in a Git repository, is simply the <em>commit objects</em> in that repository.  Depending on how generous you want to be with the definition you can also add <em>annotated tag objects</em> to this.  Names, like branch and tag names, let you find commits.  Annotated tag objects let you find commits.  Commits let you find commits ... and that's pretty much it: you get started—you find a commit object hash ID—by starting with a name.  You need a name to find an annotated tag object too, so even if we're using the expanded definition, you start with a name.</p>

<h3>The four object types</h3>

<p>So, now let's look at the four object types.  These are:</p>

<ul>
<li><p>Annotated tags.  We've already mentioned annotated tag objects.  These hold your tag message, and maybe a GPG signature key or similar, plus a tag-target object hash ID.  Usually that will be the ID of a commit, although any of the four object types are allowed here.</p></li>
<li><p>Commit objects.  A commit holds <em>metadata</em>, which is information <em>about</em> the commit such as who made it and when and their log message, plus the hash ID of a <em>tree</em> object.  The tree object represents the data to go with the commit: the snapshot.  In other words, rather than holding the snapshot directly, the commit holds only the <em>hash ID</em> of the snapshot.  That means that if two commits hold the same source tree, they can share it—there's only the one snapshot.</p>

<p>Each commit can also list the hash ID of one or more predecessor (""parent"") commits.  This is is where <em>history</em> really lives; we'll come back to this in a moment.</p></li>
<li><p>Tree objects.  We mentioned these just above.  They hold small structures, each of which consist of precisely three values:</p>

<ul>
<li>a <em>mode</em>, which is a numeric value from a small set of allowed values;</li>
<li>a <em>name</em>, which is a component name like <code>file.c</code> or <code>subdir</code>; and</li>
<li>a <em>hash ID</em>.</li>
</ul>

<p><br>The hash ID is that of another tree in some cases, or of a <em>blob</em> object in most other cases.  (The remaining case is that they can hold the hash ID of some commit in some <em>other</em> repository, which is a special case called a <em>gitlink</em>, allowed only when the mode is set to <code>160000</code>.  This is how submodules work: the superproject commit holds a submodule repository's commit hash ID, in some tree object.)</p></li>
<li><p>The last kind of object is the <em>blob object</em>.  It holds a file's data, or—for a symbolic link (mode <code>120000</code>) tree entry, the file name that is the target of the link.</p></li>
</ul>

<p>Hence the objects part of the Git repository is where all your files get stored.  <em>Every</em> committed version of <em>every</em> file appears in this database, in the form of blobs that are listed in trees that are listed in commits that are listed in other commits.  Occasionally—rarely or never—a blob or tree is listed directly by a tag object or tag name, and not-so-occasionally, a commit hash ID is listed directly by a tag object or branch name.</p>

<h3>Combining the two databases results in a useful repository</h3>

<p>A branch name, by definition, contains the hash ID of the <em>last</em> commit in the branch.  From there, Git finds each earlier (parent) commit.  This produces a trace through the commit part of the object database.</p>

<p>A tag name usually lists either a tag object or a commit.  ""Peeling off"" the tag by finding its underlying commit leads you to a commit.  That commit has whatever parent(s) it has, and following those, in the same way as you do with branch names, produces a trace through the commit part of the object database.</p>

<p>Going through this process for <em>every</em> name ""reaches"" some set of commits.  Any remaining commits in the object database are, by definition, <em>unreachable</em>.  The reachable commits are the ones that <code>git clone</code> will copy; the unreachable ones will be thrown away.<sup>1</sup></p>

<p>You might wonder why I keep mentioning <em>clone</em> here; we'll get to that in the next section.</p>

<hr>

<p><sup>1</sup>There's some fussiness here with <em>reflogs.</em>  Every name has, or can have, a reflog.  Reflogs have time-and-date stamped entries; each entry stores as hahsh ID.  Running <code>git clone</code> does not copy or use the reflogs, but <code>git gc</code> uses them to avoid throwing away stuff too quickly.  The reflog entries let otherwise-dead objects—usually commits—persist, so that you can bring them back to life for at least 30 days by default.  We already know that a ref name—such as a branch name—holds an object's hash ID.  Branch names are regularly <em>updated</em> to store <em>new</em> hash IDs, when we make new commits for instance.  At this time, Git writes the <em>old</em> value of the name to the branch's reflog.</p>

<p>(A tag, annotated or not, that goes directly to a tree or blob object, keeps that object alive, too.  Normally you don't have tags for tree or blob objects, though.  Also, entries in the <em>index</em> will keep blobs alive, as that's where files that you have <code>git add</code>-ed but not yet <code>git commit</code>-ed are stored.  None of these get cloned either though.)</p>

<hr>

<h3>Rewriting history is about copying commits</h3>

<p>No commit—in fact, no Git object of any type—can ever be changed, not a single bit.  The reason for this is that the object's hash ID is a (cryptographic) checksum of the object's content.  Change one bit and what you have is a new, different object, with a different checksum.<sup>2</sup></p>

<p>To ""rewrite history"", this is exactly what we want: we go through all the reachable commits in the repository.  For each such commit, we decide: <em>Copy this commit, or not?</em>  For each one where we decide that the answer is: <em>Yes, copy it,</em> we also decide: <em>Make some changes while we're at it, or not?</em></p>

<p>If the copy we make is bit-for-bit identical to the original, then the copy <em>is</em> the original.  It remains unchanged and we actually just re-use the original commit.  But if we change <em>anything</em>—including the snapshot—we get a new, different commit, with a new unique hash ID.  By making sure to copy commits in the right order—starting with the very first commit ever and working forwards, instead of Git's preferred backwards order—we ensure that when we <em>don't</em> copy a commit, <em>later</em> commits will use a different set of parent hash IDs, and we'll copy those later commits to new-and-improved commits that have a new-and-improved history behind them.</p>

<p>This process is probably best viewed by example.  Suppose we have this existing history:</p>

<pre><code>A--B--C--D--E--H--I--L--M--N--O--P   &lt;-- master
       \               /
        F--G-------J--K
</code></pre>

<p>as the entire set of commits in the objects database, with one name <code>master</code> finding the <em>last</em> commit, <code>P</code>.  We'll do a copy, and during the copy, we'll keep commit <code>B</code> but change it to remove a file, keep commit <code>C</code> as is, keep commits <code>J</code> and <code>K</code> and <code>M</code>, drop <code>D</code> through <code>L</code> (except <code>J</code> and <code>K</code>) entirely, keep <code>N</code>, drop <code>O</code>, and keep <code>P</code>.  The resulting copy looks like this:</p>

<pre><code>A--B--C--D--E--H--I--L--M--N--O--P   &lt;-- refs/original/refs/heads/master
       \               /
        F--G-------J--K

B'-C'-----M'-N'-P'   &lt;-- master
    \    /
     J'-K'
</code></pre>

<p>We dropped <code>A</code>, so we had to change <code>B</code> in two ways: the new copy has <em>no</em> parent, and it omits the file we didn't want.  That means we had to copy <code>C</code> to change it in just one way: the copy has <code>B'</code> as its parent.  We had to copy <code>J</code> to <code>J'</code> to use <code>C'</code> as the parent; we had to copy <code>K</code> to <code>K'</code> likewise; we had to copy merge commit <code>M</code> to <code>M'</code> to make it have <code>C'</code> and <code>K'</code> as its two parents, and so on.</p>

<p>Having copied the selected commits, making some changes along the way, we have our Git repository change the <em>name</em> <code>master</code> to point to new commit <code>P'</code>.  Note that by starting at <code>master</code> and working backwards, we <em>never visit any of the original commits</em>.  If we'd kept <code>A</code> unchanged, however, we'd have this:</p>

<pre><code>A--B--C--D--E--H--I--L--M--N--O--P   &lt;-- refs/original/refs/heads/master
 \     \               /
  \     F--G-------J--K
   \
    B'-C'-----M'-N'-P'   &lt;-- master
        \    /
         J'-K'
</code></pre>

<p>That is, we'd have changed <code>B</code> only <em>one</em> way, to remove the unwanted file.  We'd still have <code>B'</code> but it would point back to existing commit <code>A</code>, and starting from <code>master</code>, we'd visit only new copies until we got to <code>B'</code>, then go back to commit <code>A</code>.</p>

<p>What about this other funky name, this <code>refs/original/refs/heads/master</code>?  <em>That</em> name—and the reflogs mentioned in footnote 1—will let us see the original history.  But <em>that</em> name is not copied by <code>git clone</code>, and neither are the reflogs.  The funky name itself is a byproduct of <code>git filter-branch</code>, which saves the original names under this new <code>refs/original/</code> set of names, when we tell it to copy <code>master</code> and drop or modify some commits along the way.</p>

<p>So, using <code>git filter-branch</code> to ""rewrite"" history really means: <em>Approximately double the size of my repository database by copying most commits, while changing something about them.</em>  The new and improved copies live <em>next to</em> the originals.  They may even share a few commits, towards the earliest part of history, depending on what you choose to copy and what you choose to change.</p>

<p>If the two histories do not share anything, your new history is stand-alone.  If they do share something, your new history is as clean as you chose to make it: it shares only the <em>first</em> (earliest in history) commits that, when copied, you said <em>leave these alone, they're good just as they are</em>.</p>

<p>You're now ready to use <code>git clone</code> to <em>copy</em> the copied commits.  Since <code>git clone</code> ignores the <code>refs/original/</code> names, and ignores the reflogs, what you get when you copy the current version of the repository to a new one is this:</p>

<pre><code>B'-C'-----M'-N'-P'   &lt;-- master (HEAD), origin/master
    \    /
     J'-K'
</code></pre>

<p>(assuming you didn't tell filter-branch to keep <code>A</code>; if you did, insert <code>A</code> at the left).  The name <code>master</code> appears here only because <code>git clone</code> itself <em>created</em> it after copying the repository to a new database-pair.  The branch names from your original repository have all been replaced with <code>origin/<em>whatever</em></code>, in the usual way for any <code>git clone</code>.</p>

<hr>

<p><sup>2</sup>The ""cryptographic"" part of this just means that it's very difficult to engineer a hash collision.  Hash collisions result in Git pouting and refusing to make the new object, or at least in theory, that's what <em>should</em> happen.  In practice, hash collisions never actually occur.  See also <a href=""https://stackoverflow.com/q/10434326/1256452"">Hash collision in git</a>.</p>
"
"61092540","<p>It's generally not a good idea to do this, even for private repos.  There are various ways parts of your repository may leak (e.g., laptop theft), and while that would be unfortunate, it's not as bad as if you have a leak and <em>also</em> the attacker has credentials to your test environment.  They could then possibly gain a foothold in your network or services, leverage it to extract additional information, or cause excessive usage or costs for your company.  Minimizing the damage an attacker can do in the event of a compromise is prudent and a good security policy.</p>

<p>What some companies choose to do is have a general shell server for employee use and a way to access the credentials (e.g., fetching them from a Vault instance) that are needed to access services, which helps reduce the scope of credential use.  Whether this particular approach is suitable for your network, I can't say, but a similar approach may meet your needs.</p>
"
"61148497","<p>You should commit config files that are static and apply to the project as a whole, but not anything that contains credentials, varies per developer, or would need to be modified in place.</p>

<p>For example, committing an <code>.editorconfig</code> file or a file that works with your project's code formatting or linting tool is a good idea, since these set the style for your project and let all developers use a consistent set of formatting standards.</p>

<p>You should avoid committing files for a particular editor, since different developers use different editors, and likewise you should avoid committing any config file that contains a developer's signing certificate or user ID (of whatever kind).</p>

<p>If your program reads from a given config file on startup and that config file will need to be modified, you should not commit it in that location; instead, you should commit a template or sample next to it that can be modified as appropriate.</p>

<p>This helps each developer have the necessary tools and config files to write, lint, style, and run the project without having committed files that are irrelevant or must constantly be in a modified state.</p>
"
"61380761","<p>A good practice regarding environment variables is storing them in an environment (.env) file, which in Node.js you can access using the <strong>dotenv</strong> npm package.</p>
<p>This allows to avoid pushing sensitive data to versioning systems like Git or SVN and adds flexibility to use several instances of an application, which can represent ease of deployment and configuration for development pipelines.</p>
<p><strong>dotenv in npm:</strong> <a href=""https://www.npmjs.com/package/dotenv"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/dotenv</a></p>
"
"61388148","<p>The security issue with what you are doing is not the environment variable itself, but the fact that you are storing the secret's plain decrypted value in it, making it accessible by the <code>os.environ</code> command while your instance is running.</p>

<p>A simpler solution would be to dump that sensitive information to a file and store it on a Cloud Storage Bucket only your app engine's service account has access to, like this:</p>

<pre><code>TEST_PW=$(gcloud secrets versions access latest --secret=test-key)
echo ""TEST_PASSWORD=$${TEST_PW}"" &gt;&gt; [YOUR_FILE_URL]
unset TEST_PW
</code></pre>

<p>If you want to keep using environment variables, you can do it by using Cloud KMS to keep data encrypted, you can find a how to <a href=""https://cloud.google.com/cloud-build/docs/securing-builds/use-encrypted-secrets-credentials#encrypt_credentials"" rel=""nofollow noreferrer"">here</a>, which is a different section of the same documentation you shared on your question.</p>
"
"61412164","<p>Before you do anything else, deactivate the compromised API key.<br>
Then search through your repository for any other API keys, connection strings, etc, and deactivate them as well.<br>
Even if you remove the key from your code and push, it's still in the repository's history.</p>

<hr>

<p>It's best to keep your API keys and other secure information out of the code base completely.</p>

<p>My personal preference is to store them in encrypted environment variables on the deployment environment itself.<br>
This approach also has the added benefit of preventing you from accidentally deploying the Prod API Key to the QA environment (or vice a versa).  </p>

<p>Another common approach is use a build pipeline and have that pipeline add the secure value to the code's config files at build time.</p>
"
"61648293","<p>You can make your code to look for a LOCAL config.json and read the actual keys off of that, and just .gitignore the local config.json so it's never uploaded. </p>
"
"61699655","<p>The reason it's considered safer is because you should have your settings file in git or some other VCS to have consistent development environments, but your secrets should be outside of it. This way, even developers don't have the production secrets if they don't need them.</p>

<p>It doesn't need any extra protection as long as you're careful about how you deploy your code, who can access the servers, etc.</p>

<p>Your question also asks about other methods, so...</p>

<p>You could encrypt it like you have there, but this will always require a master key that also needs securing somehow.</p>

<p>Another option is to use a text file on the server.</p>

<p>A good option if you want to encrypt the secrets is to store them encrypted in your continuous integration solution, which injects them into the environment at deploy time. Travis CI, GitHub Actions, more or less any CI solution can do this.</p>

<p>But in general, just keeping it out of VCS and limiting the access to the secrets is usually good enough.</p>
"
"61732752","<h2>YOUR PROBLEM</h2>

<blockquote>
  <p>Where to keep static information securely in Android app?</p>
</blockquote>

<p>No matter where and how you store them, because from the moment you release your mobile app, any secret on it belongs now to the public domain.</p>

<blockquote>
  <p>I have tried Cryptography as well, but then I will have to store the secretKey also for decryption.</p>
</blockquote>

<p>You can make this hard to be reverse engineered by static analysis by hiding it in the C code, using the JNI/NDK interface in Android, like I do in this <a href=""https://github.com/approov/currency-converter-demo/tree/0.4.0/mobile-app/android/app/src/main/cpp"" rel=""nofollow noreferrer"">Currency Converter Demo</a> repo, but then if the attacker is not able to reverse engineer it this way, he will do it during run-time with an instrumentation framework, and a popular one is <a href=""https://www.frida.re/"" rel=""nofollow noreferrer"">Frida</a>:</p>

<blockquote>
  <p>Inject your own scripts into black box processes. Hook any function, spy on crypto APIs or trace private application code, no source code needed. Edit, hit save, and instantly see the results. All without compilation steps or program restarts.</p>
</blockquote>

<p>Another alternative it's to try to compute the secret keys at runtime, but then once more Frida will hook on the function that does this and extract the secret from it's return value.</p>

<p>A basic code example of computing an HMAC during run-time can be found the the <a href=""https://github.com/approov/shipfast-api-protection/blob/b45b4ced2a77a4c140fa29bc09b941b8a6c534c6/app/android/kotlin/ShipFast/app/src/main/java/com/criticalblue/shipfast/api/RestAPI.kt#L240-L282"" rel=""nofollow noreferrer"">ShipFast Demo</a> repo:</p>

<pre><code>private fun calculateAPIRequestHMAC(url: URL, authHeaderValue: String): String {

        val secret = JniEnv().getHmacSecret()
        var keySpec: SecretKeySpec

        // Configure the request HMAC based on the demo stage
        when (currentDemoStage) {
            DemoStage.API_KEY_PROTECTION, DemoStage.APPROOV_APP_AUTH_PROTECTION -&gt; {
                throw IllegalStateException(""calculateAPIRequestHMAC() not used in this demo stage"")
            }
            DemoStage.HMAC_STATIC_SECRET_PROTECTION -&gt; {
                // Just use the static secret to initialise the key spec for this demo stage
                keySpec = SecretKeySpec(Base64.decode(secret, Base64.DEFAULT), ""HmacSHA256"")
                Log.i(TAG, ""CALCULATE STATIC HMAC"")
            }
            DemoStage.HMAC_DYNAMIC_SECRET_PROTECTION -&gt; {
                Log.i(TAG, ""CALCULATE DYNAMIC HMAC"")
                // Obfuscate the static secret to produce a dynamic secret to initialise the key
                // spec for this demo stage
                val obfuscatedSecretData = Base64.decode(secret, Base64.DEFAULT)
                val shipFastAPIKeyData = loadShipFastAPIKey().toByteArray(Charsets.UTF_8)
                for (i in 0 until minOf(obfuscatedSecretData.size, shipFastAPIKeyData.size)) {
                    obfuscatedSecretData[i] = (obfuscatedSecretData[i].toInt() xor shipFastAPIKeyData[i].toInt()).toByte()
                }
                val obfuscatedSecret = Base64.encode(obfuscatedSecretData, Base64.DEFAULT)
                keySpec = SecretKeySpec(Base64.decode(obfuscatedSecret, Base64.DEFAULT), ""HmacSHA256"")
            }
        }

        Log.i(TAG, ""protocol: ${url.protocol}"")
        Log.i(TAG, ""host: ${url.host}"")
        Log.i(TAG, ""path: ${url.path}"")
        Log.i(TAG, ""Authentication: $authHeaderValue"")

        // Compute the request HMAC using the HMAC SHA-256 algorithm
        val hmac = Mac.getInstance(""HmacSHA256"")
        hmac.init(keySpec)
        hmac.update(url.protocol.toByteArray(Charsets.UTF_8))
        hmac.update(url.host.toByteArray(Charsets.UTF_8))
        hmac.update(url.path.toByteArray(Charsets.UTF_8))
        hmac.update(authHeaderValue.toByteArray(Charsets.UTF_8))
        return hmac.doFinal().toHex()
    }
</code></pre>

<p>Bear in mind this is a simple solution, but even a sophisticated one would be vulnerable to Frida scripts used by an attacker.</p>

<h2>SECURITY IN DEPTH</h2>

<blockquote>
  <p>So, am searching for any workaround or proper solution. Any help will be highly appreciated.</p>
</blockquote>

<p>Security is all about adding as many layers as you can afford in order to make it time consuming for an attacker to overcome all of them, and to raise the bar for the skill set necessary by an attacker. </p>

<p>So using C code to hide secrets, like the decryption keys, store encrypted secrets on the Android keystore will throw away the scripts kids, but will leave you vulnerable to attackers that know how to use Frida scripts to hook into your code.</p>

<blockquote>
  <p>In my Andorid app, am using few keys and tokens for authentication and initialisations.</p>
</blockquote>

<p>If your are trying to secure the keys to access your API then you can read <a href=""https://stackoverflow.com/questions/60559419/how-to-secure-an-api-rest-for-mobile-app-if-sniffing-requests-gives-you-the-k/60605789#60605789"">my answer</a> to <a href=""https://stackoverflow.com/questions/60559419/how-to-secure-an-api-rest-for-mobile-app-if-sniffing-requests-gives-you-the-k/60605789#60605789"">this question</a> to understand that implementing the Mobile App Attestation concept will allow you to not need to store secrets to access your API server. For initializations purposes I would recommend that you move this logic to the backend, because any in app decisions can be modified/bypassed with instrumentation Frameworks</p>

<p>Also consider using strong obfuscation techniques for all your code base, that will add another layer of difficulty in the attacker steps to reverse engineer your mobile app.</p>

<h2>DO YOU WANT TO GO THE EXTRA MILE?</h2>

<p>In any response to a security question I always like to reference the excellent work from the OWASP foundation.</p>

<h3>For Mobile Apps</h3>

<p><a href=""https://www.owasp.org/index.php/OWASP_Mobile_Security_Project#Top_Ten_Mobile_Risks"" rel=""nofollow noreferrer"">OWASP Mobile Security Project - Top 10 risks</a></p>

<blockquote>
  <p>The OWASP Mobile Security Project is a centralized resource intended to give developers and security teams the resources they need to build and maintain secure mobile applications. Through the project, our goal is to classify mobile security risks and provide developmental controls to reduce their impact or likelihood of exploitation.</p>
</blockquote>

<p><a href=""https://github.com/OWASP/owasp-mstg"" rel=""nofollow noreferrer"">OWASP - Mobile Security Testing Guide</a>:</p>

<blockquote>
  <p>The Mobile Security Testing Guide (MSTG) is a comprehensive manual for mobile app security development, testing and reverse engineering.</p>
</blockquote>

<h3>For APIS</h3>

<p><a href=""https://github.com/OWASP/API-Security"" rel=""nofollow noreferrer"">OWASP API Security Top 10</a></p>

<blockquote>
  <p>The OWASP API Security Project seeks to provide value to software developers and security assessors by underscoring the potential risks in insecure APIs, and illustrating how these risks may be mitigated. In order to facilitate this goal, the OWASP API Security Project will create and maintain a Top 10 API Security Risks document, as well as a documentation portal for best practices when creating or assessing APIs.</p>
</blockquote>
"
"61846496","<p>You can add variables that you want to be included as part of your static site to <a href=""https://docs.netlify.com/configure-builds/environment-variables/"" rel=""nofollow noreferrer"">Netlify's environment variables</a>, as you've mentioned. That keeps them out of the Git repository.</p>

<p>The tricky part is getting those variables out of the Netlify build environment and into your source code. You have at least two different options, depending on how sensitive your variables are:</p>

<ol>
<li><p>If you don't want your variables to be checked into Git but you are OK having them embedded into your public Javascript/HTML files (Google Maps API key might fall into this category), you can use a build tool like <a href=""https://stackoverflow.com/a/30061249/3312114"">Webpack</a> to inject environment variables into your source code. If you're using React or another framework, they <a href=""https://create-react-app.dev/docs/adding-custom-environment-variables/"" rel=""nofollow noreferrer"">usually have ways</a> to include environment variables from the build environment. If you aren't, you may just need to write a custom build script or leverage a pre-built NPM package to inject a small <code>&lt;script&gt;var myVar = ""&lt;myEnvironmentVariableValue&gt;"";&lt;/script&gt;</code> into your HTML page on build. Actually it looks like Netlify can <a href=""https://docs.netlify.com/site-deploys/post-processing/snippet-injection/#snippet-injection-ui"" rel=""nofollow noreferrer"">inject some custom script</a> into your page. Maybe you could try that.</p></li>
<li><p>If your variables are more sensitive and you don't want them publicly exposed, you need to add an actual server-side component. This could be as fancy as a serverless API or a standard humdrum web server. Then when your front-end needs this secret variable, it reaches out to the server and asks for it, presumably from within an authenticated portion of your website. That keeps the variables out of the public HTML/JS but still lets your site access them on demand.</p></li>
</ol>
"
"61922603","<p>If it's just a small side project, and your GitHub repository is private, there should be no issue in leaving the <code>config.json</code> out of your <code>.gitignore</code>. However, for larger or open-source projects, you can use Heroku's <a href=""https://devcenter.heroku.com/articles/config-vars"" rel=""nofollow noreferrer"">config vars</a>, and that should do the trick. I recommend using config vars but if you just want to throw your code up on Heroku, leaving it out of <code>.gitignore</code> should be fine. I would recommend config vars though, they work reliably.</p>

<p>Thanks,
Jackson</p>
"
"62079083","<p>Best practice would be to place SETTINGS.ini.sample (or similarly named) file in your repository, with some dummy values in it, and include instructions to copy that file as SETTINGS.ini with correct values for whoever is using it. Keep SETTINGS.ini in gitignore.</p>
"
"62083985","<p>Short answer, No.</p>

<p>You might want to consider having that injected in for your release in your release/build pipeline via file or ENV variable.
You could also use a mechanism like Rails secrets where there is an ecrypted file in your repo to which only you hold the key and inject the key for deployment.</p>
"
"62143130","<p>Yes, secrets are safe to use in public repositories but there are some things you should be careful about.</p>
<ul>
<li><p>All secrets are automatically masked in build logs and show as <code>***</code>. However, if during your workflow you create a sensitive credential from a secret (e.g. base64 an API key) then you should <a href=""https://help.github.com/en/actions/reference/workflow-commands-for-github-actions#masking-a-value-in-log"" rel=""noreferrer"">mask the new value</a> so it doesn't leak in the build log.</p>
<pre><code>echo &quot;::add-mask::My sensitive value&quot;
</code></pre>
</li>
<li><p>If you are very concerned about the security of your secrets, I would also suggest not using third party GitHub actions directly by following the action's tags or branches. Fork the action and use <em>your fork</em> in workflows. This will prevent the possibility of someone modifying an action you are using to capture secrets being used by the action, and send them to some external server under their control.</p>
<p>Alternatively, use the action directly and reference the commit hash for the version you want to target.</p>
<pre><code>- uses: thirdparty/foo-action@172ec762f2ac8e050062398456fccd30444f8f30
</code></pre>
</li>
<li><p>Use <a href=""https://help.github.com/en/github/authenticating-to-github/securing-your-account-with-two-factor-authentication-2fa"" rel=""noreferrer"">two-factor authentication (2FA)</a> on your account. If your account is compromised, it's trivial for an attacker to create a workflow and export your secrets.</p>
</li>
<li><p>Repository collaborators or any organization users with <code>write</code> access are able to create a workflow to export secrets. So manage access to your repository carefully.</p>
</li>
</ul>
<p>Points related to pull requests:</p>
<ul>
<li>Public repository <a href=""https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request"" rel=""noreferrer""><code>pull_request</code></a> events triggered by forks do not have access to secrets, <a href=""https://docs.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets#using-encrypted-secrets-in-a-workflow"" rel=""noreferrer"">except for the default <code>GITHUB_TOKEN</code></a>. Additionally, The <code>GITHUB_TOKEN</code> has <a href=""https://docs.github.com/en/actions/configuring-and-managing-workflows/authenticating-with-the-github_token#permissions-for-the-github_token"" rel=""noreferrer"">read-only access when an event is triggered by a forked repository</a>. These are intentional restrictions enforced by GitHub Actions to prevent an attacker creating a pull request containing a workflow that captures secrets, or uses secrets to perform operations.</li>
<li>The <a href=""https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request_target"" rel=""noreferrer""><code>pull_request_target</code></a> event does not have secret restrictions for events triggered by forks. By default it checks out the last commit on the base branch, but it is possible to checkout the pull request HEAD. Choosing to do this requires extreme caution. Passing secrets to any code that could be modified in a pull request could allow an attacker to write code to export secrets.</li>
</ul>
"
"62150970","<p>Split all (hardcoded) configuration data into a separate file, for example <code>Config.java</code> or <code>application.xml</code> or some format you like.</p>

<p>Create a <a href=""https://git-scm.com/docs/gitignore"" rel=""nofollow noreferrer""><code>.gitignore</code></a> file in your project directory, listing all the files / folders that should be ignored, for example the configuration file mentioned above, and some other generated file, compile output, <del>jar file,</del> etc.</p>

<p>If you have accidently added some sensitive data that exists in your Git history, use <code>git filter-branch</code> to remove those file from history.</p>
"
"62229473","<p>If your not storing your .env file in your git repository (which is absolutely the correct thing to do) then you need to manually configure the .env file once you deploy it.</p>

<p>In the instance of Heroku you can set Config Vars:</p>

<p><a href=""https://devcenter.heroku.com/articles/config-vars"" rel=""nofollow noreferrer"">Configuration and Config Vars</a></p>

<p>If you do it that way I believe you have to access the vars in a different manor to env values but it has a local mode so that shouldn't be a problem.</p>
"
"62264147","<p>Simply add <code>keys.json</code> into your <code>.gitignore</code> file.</p>
"
"62279852","<p>If this is the perception you have on GitHub or any other provider, you will have to do a local deployment in your infrastructure. In this way, you have to put extra effort for maintenance and updates and you will lose all the benefits that GitHub provides. </p>

<p>Anyway as a practice sensitive information such as credentials is not stored in git.</p>
"
"63397983","<p>Disclaimer: I have no clue about best practices for dotenv.</p>
<p>If you have a secret that's larger than the allowed 64 KB, you can follow the instructions for <a href=""https://docs.github.com/en/actions/security-guides/encrypted-secrets#limits-for-secrets"" rel=""nofollow noreferrer"">Limits for secrets</a>, roughly this:</p>
<ul>
<li><p>Encrypt your secret:</p>
<pre class=""lang-sh prettyprint-override""><code>gpg --symmetric --cipher-algo AES256 .env
</code></pre>
</li>
<li><p>Store the passphrase as a secret, for example <code>LARGE_SECRET_PASSPHRASE</code></p>
</li>
<li><p>Add the encrypted file to the repository, for example as <code>.env.gpg</code></p>
</li>
<li><p>To decrypt in a workflow, run something like</p>
<pre class=""lang-yaml prettyprint-override""><code>run: |
  gpg --quiet --batch --yes --decrypt \
      --passphrase=${{ secrets.LARGE_SECRET_PASSPHRASE }} \
      --output .env .env.gpg
</code></pre>
</li>
</ul>
"
"63797193","<p>Have a <code>example-settings.json</code> file with dummy data in it.</p>
<p>Have as many <code>settings-ENVIRONMENT-NAME.json</code> files as you have different environments.</p>
<p>Add <code>settings-*</code> to your <code>.gitignore</code> file so that real credentials do not get published by accident.</p>
<p>Include clear instructions (e.g. in your README) on how to name the real settings files.</p>
"
"63865309","<p>The easiest way to do to this is to use some sort of configuration file or environment variable during the build process for publication, defaulting to some example values.  Ideally the app will still work without reporting errors if no token is specified; that's the usual approach for development.</p>
<p>If you use a CI system, you can store those credentials in your CI system's secret store and use them for building and signing when you're doing a production release.</p>
"
"64383446","<p>With <code>git filter-branch</code>, Git runs the filter on <em>every commit</em>.<sup>1</sup>  That is, the tree-filter:</p>
<ul>
<li>checks out the commit (in a temporary directory);</li>
<li>runs the specified command (in that temporary directory); and</li>
<li>builds the replacement commit from whatever that command leaves behind.</li>
</ul>
<p>The filter-branch command repeats this for every commit that is to be copied.  (That's what filter-branch does: it <em>copies</em> commits.  The originals continue to exist.)</p>
<p>Some of your commits have the file; the <code>sed</code> command would work on those commits.  Some of your commits <em>lack</em> the file and the <code>sed</code> command in this case fails.  The failure, which <code>git filter-branch</code> sees as a non-zero exit status from your filtering command(s), causes <code>git filter-branch</code> itself to stop and not do the filtering you wanted.</p>
<p>The solution is to avoid running this <code>sed</code> command entirely when the file does not exist.  There are two ways to do that (see footnote 1) but the <em>simplest</em> is to modify your command to <em>check</em> first.  Instead of:</p>
<pre><code>sed -i '' 's/my_sensitive_data/&lt;your-api-key&gt;/' ./app/src/main/java/com/demo/Test.kt
</code></pre>
<p>you would use:</p>
<pre><code>if [ -f app/src/main/java/com/demo/Test.kt ]; then
    sed -i '' 's/my_sensitive_data/&lt;your-api-key&gt;/' app/src/main/java/com/demo/Test.kt
fi
</code></pre>
<p>Note: if and when you squish this up into a single line, it requires at least one more semicolon.  I left it out (and took out the <code>./</code> as well, since it's redundant) to make the lines fit better for posting purposes.</p>
<hr />
<p><sup>1</sup>Technically, it runs the filter only on <em>the commits you tell it to</em>, which can be fewer commits than <em>every</em> commit.  The commits that will be visited are those that are named explicitly or implicitly via <em>positive references</em>, excluding those named explicitly or implicitly via <em>negative references</em>.  There is a fair bit of jargon in that single sentence and it is worth unpacking it a bit:</p>
<ul>
<li><p>A <em>positive reference</em> is one not preceded by a negation, nor used in any of the various special syntactic methods that negate a reference.  Simple examples of this include <code>feature</code> (a branch name), <code>v2.1</code> (a tag name), and <code>a1234567</code> (an abbreviated commit hash).</p>
</li>
<li><p>A <em>negative reference</em> is one preceded by a negation, or used in syntax that negates: <code>^feature</code>, <code>^v2.1</code>, <code>^a1234567</code>.  For a simple example of a syntax that negates, consider <code>master..feature</code>: this is exactly equivalent to writing <code>feature ^master</code>.</p>
</li>
<li><p>The phrase <em>explicitly or implicitly</em> refers to the fact that Git is <em>walking the commit graph</em>.  For a proper tutorial on what this means, see <a href=""http://think-like-a-git.net/"" rel=""nofollow noreferrer"">Think Like (a) Git</a>.</p>
</li>
</ul>
<p>All positive references mentioned on the command line cause Git to walk the commit graph, marking commits to be copied.  All negative references cause Git to walk the graph, un-marking commits.  If you view the process as &quot;mark first, then unmark&quot; you get the right result: only the <em>marked</em> commits get copied-and-filtered.  If you view it as &quot;unmark first&quot;, then the &quot;mark after&quot; phase must respect all earlier &quot;unmarkings&quot;.  (Git actually does it in a complicated interleaved fashion, so that it always gets the right result, but does so faster than a naive two-pass algorithm.)</p>
<p>Those positive references that are <em>branch names</em> cause the name to be remembered.  Git then arranges all the marked commits into an appropriate order—one topologically sorted as needed for the copying process—and begins the copying.  As it copies, it builds a map from old hash ID to new hash ID.  At the end of the copying process, for each of these saved branch names, Git forces the name to point to the new hash ID instead of the old one, and the filtering is now complete.</p>
<p>Hence, if there's a simple (or complicated!) range expression that lets Git enumerate <em>only</em> the commits you <em>need</em> to copy-and-filter, you can use that, rather than a test in your filter.  For instance, suppose the sensitive data is introduced specifically in commit <code>badf00d</code>, whose parent is <code>cafedad</code>: all <em>good</em> commits are therefore reachable from <code>cafedad</code> and all <em>bad</em> commits are in the commits starting with <code>badf00d</code> and continuing up to the tip of <code>master</code>.</p>
<p>Some commits <em>before</em> <code>cafedad</code>, and possibly <code>cafedad</code> itself, <em>lack</em> the <code>Test.kt</code> file and hence the <code>sed</code> will fail on them.  In that case:</p>
<pre><code>git filter-branch &lt;filter-specifiers&gt; -- cafedad..master
</code></pre>
<p>will do the trick, because this limits the copying-and-filtering to only those commits that (a) <em>have the file</em> and (b) <em>require the edit</em>.</p>
"
"64710964","<p>What is better is to store an <code>httpd.conf.tpl</code> <em>template</em> file with placeholder values in it.</p>
<p>That allows you to <em>generate</em> the right httpd.conf file locally, and to do so automatically on <code>git clone</code>/<code>git checkout</code>.</p>
<p>The generation script will:</p>
<ul>
<li>search the right values for any sensitive data from an external secure referential (like a vault)</li>
<li>replace the placeholder value in <code>httpd.conf.tpl</code> to generate the right <code>httpd.conf</code> (that can be ignored by Git)</li>
</ul>
<p>For that, do register (in a <a href=""https://stackoverflow.com/a/2316728/6309""><code>.gitattributes</code> declaration</a>) a <strong><a href=""https://stackoverflow.com/a/10571580/6309"">content filter driver</a></strong>.</p>
<p><a href=""https://i.stack.imgur.com/tumAc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tumAc.png"" alt=""smudge"" /></a>
<sup>(image from &quot;<a href=""http://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes#Keyword-Expansion"" rel=""nofollow noreferrer"">Customizing Git - Git Attributes</a>&quot;, from &quot;<a href=""http://git-scm.com/book/en/v2/"" rel=""nofollow noreferrer"">Pro Git book</a>&quot;)</sup></p>
<p>The <code>smudge</code> script will generate (automatically, on <code>git checkout</code> or <code>git switch</code>) the actual <code>httpd.conf</code> file as mentioned above.<br />
Again, the generated actual <code>httpd.conf</code> file remains ignored (by the <code>.gitignore</code>).</p>
<p>See a complete example at &quot;<a href=""https://stackoverflow.com/q/22909620/6309"">git smudge/clean filter between branches</a>&quot;.</p>
"
"64737915","<p>Finally thanks to @AndreasJägle I came up with a completely different solution for then what I first thought of.
I dont need a .env-file and dont use the described getConfig() method for this solution anymore. As well there is no need to store environment-variables in Gitlab.</p>
<p>First I now start my node process by passing environment variables at the end of the node command like <code>node dist/index.js variable1</code>.
This environment variable can be read at runtime: <code>const baseUrl = process.argv[2]</code>.
The baseUrl-variable can than be used to send requests to this certain url.</p>
<p>Second because I'am building my project using docker I have to inject the values for the environment-variables into my docker-image. For this I modified my dockerfile like this.</p>
<pre><code>FROM node:12.7-alpine AS build

ENV BASE_URL=localhost
    
...

CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;node dist/index.js $BASE_URL&quot;]
</code></pre>
<p>(note that localhost is the default value for the BASE_URL environment variable and will be overridden)</p>
<p>Finally I use the previously build image in a docker-compose file on my server and set the environment variable like this.</p>
<pre><code>version: &quot;3&quot;

    services:
      test-service:
        image: my-image:latest
        container_name: 'my-container'
        environment:
          - BASE_URL=mydomain.com
</code></pre>
"
"64989199","<p>All connection parameters should be in config files.
You can use something like <code>config</code> package to define all needed parameters, their default values and create config files for all configurations you use (such as a development, a production, a tests configurations).</p>
<p>Obviously these config files should not be stored in version control. You can store a template for a default config file.</p>
<p>When some connection params are defined in code then after some time you will have to change them if your version control host changed its IP-address or something else.</p>
"
"65322935","<p>The most recommended way to save secrets is to use Azure Key Vault.</p>
<ol>
<li><a href=""https://docs.microsoft.com/en-us/azure/key-vault/general/soft-delete-overview"" rel=""nofollow noreferrer"">Key vault does not delete secrets on it's own</a>.</li>
<li>Moreover, if you want you can keep <a href=""https://docs.microsoft.com/en-us/azure/key-vault/general/backup"" rel=""nofollow noreferrer"">backups of Key vault</a> on regular basis.</li>
</ol>
"
"65461480","<p>After reading <a href=""https://dev.to/anuradhasivasubramanian/5-things-to-remember-when-using-an-env-file-to-store-you-api-key-in-a-react-app-4f2o"" rel=""noreferrer"">this</a>, <a href=""https://laracasts.com/discuss/channels/general-discussion/best-practices-for-storing-your-env-files"" rel=""noreferrer"">that</a>, <a href=""https://github.com/motdotla/dotenv/issues/437"" rel=""noreferrer"">this</a>, and other articles, I concluded that there is no certain answer for this question; it depends on your organization / your preferences.</p>
<p>The <strong>recommended method</strong> for most applications is to save them at the root of your project, but include them in your .gitignore file in order to avoid them from being committed to your main repo (one .env file corresponds to each device/environment).</p>
<p>Other methods suggest including them in your repo, but encrypting and decrypting all the passwords inside of them once they load. Another method is to store them in password management programs like <a href=""https://keepass.info/"" rel=""noreferrer"">KeyPass</a>, It really depends on how much effort you want to invest in the security and the time you would like to spend maintaining your application.</p>
"
"65483148","<p>Typically, other individuals who download your code will need to acquire their own API key to make your project run (depending on how your project is setup). They will then add the API Key to their fork (as a secret) or local repository on their machine.</p>
<p>You can securely store your API key as a &quot;Secret&quot; in your GitHub repository by going to:</p>
<ol>
<li><code>Settings</code> tab at top of your repo</li>
<li><code>Secrets</code> option near bottom of left-most column</li>
<li><code>New Repository Secret</code></li>
<li>Enter the variable name for your API Key in the <code>Name</code> field</li>
</ol>
<p>example: SECRET_API_KEY</p>
<ol start=""5"">
<li>Enter your API Key value into the <code>Value</code> field.</li>
<li><code>Add Secret</code></li>
</ol>
<p>Now you just need to ensure that your project references the SECRET_API_KEY variable.</p>
<p><strong>Note</strong>: Other individuals will not be able to access this Secret. Only you, as repo owner, can access this key. Other developers will need to acquire their own API key and store it as a secret in their fork of your project.</p>
"
"65526844","<p>I have used <a href=""https://github.com/rtyley/bfg-repo-cleaner"" rel=""nofollow noreferrer"">bfg-repo-cleaner</a>.</p>
<p>Follow these steps:</p>
<p>1- Install <a href=""https://www.java.com/en/download/"" rel=""nofollow noreferrer"">Java</a> on your system (for me is Windows 10).</p>
<p>2- Download <a href=""https://rtyley.github.io/bfg-repo-cleaner/"" rel=""nofollow noreferrer"">bfg-repo-cleaner</a>.
I have downloaded <code>bfg-1.13.1</code> and located it in the project folder.</p>
<p>3- In the <code>Git Bash</code> type this command:</p>
<pre><code>java -jar bfg-1.13.1.jar --delete-files appsettings.json
</code></pre>
<p>after executing you can see some information like this:
<a href=""https://i.stack.imgur.com/ewz5v.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ewz5v.jpg"" alt=""executing bfg command"" /></a></p>
<p>4- And finally type in the <code>Git Bash</code> this command:</p>
<pre><code>$ git pull
$ git push
</code></pre>
"
"65660327","<p>You need to create an application for access first when using ClientSecretCredential.</p>
<p>Navigate to Azure Active Directory -&gt; App registrations -&gt; New registration</p>
<p><code>tenantId</code> and <code>clientId</code> are in the &quot;Overview&quot; :</p>
<p><a href=""https://i.stack.imgur.com/kwWpM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kwWpM.png"" alt=""enter image description here"" /></a></p>
<p><code>clientSecret</code> is in &quot;Certificates &amp; secrets&quot;:</p>
<p><a href=""https://i.stack.imgur.com/RFTJ7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RFTJ7.png"" alt=""enter image description here"" /></a></p>
<p><strong>Note:</strong> After creating the application, you must add access policy in key vault for the application.</p>
<p><a href=""https://i.stack.imgur.com/pvyTT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/pvyTT.png"" alt=""enter image description here"" /></a></p>
"
"65676168","<p>Yes, you're safe now, but if your secrets were ever on a remote, you should still rotate them as soon as is convenient.</p>
"
"65831462","<p>Your patterns are correct and should work. Maybe post your commands here so we can read what exactly you did.</p>
"
"65933738","<p>Use the <a href=""https://github.com/newren/git-filter-repo"" rel=""nofollow noreferrer"">new <code>git filter-repo</code></a>, which <a href=""https://stackoverflow.com/a/58251653/6309"">does replace the old <code>git filter-branch</code> or BFG</a>.</p>
<p>It has <a href=""https://htmlpreview.github.io/?https://github.com/newren/git-filter-repo/blob/docs/html/git-filter-repo.html#EXAMPLES"" rel=""nofollow noreferrer"">many usage examples</a>, including content-based filtering, in order for you to remote the <code>path/to/secret</code> file in past commits:</p>
<blockquote>
<p>To keep all files except these paths, just add <code>--invert-paths</code>:</p>
<pre><code>git filter-repo --path path/to/secret --invert-paths
</code></pre>
</blockquote>
<p>You can add <code>--dry-run</code> to test it before actually changing your repository.</p>
<p>Then <code>git push --force</code> (that does rewrite the history of your repository, so make sure to notify any other collaborator)</p>
<p>Since it must be done on a fresh clone:</p>
<ol>
<li>Don't touch anything to your current clone folder</li>
<li>Create a separate clone of the repository, where you do the filter repo</li>
<li>In that second clone, now cleaned (no more big file in its history), import your work from your first repo</li>
</ol>
<p>That is, for point 3:</p>
<pre class=""lang-sh prettyprint-override""><code>cd /path/to/second/clone
git --work-tree=/path/to/first/original/clone add .
git commit -m &quot;Import work from first clone&quot;
git push --force
</code></pre>
<p>Regarding git gilter-repo, see a complete example in &quot;<a href=""https://boopathi.blog/removing-sensitive-files-from-git/"" rel=""nofollow noreferrer"">Removing sensitive files from git</a> from <a href=""https://twitter.com/heisenbugger"" rel=""nofollow noreferrer"">Boopathi Rajaa</a>.</p>
<hr />
<p>You can store encrypted keys, but available for <a href=""https://docs.github.com/en/actions/reference/encrypted-secrets"" rel=""nofollow noreferrer"">GitHub Actions only</a>.</p>
<p>Outside of GitHub Actions, see <a href=""https://pythoneatstail.com/en/overview-all-articles/github-secret-keys-and-other-local-settings/"" rel=""nofollow noreferrer"">Github, secret keys and other local settings</a> from <a href=""https://pythoneatstail.com/en/about/"" rel=""nofollow noreferrer"">Paul Smits</a>.</p>
<p>For that you need a credential (PAT) <a href=""https://docs.github.com/en/developers/apps/scopes-for-oauth-apps"" rel=""nofollow noreferrer"">with workflow scope</a>.</p>
"
"66123785","<h2>Exchanged one Problem with Another</h2>
<blockquote>
<p>In my application I have a connection with keycloak for get an API key and a secure storage to save the user data.</p>
</blockquote>
<p>So, using KeyCloak to retrieve the API Key at runtime in order to not have it harcoded in the mobile app, just shifts the problem from securing the API key to securing the KeyCloak secret.</p>
<h2>Extracting Secrets from the Mobile App</h2>
<blockquote>
<p>How I can secure :</p>
<ul>
<li>the secret id need to connect to the keycloak</li>
<li>the key to access the secure store</li>
</ul>
</blockquote>
<p>The cruel truth is that you can't properly secure them, because any secret you ship in a mobile app release must be considered as belonging to the public domain, because it's on the client side, therefore anyone can spend the time he/she wants to reverse engineer the mobile app with static or dynamic analysis to extract it.</p>
<p>You can hide the secret in Natice C code with the use of JNI/NDK as I show in the article <a href=""https://blog.approov.io/how-to-extract-an-api-key-from-a-mobile-app-with-static-binary-analysis"" rel=""nofollow noreferrer"">How to Extract an API key from a Mobile App with Static Binary Analysis</a>:</p>
<blockquote>
<p>The range of open source tools available for reverse engineering is huge, and we really can't scratch the surface of this topic in this article, but instead we will focus in using the <a href=""https://github.com/MobSF/Mobile-Security-Framework-MobSF"" rel=""nofollow noreferrer"">Mobile Security Framework(MobSF)</a> to demonstrate how to reverse engineer the APK of our mobile app. MobSF is a collection of open source tools that present their results in an attractive dashboard, but the same tools used under the hood within MobSF and elsewhere can be used individually to achieve the same results.</p>
</blockquote>
<p>Now, with the secret hidden in the native C code it will be time consuming to extract it, but not impossible. So, if you cannot do it easily with statically reverse engineer it, then you can do it with a MitM attack as I show in the article <a href=""https://blog.approov.io/steal-that-api-key-with-a-man-in-the-middle-attack"" rel=""nofollow noreferrer"">Steal that Api Key with a Man in the Middle Attack</a>:</p>
<blockquote>
<p>In order to help to demonstrate how to steal an API key, I have built and released in Github the <a href=""https://github.com/approov/currency-converter-demo/tree/0.1.1"" rel=""nofollow noreferrer"">Currency Converter Demo</a> app for Android, which uses the same <a href=""https://developer.android.com/training/articles/perf-jni"" rel=""nofollow noreferrer"">JNI/NDK</a> technique we used in the earlier <a href=""https://github.com/approov/android-hide-secrets/blob/ed0217325d42be480a15c003fae9f201ee0f3f88/app/src/main/java/com/criticalblue/androidhidesecrets/MainActivity.java#L37-L41"" rel=""nofollow noreferrer"">Android Hide Secrets</a> app to <a href=""https://github.com/approov/android-hide-secrets/blob/ed0217325d42be480a15c003fae9f201ee0f3f88/app/src/main/cpp/api_key.h.example"" rel=""nofollow noreferrer"">hide the API key</a>.</p>
<p>So, in this article you will learn how to setup and run a MitM attack to intercept https traffic in a mobile device under your control, so that you can steal the API key. Finally, you will see at a high level how MitM attacks can be mitigated.</p>
</blockquote>
<p>Do you get the the twist? You can make it very hard to extract with static binary analysis, but then the attacker just needs to use a tool like mitmproxy to intercept the traffic and lookup the API key in the header of the request.</p>
<p>You can try to safeguard your mobile app against MitM attacks has I exemplify in my article <a href=""https://blog.approov.io/securing-https-with-certificate-pinning-on-android"" rel=""nofollow noreferrer"">Securing HTTPS with Certificate Pinning</a>:</p>
<blockquote>
<p>In order to demonstrate how to use certificate pinning for protecting the https traffic between your mobile app and your API server, we will use the same <a href=""https://github.com/approov/currency-converter-demo/tree/0.2.0"" rel=""nofollow noreferrer"">Currency Converter Demo</a> mobile app that I used in the previous article.</p>
<p>In this article we will learn what certificate pinning is, when to use it, how to implement it in an Android app, and how it can prevent a MitM attack.</p>
</blockquote>
<p>But, you need to be aware that you can also bypass pinning as I show in the next article <a href=""https://blog.approov.io/bypassing-certificate-pinning"" rel=""nofollow noreferrer"">Bypass Certificate Pinning</a>:</p>
<blockquote>
<p>To demonstrate how to bypass certificate pinning we will use the same Currency Converter Demo mobile app that was used in the previous article.</p>
<p>In this article you will learn how to repackage a mobile app in order to make it trust custom ssl certificates. This will allow us to bypass certificate pinning.</p>
</blockquote>
<p>Other alternative for the attacker is to use an instrumentation framework to hook into the code that returns the secret or API key from the keystore or from KeyCloak server. A popular instrumentation framework used for this type of attack is <a href=""https://www.frida.re/"" rel=""nofollow noreferrer"">Frida</a>:</p>
<blockquote>
<p>Inject your own scripts into black box processes. Hook any function, spy on crypto APIs or trace private application code, no source code needed. Edit, hit save, and instantly see the results. All without compilation steps or program restarts.</p>
</blockquote>
<p>So, the use of Frida to hookup in the code is made easier when the code is not obfuscated, because it's easy to find the function that does it by doing some search through the code with some guessable function names, or just resort to follow the code flow with the help of an IDE.</p>
<h3>Code Obfuscation and it's importance</h3>
<blockquote>
<p>It's possible to obfuscate the code but it's not a serious solution and this has a great impact on performance.</p>
</blockquote>
<p>Yes, you are right that code obfuscation will not hide the secret, only makes it hard to understand the logic flow.</p>
<p>Code obfuscation should still be in your list of security hardening your mobile app, and once used as <a href=""https://developer.android.com/studio/build/shrink-code"" rel=""nofollow noreferrer"">Google recommends</a>, by shrink code and resources, obfuscate, and optimize your app with R8, and then you will not have a slower app just because the code is obfuscated, but you will have one that is much harder to follow the logic through the code, thus an attacker poking around the code to find were to hook an instrumentation framework will have a much more consuming time task, to not call it frustrating sometimes.</p>
<h2>Securing the Secrets in the Mobile App</h2>
<blockquote>
<p>I read different article but I didn't find a way to properly secure those data. A simple revert engineering from the APK show the secret data.</p>
</blockquote>
<p>Yes, you cannot find one because that's not a trivial problem to solve, you can only make it hard, but not impossible.</p>
<h3>The Difference Between WHO and WHAT is Accessing the API Server</h3>
<p>Before I dive into the possible approaches to solve your problem I would like to first clear a misconception that usually I find among developers of any seniority, that is about the difference between <strong>who</strong> and <strong>what</strong> is accessing an API server.</p>
<p>I wrote a series of articles around API and Mobile security, and in the article <a href=""https://blog.approov.io/why-does-your-mobile-app-need-an-api-key#api-who-vs-what"" rel=""nofollow noreferrer"">Why Does Your Mobile App Need An Api Key?</a> you can read in detail the difference between <strong>who</strong> and <strong>what</strong> is accessing your API server, but I will extract here the main takes from it:</p>
<blockquote>
<p>The <strong>what</strong> is the thing making the request to the API server. Is it really a genuine instance of your mobile app, or is it a bot, an automated script or an attacker manually poking around your API server with a tool like Postman?</p>
</blockquote>
<blockquote>
<p>The <strong>who</strong> is the user of the mobile app that we can authenticate, authorize and identify in several ways, like using OpenID Connect or OAUTH2 flows.</p>
</blockquote>
<p>So think about the <strong>who</strong> as the user your API server will be able to Authenticate and Authorize access to the data, and think about the <strong>what</strong> as the software making that request in behalf of the user.</p>
<p>Now that you are better informed about the difference between them you can make better informed decisions in terms of security and trade-offs when deciding waht approaches to take for your use case.</p>
<h3>A Possible Naive Approach</h3>
<ul>
<li>Hide your API Key or if you prefer the KeyCloak secret in Native C Code as I show in the article I linked above that references this <a href=""https://github.com/approov/android-hide-secrets"" rel=""nofollow noreferrer"">Github repo</a>. This makes static reverse engineer the secret harder.</li>
<li>Shrink code and resources, obfuscate, and optimize your app as per Google instructions.This makes it hard to find the code were to hook Frida.</li>
<li>Implement certificate pinning. This makes it harder to perform a MitM attack.</li>
</ul>
<p>I call it naive approach, because has I shown in my series of articles I linked it can be bypassed, but it raises the bar for the skill set and time necessary to do it.</p>
<h3>A Possible Better Solution</h3>
<p>So, your main goal seems to be to protect the API key, that you need to use as a way to identify your mobile app with the backend API server, aka to lock down the backend API server with the genuine and untampered versions of your mobile app, that will allow for the server to only answer to requests from the same binary that you uploaded to Google Play store, then you may want to take a look into the Mobile App Attestation concept, and to for that I recommend you to read <a href=""https://stackoverflow.com/a/60605789/6454622"">this answer</a> I gave to the question <em>How to secure an API REST for mobile app?</em>, especially the sections <em>Securing the API Server</em> and <em>A Possible Better Solution</em>.</p>
<p>In a nutshell the role of a Mobile App Attestation solution is to guarantee at run-time that your mobile app was not tampered with, is not running in a rooted device, not being instrumented by a framework like xPosed or Frida, not being MitM attacked, and this is achieved by running an SDK in the background. The service running in the cloud will challenge the app, and based on the responses it will attest the integrity of the mobile app and device is running on, thus the SDK will never be responsible for any decisions.</p>
<h2>Do You Want To Go The Extra Mile?</h2>
<p>In any response to a security question I always like to reference the excellent work from the OWASP foundation.</p>
<h3>For APIS</h3>
<p><a href=""https://github.com/OWASP/API-Security"" rel=""nofollow noreferrer"">OWASP API Security Top 10</a></p>
<blockquote>
<p>The OWASP API Security Project seeks to provide value to software developers and security assessors by underscoring the potential risks in insecure APIs, and illustrating how these risks may be mitigated. In order to facilitate this goal, the OWASP API Security Project will create and maintain a Top 10 API Security Risks document, as well as a documentation portal for best practices when creating or assessing APIs.</p>
</blockquote>
<h3>For Mobile Apps</h3>
<p><a href=""https://www.owasp.org/index.php/OWASP_Mobile_Security_Project#Top_Ten_Mobile_Risks"" rel=""nofollow noreferrer"">OWASP Mobile Security Project - Top 10 risks</a></p>
<blockquote>
<p>The OWASP Mobile Security Project is a centralized resource intended to give developers and security teams the resources they need to build and maintain secure mobile applications. Through the project, our goal is to classify mobile security risks and provide developmental controls to reduce their impact or likelihood of exploitation.</p>
</blockquote>
<p><a href=""https://github.com/OWASP/owasp-mstg"" rel=""nofollow noreferrer"">OWASP - Mobile Security Testing Guide</a>:</p>
<blockquote>
<p>The Mobile Security Testing Guide (MSTG) is a comprehensive manual for mobile app security development, testing and reverse engineering.</p>
</blockquote>
"
"66219417","<p>You are not using the environment variable correctly.</p>
<p>Firstly, you could <strong>set</strong> the environment variable in <code>settings.py</code> like below, rather than <strong>retrieve</strong> it in this file.</p>
<pre><code>SECRET_KEY = '12345'
</code></pre>
<p>You could retrieve the variable in your code like what you displayed:</p>
<pre><code>secret_key = os.environ['SECRET_KEY']
</code></pre>
<p>Considering you don't want to expose your <code>SECRET_KEY</code> value on GitHub, you could set a temp value for invoking, which is required. After deploy, the value on portal App Settings would cover the value.</p>
"
"66256791","<p>You can set environment variables on Heroku, see:</p>
<p><a href=""https://i.stack.imgur.com/Yer1l.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Yer1l.png"" alt=""Environment Variables on Heroku"" /></a></p>
<hr />
<p>Reactjs is typically a client side framework. You are usually not doing SSR. Are you certain you are doing SSR? Because if are serving the static html,js,css files people already have access to your firebase config by looking at the browser source.</p>
"
"66449179","<p>That ID in the <code>gtag</code> include just identifies your Analytics project/property on Google's servers. You need to know that ID to report analytics events for that project/property, but on its own it is not enough to then also access somebody else's or aggregated analytics data.</p>
"
"67151768","<p>There are a couple of ways one can achieve this.</p>
<p>I believe the most standard one is to have an <code>.example</code> file in your repo, which will then be changed for each user of the project. So you'll just have an <code>XYZ.env.example</code> and you'll locally &quot;implement&quot; <code>env.example</code> (by this I mean that you'll take <code>.env.example</code> and make a valid <code>.env</code> config file). With this approach, you'll have to track <code>XYZ.env.example</code> and <strong>ignore</strong> <code>XYZ.env</code>.</p>
<hr />
<p>Another way is to use <code>git update-index --[no]-skip-worktree</code>.</p>
<p>From the documentation:</p>
<blockquote>
<p>Skip-worktree bit can be defined in one (long) sentence: When reading an entry, if it is marked as skip-worktree, then Git pretends its working directory version is up to date and read the index version instead.</p>
<p>To elaborate, &quot;reading&quot; means checking for file existence, reading file attributes or file content. The working directory version may be present or absent. If present, its content may match against the index version or
not. Writing is not affected by this bit, content safety is still first priority. Note that Git can update working directory file, that is marked skip-worktree, if it is safe to do so (i.e. working directory version
matches index version)</p>
</blockquote>
<p>This means that you can keep your <strong>initial</strong> <code>XYZ.env</code> file the way one should see it without production/test/debug values and then you can <em>freely</em> change it without git bugging you for these changes.</p>
<p>You <strong>can</strong> update the file if you need to and you <strong>can</strong> push new changes. Simply unmark the file with <code>git update-index --no-skip-worktree</code>.</p>
<p>Keep in mind that if remote introduces changes to <code>.env</code>, then you`ll conflict locally (which is a good thing).</p>
<p>One last thing - this command works only locally. <strong>Every</strong> contributor (if he/she wishes to) must do this on their local clone.</p>
"
"67962767","<p>It is possible to have two copies of the same repository like this, but in practice it's very hard to do because the histories will need to be independent, meaning things like merges and conflict resolution will quickly become difficult.</p>
<p>Since your problem is a file with secrets, the best practice is to create a template file that contains everything that's reusable and public (that is, everything but the secrets) and then use a script to generate the actual Python file you want to use from the template and the secrets.  Both the file with the secrets and the generated file should be ignored.  You can run this script as part of your normal deployment or project bootstrap process if you like.</p>
<p>The reason this is a good idea is because storing secrets in your repository is unwise.  It often happens for various reasons that source code leaks.  This can happen in many ways, including accidentally serving your <code>.git</code> directory over HTTP.  If your repository doesn't contain anything private (other than your source code), then the risk of compromise is much lower.</p>
<p>If you're deploying a production service, then it's best to store secrets in some specialized secret store, such as Vault or your CI system's store (e.g., GitHub Actions's secret store) and pass them in via the environment.</p>
"
"67998780","<p>You can use your <code>secrets.dart</code> file while being ignored in the source control.</p>
<h3>Here are the steps</h3>
<ol>
<li>In your local machine, encode the content of your <code>secrets.dart</code> using the <strong>base64</strong> command:
<pre class=""lang-sh prettyprint-override""><code>  base64 lib/path/to/secrets.dart
</code></pre>
</li>
<li>Copy and paste the output into your GitHub secrets, name it <code>$SECRETS_FILE_CONTENT</code> or whatever you want.</li>
<li>Add this CI step into your <em>yaml</em> script just before the <code>flutter pub get</code> step.
<pre class=""lang-yaml prettyprint-override""><code>  # other stuff ...
  - run: echo $SECRETS_FILE_CONTENT | base64 -d &gt; lib/path/to/secrets.dart
    env:
      SECRETS_FILE_CONTENT: ${{ secrets.SECRETS_FILE_CONTENT }}
  - run: flutter pub get
  - run: flutter pub run build_runner build --delete-conflicting-outputs
  - run: flutter build web --release
  # other stuff ...
</code></pre>
</li>
</ol>
<p>To add the secret in the GitHub user interface, follow these steps:</p>
<p><a href=""https://i.stack.imgur.com/1nUv4.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/1nUv4.png"" alt=""Click on the repository's Settings tab, click on Secrets, click &quot;New repository secret&quot;, DO NOT USE &quot;environment secrets&quot; because it does not work"" /></a></p>
<p><a href=""https://i.stack.imgur.com/phb1U.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/phb1U.png"" alt=""Fill in the name of the variable e.g. SECRETS_FILE_CONTENT and its value e.g. the base-64 encoded file contents"" /></a></p>
<p>Your secret should appear in the lower &quot;repository secrets&quot; half of the UI, it should NOT appear in the &quot;Environment secrets&quot; as those do not work with a simple <code>${{ secrets.name_of_variable }}</code>.</p>
<p><a href=""https://i.stack.imgur.com/6nuqh.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/6nuqh.png"" alt=""The SECRETS_FILE_CONTENT variable name should now appear in the second box at the bottom"" /></a></p>
<p>To provide more context, here's what the &quot;actions&quot; file, e.g. .github/workflows/ci.yml in your repository, should look like:</p>
<pre><code>name: CI

on:
  push:
    branches: [ main, dev ]
  pull_request:
    branches: [ main ]

  # Allows to run this workflow manually from the Actions tab
  workflow_dispatch:
  
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Decode base64 secrets
        run: echo $SECRETS_FILE_CONTENTS | base64 -d &gt; lib/path/to/secrets.dart
        env:
          SECRETS_FILE_CONTENTS: ${{ secrets.SECRETS_FILE_CONTENTS }}
      # … put your steps here
        run: flutter pub get
</code></pre>
<h4>Edit</h4>
<p>This is also the same process when hiding <code>google-services.json</code> when people work with firebase. Or with signing keys (<code>key.jks</code> or <code>key.keystore</code>).</p>
"
"68063480","<p>Don't push your <code>settings.py</code> into a repository, because it has some important information about your application such as <code>SECRET_KEY</code> OR <code>DATABASE</code>.</p>
<p>It’s important to keep your application credentials like <strong>API Keys</strong>, <strong>Amazon S3</strong>, <strong>email</strong> parameters, <strong>database</strong> parameters safe, specially if it’s an open source repository.</p>
<p>You need to make sure that these kind of information will be stored in a secure place and don't push it into a public repository.</p>
<p>There are more files that you shouldn't push into your repository. check out this <a href=""https://djangowaves.com/tips-tricks/gitignore-for-a-django-project/"" rel=""nofollow noreferrer"">link</a> to know more about <code>.gitignore</code> files in Django projects. also there is a <a href=""https://www.gitignore.io/"" rel=""nofollow noreferrer"">website</a> that you can create your <code>.gitignore</code> files automatically.</p>
<p>Now if you want to know more about how to store these kind of informations you can use <code>environment variables</code> and also there is a package called <a href=""https://simpleisbetterthancomplex.com/2015/11/26/package-of-the-week-python-decouple.html"" rel=""nofollow noreferrer"">python-decouple</a> that you can use it for storing your important informations.</p>
"
"68105181","<p>From the structure of the file tree, its clear that .env file is placed in the root folder of the project. When checking the error message, its visible that whoever is searching for .env file is checking at the same place as settings.py.</p>
<p>So, the short answer is if you are using <strong>django-environ</strong> to keep secret-key outside, place <strong>.env</strong> file together with <strong>settings.py</strong> in the same directory.</p>
<p>For a bit more elaborated content, you can refer to this <a href=""https://alicecampkin.medium.com/how-to-set-up-environment-variables-in-django-f3c4db78c55f"" rel=""nofollow noreferrer"">link</a>. I felt it is suitable for newbies.</p>
"
"68184764","<p>As you said, secrets are not encrypted but only base64 encoded. Where secrets really add value is that they allow you to keep your passwords, keys, tokens out of  your codebase/git repos.  If you push your code to Github, you will not be pushing your secrets there. For this reason they are called secrets and add a layer of safety.</p>
<p>However, if someone gets access to your cluster, secrets will be mere plaintext to them.</p>
<p>The recommended way to store the secrets is to use a vault.</p>
<p><a href=""https://www.hashicorp.com/blog/injecting-vault-secrets-into-kubernetes-pods-via-a-sidecar"" rel=""nofollow noreferrer"">https://www.hashicorp.com/blog/injecting-vault-secrets-into-kubernetes-pods-via-a-sidecar</a></p>
"
"68461883","<p>First of all, you must also add the folder in where the <em>Constrant.swift</em> is located to <code>.gitignore</code>, and not only the file name:</p>
<pre><code>nasaAPI/Constrant.swift
</code></pre>
<p>Then if the file is already tracked (pushed on remote repository on a previous commit), you must <em>untrack</em> this file with following command:</p>
<pre><code>git rm --cache nasaAPU/Constrant.swift
</code></pre>
<p>An other way to ignore this file is to write <em>two</em> stars in front of it. Then you ignore every file with the name <em>Constrant.swift</em> in that repository. So you doesn‘t need to add the folder name where <em>Constrant.swift</em> is located before. But be careful with that:</p>
<pre><code>**/Constrant.swift
</code></pre>
<p>After that, you can add (<code>git add .</code>) your changes (edited <code>.gitignore</code> and untrack the <em>Constrant.swift</em> file) and commit (<code>git commit -m &quot;No longer tracking Constrant.swift to include in gitignore&quot;</code>) them.</p>
<p>Now, after <code>git push</code>, <em>Constrant.swift</em> isn‘t longer available on the GitHub remote repository.</p>
"
"69187250","<p><strong>ASAP:</strong> The first thing I would do is make a copy of your local branch for sanity sake, reset to the commit before the bad commit, and then force push out your branch. This will minimize the chances of someone else seeing your password file, and you can fix up your branch afterwards. Here are the commands you need (assuming the bad commit is on a branch called <code>my-branch</code>:</p>
<pre><code>git checkout my-branch # just in case it isn't checked out already
git status # make sure your status is clean, if not, stash or commit or delete the changes
git branch my-branch-bad # make a copy of it
git reset &lt;commit-id-before-bad-commit&gt; # put branch back to before the bad commit
git push --force-with-lease # push out the branch to AzDev
</code></pre>
<p>At this point the password file is no longer (easily) available on AzDev. Now let's figure out how best to recover your branch, if needed.</p>
<p><strong>If the bad commit was your latest commit</strong>, then you could be done, since you mentioned you were willing to lose that commit completely. Or, note that I purposefully suggested <code>git reset</code> without specifying a type, such as <code>--soft</code>, <code>--mixed</code>, or <code>--hard</code>, and the default is <code>--mixed</code>. This means that all of your changes will still be in your working folder. If you wish to recreate the commit, stage all of the pending files except the password file and redo the commit. Then you can push that commit out and your branch will look like how you wanted it to be in the first place.</p>
<p><strong>If the bad commit was not your latest commit,</strong> and you had other commits you wanted to keep after the commit you reset to, then reset your branch back to where it was before (by using the copied branch), and then interactive rebase to drop the bad commit:</p>
<pre><code>git reset --hard my-branch-bad # put branch back to how it was with the bad commit
git rebase -i @{u} # start an interactive rebase from the tip of the remote branch
</code></pre>
<p>The cryptic <code>@{u}</code> is shorthand for your upstream branch, which we know is currently the first commit before the bad commit because that's what we last pushed out in the first step. When the interactive rebase comes up, it will display all of the commits after what you pushed out, and the first one will be the commit you wish to drop. You can change the <code>pick</code> in the first line to either <code>drop</code> or <code>d</code>, or you can even just delete the first line, and then save and exit the file. Now continue the rebase with <code>git rebase --continue</code>. As long as the rest of the first commit you just dropped didn't have something that later commits needed, then you won't have any conflicts and the rebase will continue and finish. Your end result is the original branch except with the one bad commit omitted. You can now push out your latest version of the branch. You can also delete your copy of the bad branch since you no longer need it: <code>git branch -D my-branch-bad</code>.</p>
<p><strong>Now your branch is fixed up and you need to determine if the password file is still accessible.</strong> Since it hadn't been merged yet anywhere, I believe the answer depends on whether or not you had a PR setup on your branch yet. If you did have a PR on your branch, then unfortunately AFAIK the PR history will always contain that file in the specific Update. If there wasn't a PR on the branch, then you may be safe (enough) to not have to continue worrying about it. You (and anyone) can probably still see the commit in AzDev by directly navigating to the commit ID url, however, I can't think of any reason for someone to know that ID other than you, at this point. However, anyone who fetched during the time the bad commit was on your remote branch, would have a copy of the commit in their local copy of the repo, and could see the file if they choose to look at it.</p>
<p><strong>All that being said, if the repo is public, I wouldn't risk it</strong>, and your safest approach would be to change <em>all</em> of your passwords found in that file. It the repo is private, depending on who might possibly have access to the repo, I would at least change the passwords that you wouldn't want others in your organization to know.</p>
"
"69263740","<p>You can create a properties file, put in under your app's folder and add it to .gitignore:</p>
<p>Example of content of a properties file called <strong>passwords.properties</strong>:</p>
<pre><code>password1=123456
password2=qwerty
</code></pre>
<p>Under the plugin declaration in your build.gradle file, import the properties file and load it into a Properties object.</p>
<pre><code>def passwordsPropertiesFile = rootProject.file(&quot;app/passwords.properties&quot;)
def passwordsProperties = new Properties()
passwordsProperties.load(new FileInputStream(passwordsPropertiesFile))
</code></pre>
<p>And in order to get a value use it inside your gradle file use:</p>
<pre><code>passwordsProperties['password1']
</code></pre>
<p>If you need the values inside your application code, you can add the values to the BuildConfig either under the defaultConfig:</p>
<pre><code>defaultConfig {
    applicationId &quot;some.app.id&quot;
    minSdkVersion 21
    targetSdkVersion 30
    ...

    buildConfigField &quot;String&quot;, &quot;PASSWORD1&quot;, passwordsProperties['password1']

}
</code></pre>
<p>Or add it for a specific build type by setting the BuildConfig variable under buildTypes section:</p>
<pre><code>buildTypes {
    debug {
        buildConfigField &quot;String&quot;, &quot;PASSWORD1&quot;, passwordsProperties['debug_password1']
    }
    
    prod {
        buildConfigField &quot;String&quot;, &quot;PASSWORD1&quot;, passwordsProperties['prod_password1']
    }
}
</code></pre>
<p>To use the value in your application code use:</p>
<pre><code>BuildConfig.PASSWORD1
</code></pre>
"
"69520859","<p>The safest way to avoid making a mistake is to remove <code>or 'hard to guess string'</code>, then ensure that the <code>.env</code> in your production environment has the production secret key, and the <code>.env</code> in your develoment environment uses a separate secret. You'll want add <code>.env</code> to your <code>.gitignore</code> so that it doesn't accidentally get checked in.</p>
<p>If you haven't gotten there yet, Grinberg adds <code>python_dotenv</code> in chapter 15.</p>
"
"69840875","<p>If you are using Javascript</p>
<h2>1. Add dotenv lib in your project (npm i dotenv or yarn add dotenv)</h2>
<h2>2. Import to your main file</h2>
<pre><code>require('dotenv').config();
or
import 'dotenv/config';
</code></pre>
<h2>3. Put the variables in a file named &quot;.env&quot; in the root of your project.</h2>
<p>Inside this .env file they have to be in the format: KEY=value</p>
<pre><code>...
SECRET=123456abcdef
...
</code></pre>
<h2>4. Then to use in your project, you can use: process.env.KEY</h2>
<pre><code>...
const token = sign({email: user.email},
      process.env.SECRET,
      {subject: user.id, expiresIn: 86400}
    );
...
</code></pre>
<h2>5. 2. Add .env to .gitignore</h2>
<pre><code>//.gitignore
.env
</code></pre>
"
"69959801","<p>If you add those two files in <code>.gitignore</code> (and that is <a href=""https://newbedev.com/should-i-add-the-google-services-json-from-firebase-to-my-repository"" rel=""nofollow noreferrer"">debatable for <code>google-services.json</code></a>), you are making clear, as <a href=""https://stackoverflow.com/a/44937513/6309"">explained here</a> that others who build your code that they should be setting up their own Firebase project to host its configuration and data (because your project simply won't build with that file missing)</p>
<p>Other approaches are explained in <a href=""https://tracker.moodle.org/browse/MOBILE-3518"" rel=""nofollow noreferrer"">this issue</a></p>
<ul>
<li><p>Leave those files there (with fake data), as they are.<br />
If you want to override them in local, you can do so and then use this command to ignore the changes:</p>
<pre><code>  git update-index --assume-unchanged GoogleService-Info.plist
</code></pre>
</li>
<li><p>Convert those files to &quot;example&quot; files, and add the original ones to gitignore.<br />
A setup task should convert the example files into real files if the real ones don't exist.</p>
</li>
</ul>
"
"70078474","<p>A solution that immediately comes to my mind would be rather than upload your project to the server, you could pull it down onto the server via git.</p>
<p>I'm assuming you are using GitHub to host your code, in which case you can create a read only Deploy Key (see <strong><a href=""https://docs.github.com/en/developers/overview/managing-deploy-keys#deploy-keys"" rel=""nofollow noreferrer"">https://docs.github.com/en/developers/overview/managing-deploy-keys#deploy-keys</a></strong>) &amp; use that to authenticate your server with your GitHub Repo.</p>
<p>You could then create a <code>.env</code> file in your project folder on the server &amp; it won't be overwritten because it's in your .gitignore file.</p>
"
"67297031","<p>I am going forward with the most straightforward approach I could find.</p>
<p>I'll be storing sensitive data in local.properties file, which is not checked into version control. This works for my project as currently I am the sole admin. If more people join, I'll need to share the file's contents manually with them, but that's okay with me for now.</p>
<p>This solution won't work for teams with more collaborators, or where such roles might need to be assigned/changed dynamically.</p>
"
"67078477","<p>Okay, so the solution is way simpler.</p>
<p>According to the <a href=""https://docs.docker.com/compose/environment-variables/"" rel=""nofollow noreferrer"">documentation</a> docker-compose will utilize properties from <code>.env</code> file located in the same directory as <code>docker-compose.yml</code> is located in.</p>
<p><strong>.env:</strong></p>
<pre><code>LOKI_USER_ID=XXX
LOKI_API_KEY=YYY
</code></pre>
<p><strong>docker-compose.yml:</strong></p>
<pre><code>version: '3'

x-logging: &amp;logging
  logging:
    driver: loki
    options:
      loki-url: &quot;https://${LOKI_USER_ID}:${LOKI_API_KEY}@logs-prod-us-central.grafana.net/loki/api/v1/push&quot;

# ...
</code></pre>
<p>And simply launch with</p>
<pre><code>docker-compose up
</code></pre>
"
"66492503","<h2>TL/DR:  You don't.</h2>
<h2>Long answer:</h2>
<p>Any key that is distributed with the app can be read by the app for it to use it.  The app therefore has what it needs to read the key, even if it is encrypted or obfuscated.  An attacker can use the same technique that the app would use, to obtain the key.</p>
<p>Equally, fetching the key form an external source does not protect it.  Again an attacker can use the same channel to obtain a copy of the key.</p>
<p>Besides attacking the channel by which the app obtains the key (from an encrypted store inside the package, or from an external source), an attacker can also obtain it from the app's memory or by intercepting network transmissions.</p>
<h1>The only secure solution is to never have a copy of the key on the end user device.</h1>
<p>The key should be kept on a <strong>well secured server</strong> which will act as a middle-man between the user's device and the end service.  Any requests by the client device to the end service needs to be routed via this server.</p>
<p>The server, having the &quot;global project keys&quot;, should make the requests to the end service on the behalf of the end user, and return the result (and never any keys) to the client.  For the client to use this server, a per-user authenticated session must be used.  The server must validate this session for every request prior to forwarding the request on to the end service.</p>
<h2>Summary:</h2>
<p>Use a secure server between the client and the end service to make requests on behalf of clients using the global key.</p>
<p>EDIT:
Side note:  There is a distinction that needs to be made between per-user keys and keys that are project-wide.  It is acceptable to keep keys that are specific to one individual person on that user's device.</p>
"
"64533059","<blockquote>
<p>I see, so I would need to provide the values to them somehow, and have them configure it manually?</p>
</blockquote>
<p>Yes, but if those values are sensitive, there should not be stored in the Git repository in the first place.<br />
Which means your README (in that git repository) should include instructions in order for a user to:</p>
<ul>
<li>fetch those values</li>
<li>build the env file</li>
</ul>
"
"64519663","<p>Generally the way that folks pass secrets to their code is through the environment, which is considered a best practice.  Here's why:</p>
<ul>
<li>Secrets in the environment are never written to disk, so there's much less accidental risk of discovery or disclosure.</li>
<li>Secrets in the environment are only visible to other processes with the same user ID, which is helpful when deploying to hardware.</li>
</ul>
<p>If your credentials are small enough, you can use the secret store or environment store of whatever provider you're using.  All major CI providers have this and I expect most major hosting sites do as well; I know Heroku does.  Things like SSH keys which <em>must</em> be files can be written to disk from the environment, ideally into a temporary directory which is cleaned up.</p>
<p>If you're deploying to your own infrastructure, generally you'll have some encrypted secret store for this purpose.  Vault is a common one.</p>
<p>If you need credentials that are for development, you can structure your code such that there's a safe default (like the hard-coded phrase <code>secret</code>) for development use if no variable is set, or you can provide a set of fallbacks in development and test code.  Some projects also use <code>.env</code> files, although this requires additional code which some people don't want to install.</p>
<p>If you have huge credentials that you cannot store in your secret store, you can <a href=""https://docs.github.com/en/free-pro-team@latest/actions/reference/encrypted-secrets"" rel=""nofollow noreferrer"">encrypt them and store the passphrase in the secret store</a>.</p>
"
"63287086","<p>Its not the Heroku issue, any platform will need files required in the app to build.</p>
<p>Also, sensitive data (keys file) must not be pushed to Git. You will need to make some changes in your app where ever you are requiring keys file, read all those properties from environment variable like process.env.{key_name}, and in Heroku set this sensitive property in the environment variable.</p>
<p>Check this link</p>
<p><a href=""https://devcenter.heroku.com/articles/config-vars"" rel=""nofollow noreferrer"">https://devcenter.heroku.com/articles/config-vars</a></p>
<p>Hope you got the idea.</p>
"
"63173572","<p>Just add the file you want to ignore, like:</p>
<pre><code>secrets/passwords.txt
</code></pre>
<p>Note, that in order to explicitly negate ignoring (which should not be necessary in your case), you can use <code>!</code> prefix, like:</p>
<pre><code>!secrets/passwords.txt.template  //! will negate the instruction
</code></pre>
"
"63083003","<p>GitHub, like other CI providers, redacts most secrets from the logs.  It considers a variety of formats and tries to scrub them.  However, in general, you should be careful to avoid printing them to the logs because no system is foolproof and not every possible encoding can be considered.</p>
<p>If you're worried about forked repositories trying to access your secrets, <a href=""https://docs.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets#using-encrypted-secrets-in-a-workflow"" rel=""noreferrer"">they can't</a>; that's specifically not allowed for the reason you describe.  So if someone opens a PR against your repository, they won't be able to access the secrets unless the branch is in your repository (in which case, don't grant that person write access to your repo).  It's presumed that you'll perform basic code review to catch any malicious code before merging, so a bad actor won't be able to run any code with the secrets for your repository.</p>
<p>In general, though, using environment variables as a way to pass secrets to programs is a best practice, assuming the running system and programs are trusted.  Other users on the system cannot see the environment, and in a CI system the system and programs are assumed to be trusted.</p>
"
"62947718","<p>You have multiple ways to do it. Below are some of them.</p>
<ol>
<li>Store your .env file to S3 with proper permission with encryption at rest. Every time you deploy the app from SCM (Source Code Management) your deployment script will pull the .env from S3 to the app working directory. But to do so, your instance must have a role with proper policy bind to it that enables access to the S3 bucket where .env is stored.</li>
<li>Utilize AWS Secret Manager. This way you can fetch the variables directly using AWS SDK from your app, without needing the .env file, what it does, it that AWS Secret Manager store your variables (replacing the .env file) and by using AWS SDK within the app, you can retrieve those values and can directly integrate with the app logic. <a href=""https://aws.amazon.com/blogs/aws/aws-secrets-manager-store-distribute-and-rotate-credentials-securely/"" rel=""nofollow noreferrer"">https://aws.amazon.com/blogs/aws/aws-secrets-manager-store-distribute-and-rotate-credentials-securely/</a></li>
</ol>
"
"62712369","<p>No.</p>
<p>Preferred way is to have a file called <code>.env.sample</code> This will contain all the keys with random or no values in it. Any developer who clones the repo, will get to know the env_vars that are needed to run/build the project.</p>
<p>Within the teams, have a secrets sharing mechanism. There are lots of tools available to solve this.</p>
<p>First time after cloning the repo, the developers needs to run <code>cp .env.sample .env</code> and copy the values from the secret manager.</p>
<p>Make sure to add <code>.env</code> to <code>.gitignore</code> so no-one accidently pushes the <code>.env</code> containing secrets to the repo.</p>
"
"61361734","<p>After some more research I stumbled upon a support-forum entry on gitlab.com, which exactly describes my situation (unfortunately it got deleted in the meanwhile) and it got solved by the same approach I was trying to use, namely this:</p>
<pre><code>...
script:
- cp $DOTENV_STAGE $CI_PROJECT_DIR/.env
...
</code></pre>
<p>in my .gitlab-ci.yml</p>
<p>The part I was actually missing was adjusting my <code>.dockerignore</code>-File accordingly (removing <code>.env</code> from it) and then removing the line</p>
<pre><code>COPY .env ./.env
</code></pre>
<p>from my <code>Dockerfile</code></p>
<p><strong>An alternative approach</strong> I thought about after <a href=""https://stackoverflow.com/a/61357756/5168701"">joyarjo's answer</a> could be to use a <a href=""https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/"" rel=""nofollow noreferrer"">ConfigMap for Kubernetes</a>. But I didn't try it yet</p>
"
"61335226","<p>This problem occurred because of a misunderstanding of mine, which I thought the secret values should show up in the logs if they are passed to the action correctly.</p>
<p>I am combining the answers of <a href=""https://stackoverflow.com/a/61313152/4919731"">Ben Winding</a> and <a href=""https://stackoverflow.com/users/8705432/bk2204"">bk2204 </a> to make it clear.</p>
<p><strong>Secret values are scrubbed in action logs</strong>. Don't expect to see the actual values in the action logs. Getting the scrubbed text means the value has been passed to the action. you can use the value within the script but you cant see them in the logs. Check <a href=""https://stackoverflow.com/a/61313152/4919731"">Ben's Answer</a> for How you can see the values, but it is not recommended.</p>
"
"60645658","<p>Git doesn't provide a way to ignore changes to tracked files.  The <a href=""https://git-scm.com/docs/git-update-index#_notes"" rel=""nofollow noreferrer"">documentation</a> specifically recommends the solution that answers to other questions have provided.  There are techniques people use to try to trick Git, but that same documentation passage explains why those don't work and why the right solution is to use separate files.</p>
"
"60360317","<p>Simple answer is <strong>YES</strong>, .env is used to store keys and secrets. It is not pushed to your repo i.e. github or bitbucket or anywhere you store your code. In that way it is not exposed.</p>

<p>Here are the tutorial links for correct usage: </p>

<ul>
<li><a href=""https://stackabuse.com/managing-environment-variables-in-node-js-with-dotenv/"" rel=""noreferrer"">managing-environment-variables-in-node-js-with-dotenv</a> </li>
<li><a href=""https://codeburst.io/how-secure-is-your-environment-file-in-node-js-7c4d2ed0d15a"" rel=""noreferrer"">how-secure-is-your-environment-file-in-node-js</a></li>
</ul>
"
"59506016","<p>You don't include the token in your package, instead you would read it from your environment. You can then read those variables in your package.</p>

<p>For example, if you export the variables as environment variables, you can read them via <a href=""https://nodejs.org/dist/latest-v8.x/docs/api/process.html#process_process_env"" rel=""nofollow noreferrer""><code>procss.env</code></a>.</p>

<pre class=""lang-js prettyprint-override""><code>var clientId = process.env.MY_CLIENT_ID;
var clientSecret = process.env.MY_CLIENT_SECRET;

console.log(clientId, clientSecret);
</code></pre>

<p>Then in your shell or dot files that init your shell, you can simple export the values.</p>

<pre class=""lang-sh prettyprint-override""><code>export MY_CLIENT_ID='myid'
export MY_CLIENT_SECRET='mysecret'
</code></pre>

<p>For use with a continuous integration service, there should be a way to create secret or hidden environment variables (<a href=""https://docs.travis-ci.com/user/environment-variables/"" rel=""nofollow noreferrer"">for example with Travis CI</a>).</p>

<hr>

<p>Alternately, if you need to use those same credentials, and you don't want people to be able to access those credentials, you would have to setup a server that accepts requests from clients and performs those actions using your credentials.</p>
"
"59065423","<p>If you want to totally ignore the files, you should add them to your <a href=""https://git-scm.com/docs/gitignore"" rel=""nofollow noreferrer""><code>.gitignore</code></a>.</p>

<p>If you wish to ""hide"" only the credentials, that depends on your deployment and your build process. One way is using a vault (again, depending on your system).</p>

<p>Another option would be reading credentials from some environment variable, that'll be set in a secured manner somewhere else.</p>
"
"58783284","<p>You're handling secrets correctly by not putting those secrets into your repository unencrypted.  To fix this issue, what I usually do is to add a second check in settings.py</p>

<pre><code>if os.path.exists('secrets.json'):
   # read secrets from json file
else:
    SECRET_KEY = os.environ['DJANGO_SECRET_KEY']
</code></pre>

<p>And in heroku, you would set an environment variable with that name with <a href=""https://devcenter.heroku.com/articles/config-vars#managing-config-vars"" rel=""nofollow noreferrer"">the value that you want using config vars</a>.  This way your secrets are available to heroku and to local, but not put in your repository.  </p>
"
"58470050","<p>Instead of BFG, try the <a href=""https://github.com/newren/git-filter-repo"" rel=""nofollow noreferrer"">new <code>git filter-repo</code></a>, which <a href=""https://stackoverflow.com/a/58251653/6309"">will replace the old <code>git filter-branch</code> or BFG</a></p>
<p>Example:</p>
<blockquote>
<p>To replace the text 'password' with 'p455w0rd':</p>
<pre><code>git filter-repo --replace-text &lt;(echo &quot;password==&gt;p455w0rd&quot;)
</code></pre>
</blockquote>
<p>But the end result will be the same: a new commits history, not just for your current branch, but for <em>all</em> branches (where your password was found)<br />
That means a <code>git push --all --force</code>, to override the history of the remote repository.</p>
<p>If the password was added only in the PR branch then removed, filter only that PR branch instead of everything, then rebase that new history on top of <code>upstream/master</code></p>
<p>Before password removal:</p>
<pre><code>        u--u--u     (upstream/master)
       /
x--x--x             (master)
       \
        pr--pr--pr  (pull-request branch)
</code></pre>
<p>After password removal, using <code>--refs pr</code> (replace 'pr' by the name of your pull-request branch: git filter-repo --replace-text &lt;(echo &quot;password==&gt;p455w0rd&quot;) --refs pr)</p>
<pre><code>        u--u--u     (upstream/master)
       /
x--x--X             (master)
      |\
      | pr'--pr'--pr'  (new pull-request branch)
       \
        pr--pr--pr  (old pull-request branch)
</code></pre>
<p>You need to rebase that new branch on top of upstream/master, assuming that upstream is the original repository to where you are making a PR.</p>
<pre><code>git fetch upstream
git switch pr
git rebase upstream/master
</code></pre>
<p>Then the PR would only include your commits, not every commits since the beginning of time.</p>
"
"58022358","<p>If your source code is open source, you probably should NOT check it in.  The issue is not so much safety as it is confusion from others who use your source code.  Every instance of your app should be running in a different project so they don't overwrite each others' data.</p>

<p>If your source is NOT open source, and all of your coworkers are using the same project to collaborate, then it's not a problem.  But everyone sharing a project is not a great idea since all of their changes to the project might still conflict with each other.</p>

<p>In general, it's better not to share your project configuration unless everyone needs to use it.</p>
"
"57889807","<p>You can use git built-in git-filter-branch, for more refer to <a href=""https://stackoverflow.com/a/57473979/6521116"">this answer</a>.</p>

<pre><code>git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch filepattern' --prune-empty --tag-name-filter cat -- --all
</code></pre>
"
"57889673","<p>If you are going to be passing the contents of the environment data file to React, which is client-side code, then it isn't likely to be very useful for keeping things secret.</p>

<p>Mostly this will be useful for keeping your various environments separate (e.g. so you don't accidentally use the URL for your test API server in the production deployment of your app).</p>

<p>If you were using this for server-side code, then it would be useful to keep your secrets secret and not publishing them in a git repository (that you might want to allow other people access to).</p>

<p>Whether or not the environment data file would be deployed to your server would depend on your deployment process. If your deployment process consisted of nothing more than checking out your git repository to the live server, then no, it wouldn't be deployed.</p>
"
"57418239","<p>Credentials can always end up in the wrong hands, so if you give any credentials to anyone - for any purpose - always make sure they have the absolute minimum amount of access they need, i.e. just enough privileges to do what they need to do, and not a bit more.</p>

<p>Good practice would also suggest to rotate those credentials on a regular basis, and also to track from where and when they are being used by taking a look at your cloudtrail logs. </p>

<p>For example if you give a set of credentials access to a particular bucket for putting s3 objects into it - and those credentials are seen trying to start ec2 instances instead, or write to a different s3 buckets (for example), its a good chance someone else has them and is trying to see what 'else' they can do with them.</p>

<p>You really just can't give them out and forget about them - you need to monitor how they are being used - how often will depend on how critical your data is.</p>
"
"57337331","<h2><strong>Short answer :</strong></h2>
<p>Obfuscate or Encrypt your google map API key according to <a href=""https://developers.google.com/maps/api-key-best-practices"" rel=""noreferrer"">Google Map Documentation</a> :</p>
<blockquote>
<p>On mobile apps that use Maps Web Service APIs, consider one or more    of the following techniques to further safeguard your apps and API<br />
keys:</p>
<ul>
<li><p>Apply an API restriction on the API key. This action narrows the    scope of the API key to the APIs you associate with the key.<br />
Obfuscate or encrypt the API key. This action complicates key<br />
scraping attempts directly from the application.</p>
</li>
<li><p>Use CA pinning or certificate pinning to verify the server resources    are valid. CA pinning checks that a server's certificate
was issued    by a trusted certificate authority, and prevents
Man-In-The-Middle    attacks that could lead to a third party
discovering your API key.    Certificate pinning goes further by
extracting and checking the    public key included in the server
certificate. Pinning is useful for    mobile clients communicating
directly with Google servers, as well as    mobile clients
communicating with the developer's own proxy server.</p>
</li>
<li><p>Use a proxy server.</p>
</li>
</ul>
</blockquote>
<p>You can use many encryption or obfuscation ways you can find easily with just a quick search, One common way is to base64 encoding the key in C++ as a library and to use it just call a function in your Java class, because C++ codes after compiling is more hard to decompile than your Java classes.</p>
<p><a href=""https://medium.com/programming-lite/securing-api-keys-in-android-app-using-ndk-native-development-kit-7aaa6c0176be"" rel=""noreferrer""><strong>Tutorial of doing it with NDK</strong></a></p>
<h2>Long Answer: IT DEPENDS</h2>
<p>You can not do anything in client side to proof your code against decompiling and specially make one hard coded string immune to get extracted.</p>
<p><strong>So what you should do ?</strong></p>
<p>It's a trade-off, at First you should see how much your Key is important for you, Who will try to access it and how much time it worth for him to put on hacking your app. With Encryption or obfuscation we just make it harder, So we need more professional person with more time to hack it(Basically with every layer of security we add to it we are doing that.)</p>
<p>If it's too secret and if It's leak will have cause many problem for you and it's critical you should store it in a server, Then you should request to that server and that server will do API call with your key Or with something like a JWT Token.</p>
<p><strong>But</strong> in case of Google Map API as long as you monitor it and configure it correctly, leaking your key will not cause many problems for you.</p>
"
"57103663","<p>Unfortunately, keeping any key in your React client, even if you are using gitignore and an <code>.env</code> file, is not secure. As pointed out by @ClaudiuCreanga,  React environment variables are embedded in the build and are publicly accessible.</p>

<p>You should really only save API keys or secrets in your backend such as Node / Express. You can have your client send a request to your backend API, which can then make the actual API call with the API key and send the data back to your client. </p>
"
"50748993","<p>I think <a href=""https://rtyley.github.io/bfg-repo-cleaner"" rel=""nofollow noreferrer"">BFG Repo-Cleaner</a> is exactly what you're looking for.</p>

<p>You can use it to <em>replace</em> or <em>remove</em> sensitive information contained in the working tree (like for example a password) throughout the history of the repository. Here's an example from their <a href=""https://rtyley.github.io/bfg-repo-cleaner/#usage"" rel=""nofollow noreferrer"">documentation</a>:</p>

<pre><code>bfg --replace-text passwords.txt /path/to/repository
</code></pre>

<p>The <code>passwords.txt</code> file would then contain a series of strings to match together with what value they should be replaced with. For example:</p>

<pre><code>password             # Replaces the string 'password' with '***REMOVED***' (default)
password==&gt;DELETED   # Replaces the string 'password' with 'DELETED'
password==&gt;          # Replaces the string 'password' with an empty string
regex:password.+==&gt;  # Replaces using a regular expression with an empty string
</code></pre>

<p>As with <code>git-filter-branch</code>, this is a <a href=""https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History"" rel=""nofollow noreferrer"">rewrite history</a> operation, so the usual disclaimer applies.</p>
"
"50439541","<p>In both open source and closed source applications, credentials should not be stored with the source code.</p>

<p>Multiple solutions exist to store credentials, you can store them into environment variables, into a property file added in <code>.gitignore</code> or if you want a more elaborate solution you can use a dedicated tool such as <a href=""https://www.vaultproject.io/"" rel=""nofollow noreferrer"">HashiCorp Vault</a>. There is an interesting official Spring blog post exploring this solution : <a href=""https://spring.io/blog/2016/06/24/managing-secrets-with-vault"" rel=""nofollow noreferrer"">Managing Secrets with Vault</a>.</p>
"
"49930982","<p>This is a common misunderstanding about the way .gitignore works we all met at some point when working with Git: .gitignore will ignore all files that are not being tracked yet; indeed, files that are already being tracked in your Git repository are not ignored by your .gitignore setup.</p>

<p>To fulfil your need, it would be sufficient to untrack the files that you desire to ignore, i.e. in your case the appsettings.json file.
As reported in your question's comments, this has been answered already <a href=""https://stackoverflow.com/questions/1274057/how-to-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-gitignore"">here</a>. Then, your .gitignore setup will work as you would expect.</p>
"
"49829820","<p>@fardjad sent me a link in the comments: <a href=""https://help.github.com/articles/removing-sensitive-data-from-a-repository/"" rel=""nofollow noreferrer"">github sensitive data</a></p>

<p>It says: </p>

<blockquote>
  <p>Warning: Once you have pushed a commit to GitHub, you should consider any data it contains to be compromised. If you committed a password, change it! If you committed a key, generate a new one.
  This article tells you how to make commits with sensitive data unreachable from any branches or tags in your GitHub repository. However, it's important to note that those commits may still be accessible in any clones or forks of your repository, directly via their SHA-1 hashes in cached views on GitHub, and through any pull requests that reference them. You can't do anything about existing clones or forks of your repository, but you can permanently remove all of your repository's cached views and pull requests on GitHub by contacting GitHub Support.</p>
</blockquote>

<p>The answer is YES the first commit with the naked text is accessible/unsafe.</p>
"
"49738291","<p>As far as I know, the common approach for this problem is to have a keys.py.example, and when someone clones the repo, copy it to keys.py and change the values as necessary (you can write it on the README). You can do it with this steps:</p>

<ul>
<li>Run  <code>git rm keys.py</code>, so the keys.py that you have on the repo gets removed</li>
<li>Create or add  the line <code>keys.py</code> on your .gitignore file</li>
<li>Create keys.py.example with the default values</li>
<li><code>git add .</code> to add all this changes on the commit</li>
<li><code>git commit</code> to commit the removal of the file from the repo, the example file and the gitignore changes</li>
</ul>

<p>Usually this kind of values goes on a .env file instead of keys.py. I can see you are using python, so you will need to use <a href=""https://github.com/theskumar/python-dotenv"" rel=""nofollow noreferrer"">this package</a>.</p>
"
"48843086","<p>GitHub has an article for exactly this. Check it out <a href=""https://help.github.com/articles/removing-sensitive-data-from-a-repository/"" rel=""nofollow noreferrer"">here</a>. To sum up the article: you can use either the <code>git filter-branch</code> command or the BFG Repo-Cleaner. BFG Repo-Cleaner is easier and faster to use, so I use that. To use BFG Repo-Cleaner follow these steps:</p>
<ol>
<li><a href=""https://rtyley.github.io/bfg-repo-cleaner/"" rel=""nofollow noreferrer"">Download</a> the jar file at the project repo or with macos use <code>brew install bfg</code></li>
<li>Clone a fresh copy of your repo, using the <code>--mirror</code> flag:</li>
</ol>
<p><code>git clone --mirror git://example.com/some-big-repo.git</code></p>
<p>if using SSH or</p>
<p><code>git clone --mirror https://example.com/some-big-repo.git</code></p>
<p>if using HTTPS.</p>
<p>This is a bare repository so you won't be able to see your files but it will be a full copy of your repository with all commits.</p>
<ol start=""3"">
<li>You can then use the following command to delete specific files from previous commits:</li>
</ol>
<p><code>java -jar bfg.jar --delete-files [FILE NAME]  --no-blob-protection  my-repo.git</code></p>
<p>or if installed to the PATH</p>
<p><code>bfg --delete-files [FILE NAME]  --no-blob-protection  my-repo.git</code></p>
<p>or to delete a password from an old commit</p>
<p><code>bfg --replace-text passwords.txt</code></p>
<ol start=""4"">
<li>Before pushing back up to your repo, check that the repo history has changed by going into your git repo folder and running the following command:</li>
</ol>
<p><code>git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</code></p>
<p>and then</p>
<p><code>git gc</code></p>
<p>to strip out unwanted data that you don't want to push back up to your repo.</p>
<ol start=""5"">
<li>Once your happy, push back up to your remote repo by running <code>git push</code> - note that, because you used the <code>--mirror</code> flag when cloning your repo, when you push back to your repo, you will also push back reference changes.</li>
</ol>
<p>To read up more about BFG Repo-Cleaner, visit this <a href=""https://rtyley.github.io/bfg-repo-cleaner/"" rel=""nofollow noreferrer"">link</a>.</p>
"
"47599464","<p>You can use the <code>--msg-filter</code> switch of <code>git filter-branch</code>. For each commit, it receives the commit message via standard input and applies the given ""script"" on it. In your case, you could keep just the first line of the commit message (the title):</p>

<pre><code>$ git filter-branch --msg-filter 'head -1'
</code></pre>
"
"47577451","<p>In the project I'm working on, my lead copies his <code>.env</code> file to a file called <code>sample.env</code> and pushes it with the code. Then we can ust run <code>cp sample.env .env</code> That will be different depending on your OS of course. I would include those instructions in your <code>README.md</code> for clarity. We use Bitbucket instead of Github but I doubt there will  be any difference there. </p>

<p>Alternatively you could include some code like <code>os.environ[""PYAPPLICATIONRC""] = ""/path/to/.applicationrc""</code></p>
"
"47574417","<p>Yes. You can set your secret as an environment variable on Travis, and use it in your program. Others can only know ""oh, this guy uses a environment variable called <code>PASSWORD</code>!"" and they don't know what the value is.</p>

<p>Only you and Travis CI know.</p>

<p>See this doc: <a href=""https://docs.travis-ci.com/user/environment-variables/"" rel=""nofollow noreferrer"">https://docs.travis-ci.com/user/environment-variables/</a></p>

<p>If you want to store a secret file, you can create a private github repo, and clone it with your github password stored in the env variables.</p>
"
"47343019","<p>There is a popular web service called <a href=""https://www.gitignore.io/"" rel=""noreferrer"">Gitignore.io</a> that help developers generate gitignore files for popular framework and languages. You can see the Django one <a href=""https://www.gitignore.io/api/django"" rel=""noreferrer"">here</a>.</p>

<pre><code>*.log
*.pot
*.pyc
__pycache__/
local_settings.py
db.sqlite3
media
</code></pre>

<p>On top of that I would also recommend you to ignore things environment items such as virtualenv, or .env files that are related to the local environment that the code is being run from. This also allow you to store passwords and secrets in environment files, and keep them out of your git repo. </p>

<pre><code>.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
</code></pre>

<p>Lastly I would also add the django <code>static</code> folder to the list of files to ignore since it is collected with <code>collectstatic</code> whenever you deploy your code.</p>
"
"47264369","<p>When you add a file to .gitignore, it must be untracked. Remove it using <code>git rm --cached database_config.php</code>.</p>
"
"47077553","<p>There is no perfectly safe choice, but some are better than others.</p>

<p>Don't save sensitive information in your project's source code -- you don't want your passwords and API keys on github.</p>

<p>Saving sensitive information in a database is fine, but then you still need somewhere to store the database credentials, and you're right back where you started.</p>

<p>You can save sensitive information in environment variables. These would usually be set up in your web server's configuration file(s).</p>

<p>Saving sensitive information in an ini file is fine, provided the following:</p>

<ul>
<li>The file has the minimal permissions required.</li>
<li>The file is completely outside the web server's document root and thus can't ever be served directly. Don't put the file in your main directory and then use .htaccess to deny access to it.</li>
<li>The file is not committed to source control. If you're using git, edit your .gitignore so that the file is ignored.</li>
</ul>

<p>These should also go without saying:</p>

<ul>
<li>The user account running the web server process should never have write permission to the files it's serving.</li>
<li>Other non-privileged users on the machine running the web server process should not have read access to the files it's serving.</li>
</ul>
"
"45989725","<p>Spring-boot allows you to externalize your configuration in different places. For the scenario in question, one could place an <code>application.properties</code> file under <code>${PROJECT_ROOT}/config/</code>.
Those properties will override any other defined properties.
In this case, it is not packaged within a deployable artifact.<br>
Take a look at <a href=""https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-application-property-files"" rel=""noreferrer"">Application property files</a> for further details.</p>

<p>Provide a sample configuration file under <code>config/application.properties.example</code> as a good starting point. That file could be version controlled.
To avoid unintentional commits ignore everything else. </p>

<p>Using <code>git</code>, an ignore file could contain the following snippet (ignores everything but files ending with <code>.example</code> and a <code>README.md</code>):</p>

<p><em>.gitignore</em>:</p>

<pre><code>/config/*
!/config/README.md
!/config/*.example
</code></pre>
"
"42863070","<p>The easiest way would be to create a configuration file that is read by your project at start-up. This configuration file will not be included in the source code repository, only a example version that does not contain the <code>client_secret</code>.</p>

<p>Furthermore add a readme file describing where and how to get the <code>client_secret</code> and how to make a working configuration file.</p>
"
"42558841","<p>Yes, it is.</p>

<p>Use server-level secrets to store sensitive information like DB connection strings.</p>

<p>In IIS you can use <a href=""https://stackoverflow.com/a/8344498/905""><code>ASPNET_REGIIS</code></a> - it lets you add secret configuration that IIS can access, but that isn't held in plain text with the web files.</p>

<p>In .NET core there's new <a href=""http://asp.net-hacker.rocks/2016/07/11/user-secrets-in-aspnetcore.html"" rel=""nofollow noreferrer""><code>Microsoft.Extensions.SecretManager.Tools</code></a> that does the same thing.</p>

<p>For different environments you can <a href=""https://blogs.msdn.microsoft.com/webdev/2009/05/05/web-deployment-web-config-transformation/"" rel=""nofollow noreferrer"">have multiple <code>web.config</code> files</a>, for instance <code>web.release.config</code> and <code>web.debug.config</code>.</p>
"
"42170662","<blockquote>
  <p>How should this file be secured?</p>
</blockquote>

<p>Not by GitHub or anything Git related.</p>

<p>You need either:</p>

<ul>
<li>an external service (like <a href=""https://github.com/hashicorp/vault"" rel=""nofollow noreferrer"">hashicorp/vault</a>)</li>
<li>or a plateform able to distribute a secret securely (like a <a href=""https://blog.docker.com/2017/02/docker-secrets-management/"" rel=""nofollow noreferrer"">docker secret</a>)</li>
</ul>

<p>But GitHub itself only hosts repo, it does not manage secrets.<br>
A <a href=""https://developer.github.com/webhooks/"" rel=""nofollow noreferrer"">GitHub webhook</a> is just a callback, meaning there mush be a service listening to that callback.</p>
"
"42123756","<p>Avoid storing credentials with code, they get quite vulnerable and consequences may be irreversible. It would be much better to use IAM Roles to grant access and use keys only for development, preferably a different one per developer so they can be rotated as needed.</p>

<p>Check the <a href=""https://d0.awsstatic.com/whitepapers/Security/AWS_Security_Best_Practices.pdf"" rel=""nofollow noreferrer"">AWS Security Best Practices</a> whitepaper for further details.</p>
"
"42115582","<p>I will try to give my suggestion which was already mentioned by you. The most secure way is do not put sensitive data in web config as much as possible and if their's really a need you MUST encrypt it using this <a href=""https://msdn.microsoft.com/en-us/library/zhhddkxy.aspx"" rel=""nofollow noreferrer"">method</a> which is option 3 and move on!</p>

<p>Hold on, move on to what? You must move on to other security aspect of your application. Securing web config section doesn't guaratee full protection. You must harden your server, secure communication, pentesting or conduct online vulnerability test and even source code scanning. It may sounds overkill and rediculus but if you really want to mitigate security issues those I mentioned is a must. I say mitigate because now a days you and me are not secure any more! Not unless you are not connected to the internet. :)</p>

<p><strong>Update :</strong> These are the tools that may help you. Some are free and some are not. It's not limited only to this</p>

<ul>
<li><a href=""https://www.owasp.org/index.php/Main_Page"" rel=""nofollow noreferrer"">OWASP</a> - for pentesting (free)</li>
<li><a href=""https://www.tenable.com/products/nessus-vulnerability-scanner"" rel=""nofollow noreferrer"">Nessus</a> - for system hardening (enterprise)</li>
<li><a href=""https://benchmarks.cisecurity.org/downloads/audit-tools/"" rel=""nofollow noreferrer"">CIS CAT</a> - tech stack like OS, Database, WebServer etc. (membership only)</li>
<li><a href=""http://www-03.ibm.com/software/products/en/appscan"" rel=""nofollow noreferrer"">IBM AppScan</a> - for source code scanning (enterprise)</li>
</ul>

<p>If you don't want to bother doing on your own, you can delegate this security testing in third party like <a href=""https://www.whitehatsec.com/"" rel=""nofollow noreferrer"">whitehatsec</a>.</p>

<p>Alright, that's all that I have. I'm out! :)</p>
"
"41955908","<p>You can ues SecureStorage provided by XLAB
<a href=""https://github.com/XLabs/Xamarin-Forms-Labs/blob/master/src/Platform/XLabs.Platform.iOS/Services/SecureStorage.cs"" rel=""nofollow noreferrer"">https://github.com/XLabs/Xamarin-Forms-Labs/blob/master/src/Platform/XLabs.Platform.iOS/Services/SecureStorage.cs</a></p>
"
"41927361","<p>Put your secrets into environmental variables which you can reference in your script.</p>

<p>export MY_OAUTH='some oauth key'</p>

<p>Then you can use the variable $MY_OAUTH in your script.</p>

<p>If you want to make the environmental variable permanent see this: </p>

<p><a href=""https://unix.stackexchange.com/questions/117467/how-to-permanently-set-environmental-variables"">https://unix.stackexchange.com/questions/117467/how-to-permanently-set-environmental-variables</a></p>
"
"41917249","<p>You can possibly do one of the following (Assuming that you're deploying on a Linux Based OS):</p>

<ol>
<li><p>Store the keys in variables and then export them from the file: <code>~/.bash_profile</code></p></li>
<li><p>Save them as environment variables</p>

<p>You can checkout this answer to see how to access them : <a href=""https://stackoverflow.com/q/4906977/1542307"">Access environment variables from Python</a></p></li>
</ol>
"
"41482391","<p><strong>TL;DR:</strong></p>

<p><strong><em>Important!</strong> Storing in source control could expose <a href=""https://www.terraform.io/docs/state/sensitive-data.html"" rel=""noreferrer"">potentially sensitive data</a> and risks running Terraform against an old version of state. Don't do it.</em></p>

<p>Terraform no longer recommends storing state in source control. Your 'good' options are remote or local.</p>

<p>Remote state grants significant benefits vs both local and storing in source control. Details of these are below.</p>

<hr>

<p><strong>Original answer:</strong></p>

<p>Yevgeniy's answer is a good one. The issue is somewhat less controversial now as Terraform have updated their docs to state:</p>

<blockquote>
  <p>Terraform also puts some state into the terraform.tfstate file by
  default. This state file is extremely important; it maps various
  resource metadata to actual resource IDs so that Terraform knows what
  it is managing. This file must be saved and distributed to anyone who
  might run Terraform. It is generally recommended to setup remote state
  when working with Terraform. <strong>This will mean that any potential secrets
  stored in the state file, will not be checked into version control</strong></p>
</blockquote>

<p>So there is no longer a disagreement between established best practice and official recommendations.</p>

<hr>

<p><strong>Update 2019-05-17</strong></p>

<p>In <a href=""https://www.terraform.io/docs/state/index.html"" rel=""noreferrer"">the most recent version of the docs</a> this has been changed to say:</p>

<blockquote>
  <p>... This state is stored by default in a local file named
  ""terraform.tfstate"", but it can also be stored remotely, which works
  better in a team environment. ...</p>
</blockquote>

<p>I don't expect the advice will ever revert to source control being the preferred method of storing state. </p>

<p>Despite the docs quote above <strong>remote state is still beneficial as a solo developer</strong></p>

<p>Remote state allows the solo developer to:</p>

<ul>
<li>Work on/run their Terraform code from several devices</li>
<li>Easily backup and protect against losing the state file, depending on backend chosen</li>
<li>Segregate sections of their architecture via <a href=""https://www.terraform.io/docs/state/remote.html#delegation-and-teamwork"" rel=""noreferrer"">outputs</a></li>
<li><a href=""https://www.terraform.io/docs/state/sensitive-data.html#recommendations"" rel=""noreferrer"">Automatically encrypt state file at rest</a>, depending on backend chosen</li>
</ul>
"
"40844850","<p>Add the .pubxml-files to your <code>.gitignore</code>. You should not post them to GitHub for the reason you mentioned.</p>

<p>All of your colleagues will have to get the .pubxml file somehow so they can do the publish. Either you send the file to them, or they connect to the Azure subscription and get it.</p>
"
"40132369","<p>As they state, user secrets is <strong>only</strong> for development (to avoid commiting credentials accidentally into the SCM) and not intended for production. You should use one connection string per database, i.e. <code>ConnectionStrings:CmsDatabaseProduction</code>,<code>ConnectionStrings:CmsDatabaseDevelopment</code>, etc. </p>

<p>Or use docker containers (when you're not using Azure App Service), then you can set it on per container basis.</p>

<p>Alternatively you can also use environment based appsetting files. <code>appsettings.production.json</code>, but they must not be included in the source control management (Git, CSV, TFS)! </p>

<p>In the startup just do:</p>

<pre><code>    public Startup(IHostingEnvironment env)
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(env.ContentRootPath)
            .AddJsonFile(""appsettings.json"", optional: true, reloadOnChange: true)
            .AddJsonFile($""appsettings.{env.EnvironmentName}.json"", optional: true)
            .AddEnvironmentVariables();
        Configuration = builder.Build();
    }
</code></pre>

<p>This way, you can load specific stuff from the <code>appsettings.production.json</code> and can still override it via environment variable. </p>
"
"39459587","<p>Please don't do that.</p>

<p>Storing passwords on thirdparty services is generally a bad idea, especially ones not designed for secure data storage.</p>

<p>Github has a pretty detailed article about their security:
<a href=""https://help.github.com/articles/github-security/"" rel=""noreferrer"">https://help.github.com/articles/github-security/</a></p>

<p>They don't encrypt the repositories on disk because, as they point out:</p>

<blockquote>
  <p>We do not encrypt repositories on disk because it would not be any more secure: the website and git back-end would need to decrypt the repositories on demand, slowing down response times. Any user with shell access to the file system would have access to the decryption routine, thus negating any security it provides. Therefore, we focus on making our machines and network as secure as possible.</p>
</blockquote>

<p>So, at the very least, your passwords would be accessible to GitHub employees.</p>

<p>Private repos are basically just the same as non-private ones, they're just not listed on the website for people who aren't allowed to see them.</p>

<p>Plus, if you stop paying, don't your private repos become public?</p>

<p>Do you really trust everyone you're going to give access to your repository to not abuse the passwords, and not publish them?</p>

<p>The problem you presumably have is roughly ""I have a piece of software that needs to use database passwords and it's annoying to have to keep inputting them so I want to put them in the config file I store in git"".</p>

<p>One way to solve this problem is to make a file containing your passwords, <code>passwords.json</code>, and add this to your <code>.gitignore</code>. You would then commit to your repo a <code>passwords-example.json</code> showing the format of <code>passwords.json</code>, just without any real passwords (and presumably a <code>README.md</code> explaining how to use this).</p>
"
"39356579","<p>You should acquire the access token on a server endpoint then send it to your client, then the client can finish the login/linking/signup with option 2.</p>

<p>Does that make sense?</p>
"
"39242359","<p>First of all, why should users be able to see the code? Are you using Onsen to develop a web-app?</p>

<p>If you are developing a Cordova App, you can use Monaca Power Plugins, like <a href=""https://docs.monaca.io/en/reference/power_plugins/html5_resource_encryption/"" rel=""nofollow"">HTML5 Resource Encryption</a> in order to encrypt your source code.</p>
"
"36107082","<p>In general, and as long as your <code>settings.py</code> does not include sensitive information, uploading your Django project to GitHub will not compromise your super user account. Your user information is stored in your database, which should not be included in your Git repository.</p>
<p>The most likely situation where this <em>might</em> be a problem is if you are using SQLite, a file-based database. If you are, make sure that your database file is not (and has never been) checked into your repository.</p>
"
"33509554","<p>Like others here have said. You Don't. </p>

<p>If you want to process payments in an ionic app you need your private key on a server and can use the public key in the app. </p>

<p>You will likely need to send the user info to a server that you make where the server will actually make the reqest to stripe to process the payment.</p>

<p>One recomendation would be to create a parse.com account and have Parse Cloud Code process the stripe payment. This is what it would look like.</p>

<p><strong>Parse Cloud Code</strong></p>

<pre><code>    var Stripe = require('stripe');
Stripe.initialize('sk_test_xxx');

Parse.Cloud.define(""purchaseItem"", function(request, response) {...
</code></pre>

<p><strong>ionic</strong></p>

<pre><code>Parse.Cloud.run (""purchaseItem"" ....
</code></pre>
"
"33136057","<p>Here is another way:</p>

<p>Place the API key in a file accessible to the build machine/server, we'll call it: </p>

<pre><code>/usr/api_user/api_key1
</code></pre>

<p>With contents:</p>

<pre><code>myApiKey = abcdefghijklmnopqrstuvwxyz
</code></pre>

<p>You will now access it using the `BuildConfig' gradle object. Modify your code to this: </p>

<pre><code>public interface APIContract {
    //The API KEY MUST NOT BE PUBLISH. It is possible to generate a new one for free from www.themoviedb.org
    //Remove before commit !!!
    String API_KEY = BuildConfig.MY_API_KEY;
    /...
}
</code></pre>

<p>Then in your build.gradle, add something like this:</p>

<pre><code>buildConfigField ""String"", ""MY_API_KEY"", getMyApiKey(""myApiKey"")
</code></pre>

<p>And also add this:</p>

<pre><code>//return a MY API KEY from a properties file.
def getMyApiKey(String property){
    Properties properties = new Properties()
    properties.load(new FileInputStream(""/usr/api_user/api_key1""))
    return ""\"""" + properties.getProperty(property) +""\""""
}
</code></pre>

<p>You can relocate the API directory location, as you can tell, so that it is not a part of your repo. Of course, then it will have file system dependencies for the build... which you could have a list setup in a CI/CD environment (maybe a tool like Jenkins) to replicate the build files to a private repo, for backup purposes.</p>
"
"33113613","<p>I find the following technique to be the easiest way to do this.</p>

<p>Instead of putting the deployment <strong>values</strong> of these settings into the <code>web.config</code>, I keep the test values in there instead.  I then put the deployment values into the Application Settings section of the Azure Website via the Azure Portal:</p>

<p><a href=""https://i.stack.imgur.com/yYOU5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/yYOU5.png"" alt=""enter image description here""></a></p>

<p>When the website runs, these settings will take precedence over what is in the <code>web.config</code>.  This helps me avoid externalized files, allows me to keep sane development configuration that the team can share, and makes deployment very easy.</p>
"
"32918730","<p>It’s not easy. You have to go through each commit and remove that file. And keep in mind that will modify the history, be careful if you are collaborating with others.</p>

<p>Here is a guide from GitHub on how to remove sensitive data: <a href=""https://help.github.com/articles/remove-sensitive-data/"" rel=""nofollow"">https://help.github.com/articles/remove-sensitive-data/</a></p>

<p>The resulting command should be:</p>

<pre><code>git filter-branch --force --index-filter \
'git rm --cached --ignore-unmatch config/secrets.yml' \
--prune-empty --tag-name-filter cat -- --all
</code></pre>
"
"32560099","<p>I think the issue is that you're trying to access the Foursquare API using Javascript, which is executed on the client side, so yes, anybody using your website can, with a little bit of investigation, see the secret key that you're using, which is something that you definitely don't want to do.</p>

<p>The way to get around that is not to access the API using code that is executed on the client side. Whatever language you have building the website on the server side should be the code that accesses the API (using the auth credentials that you have set up) and then returns the results of the API call to the rest of the code.</p>

<p>Alternately, you can get users to authenticate with Foursquare and get an access token, which you can then use in user-specific API calls, and it won't matter if those are executed on the client side. I think this is the relevant page in the documentation for using that method: <a href=""https://developer.foursquare.com/overview/auth#access"" rel=""nofollow"">https://developer.foursquare.com/overview/auth#access</a> </p>
"
"32176158","<p>No, a soft reset is not enough.
Doing this will leave the file in your index (where you stage files to be committed). This means, that git is still tracking the file.</p>

<p>You will want to do a mixed reset, which unstages these files as well. As René pointed out, it is also a good idea to remove the file or add it to your <code>.gitignore</code> so you don't accidentally commit it again.</p>

<p>This is enough so the sensitive information will not be transmitted to a remote server on <code>git push</code>.</p>

<p>However, the information is still in your local repository. If you ever ""loose"" a commit by accidentally resetting too far, <a href=""http://effectif.com/git/recovering-lost-git-commits"" rel=""noreferrer"">git reflog</a> is a very useful tool.</p>

<p>Now to clean all away all commits, that are not reachable through a branch or tag:</p>

<pre><code>git reflog expire --expire=1.minute --all
git prune
git gc
</code></pre>

<ol>
<li>Removes all entries older than 1 minute from the reflog. A commit will not be removed, if there is any remaining reference to it. Such a reference can come from another commit, a branch, a tag and also the reflog.</li>
<li>Removes all commits that aren't reachable anymore.</li>
<li>Does a number of housekeeping tasks. For more info look at the <a href=""http://git-scm.com/docs/git-gc"" rel=""noreferrer"">documentation</a></li>
</ol>

<p><code>reflog expire</code> and <code>prune</code> are destructive operations. I recommend running these commands with the <code>--dry-run</code> argument first, to see what exactly gets removed.</p>
"
"31591070","<p>Use the Heroku app settings to store your credentials.</p>

<pre><code>heroku config:set KEY=VALUE
</code></pre>

<p>and then your app has an environment variable <code>KEY</code> with the specified value.</p>

<p>Or if you prefer you can update them through the Heroku Dashboard on the 'Settings' tab press the 'Reveal Config Vars' button and then you can edit the config variables through the web.</p>
"
"31350917","<p>Yes, the only thing you do not want to push to github are secrets associated with any APIs you may be associated with.  Those should be added as environment variables where the server is hosted.</p>
"
"31195499","<p>No it won't, as long as you are not deploying a rails app somewhere in development or test mode.</p>

<p>See <a href=""https://stackoverflow.com/questions/25426940/what-is-the-use-of-secret-key-base-in-rails-4"">What is the use of secret_key_base in rails 4</a></p>
"
"29909037","<p>Your best bet is to use environment variables.</p>

<p>Check out these two links. The second link will show you how to keep your sensitive information secure by using environment variables to store sensitive data.</p>

<p><a href=""http://railsapps.github.io/rails-environment-variables.html"" rel=""nofollow"">Rails Environment Variables</a></p>

<p><a href=""http://richonrails.com/articles/environment-variables-in-ruby-on-rails"" rel=""nofollow"">Environment Variables in Ruby on Rails</a></p>
"
"29741586","<p>Since you have already made 5 commits since the commit containing the clear text password, you best bet is to do a <code>git rebase -i</code> in interactive mode on your local branch.  Find the SHA-1 of the commit where you added the clear text password, and type the following:</p>

<pre><code>git rebase --interactive dba507c^
</code></pre>

<p>where <code>dba507c</code> are the first 7 characters of the SHA-1 for the bad commit.</p>

<p>Change this:</p>

<pre><code>pick dba507c comment for commit containing clear text password
</code></pre>

<p>To this:</p>

<pre><code>edit dba507c I have removed the clear text password
</code></pre>

<p>Make the change to the password file to remove the clear text, then commit your result like this:</p>

<pre><code>git commit --all --amend --no-edit
git rebase --continue
</code></pre>

<p>Finish the rebase, then push your (correct) local branch to the remote via:</p>

<pre><code>git push -f origin your_branch
</code></pre>

<p>You will need to force push <code>your_branch</code> because you have rewritten history (by modifying the password file).  Now you have all your latest commits, but you have removed the clear text.</p>
"
"29687630","<p>Usually what I have seen is that the client requests a user-specific token from the API and then sends it back over HTTPS on a per request basis.</p>

<p>If the secret key is shared across all clients then you have to do more work. One way to handle this would be to create a proxy that generates and accepts user-specific tokens on the frontend and uses the shared key on the backend. The JS would talk to the proxy.</p>
"
"29399036","<p>It's a bad idea to store any kind of plaintext secret in revision control, SSH private keys included. Instead, use ansible-vault to store the private key. </p>

<p><code>ansible-vault</code> can operate on any file type. Just encrypt the file with </p>

<pre><code>ansible-vault encrypt /path/to/local/private_key
</code></pre>

<p>then install the key:</p>

<pre><code>- name: Install a private SSH key
  vars:
    source_key: /path/to/local/private_key
    dest_key: /path/to/remote/private_key
  tasks:
  - name: Ensure .ssh directory exists.
    file: 
      dest: ""{{ dest_key | dirname }}""
      mode: 0700 
      owner: user 
      state: directory
  - name: Install ssh key
    copy: 
      src: ""{{ source_key }}"" 
      dest: ""{{ dest_key }}""
      mode: 0600
      owner: user
</code></pre>

<p>Earlier versions of ansible-vault would only operate on variables defined in var files, so you had to do something like this:</p>

<pre><code>ssh_key: |
  -----BEGIN RSA PRIVATE KEY-----
  ...
  -----END RSA PRIVATE KEY-----
key_file: /home/user/.ssh/id_rsa
</code></pre>

<p>Encrypt with ansible-vault:</p>

<pre><code>ansible-vault encrypt /path/to/var_file
</code></pre>

<p>And install the key:</p>

<pre><code>- name: Ensure .ssh directory exists.
  file: 
    dest: ""{{ key_file | dirname }}""
    mode: 0700 
    owner: user 
    state: directory

- name: Install ssh key
  copy: 
    content: ""{{ ssh_key }}"" 
    dest: ""{{ key_file }}""
    mode: 0600
    owner: user
</code></pre>

<p>Thanks to all those below who improved the answer with their comments.</p>
"
"27068378","<p>The standard (and correct, really) advice is to keep those passwords elsewhere, e.g., read them out of a different, not-version-controlled, file (<code>~/.netrc</code> and so on).</p>

<p>That said, you could use a pre-commit hook to check for a password in the index<sup>1</sup> and abort the commit if present (this is again standard advice: don't modify things in pre-commit hooks, just tell the user that there's something not right, and stop).  Or, you could even have the pre-commit hook adjust the index so that the password is absent.</p>

<p>Note that the pre-commit hook can be bypassed by the user, so this is not foolproof, no matter how you set it up (as a verifier, or as a modifier).</p>

<hr>

<p><sup>1</sup>Remember that the new commit will be made from the contents of the <em>index</em>, not that of the working directory.  For instance:</p>

<pre><code>$ echo this is what will be committed &gt; foo.txt
$ git add foo.txt                 # put current foo.txt into the index
$ echo the current contents are completely different &gt; foo.txt
$ git commit -m 'demonstrate index vs work dir'
</code></pre>

<p>The version of <code>foo.txt</code> in the commit this creates reads ""this is what will be committed"", even though ""the current contents are completely different"" is what is in <code>foo.txt</code> if you look at it now.  To see what's actually in the index, use, e.g.:</p>

<pre><code>$ git cat-file -p :0:foo.txt
</code></pre>

<p>See <a href=""https://www.kernel.org/pub/software/scm/git/docs/gitrevisions.html"" rel=""nofollow"">gitrevisions</a> for what <code>:0:foo.txt</code> means.</p>
"
"26448538","<p>as i saw before in other project , they ignore the .sln from committing in to the repository .
by the way i have an answer in mind , why would you want to publish a project on github when you have a TFS server for that ? 
in fact , have this check list in mind :</p>

<p>Put the following files in version control:</p>

<ul>
<li>dsw (VS6 workspace)</li>
<li>dsp (VS6 project)</li>
<li>*proj (VS Project files of various types)</li>
</ul>

<p>of course your source files and other artifacts you create
Do not put the following files into version control:</p>

<ul>
<li>ncb (something to do with browsing or intellsense)</li>
<li>sln (sensitive data)</li>
<li>suo (user workspace settings like window placement, etc - I think)</li>
<li>user (user project settings like breakpoints, etc - I think)</li>
</ul>

<p>Also, don't put in any object files, executables, auto-generated files (like headers that might be generated).</p>

<p>in the end there is a file with name *.vssscc which you should not commit that duo to having sensitive data's.</p>

<p>good luck .</p>
"
"25731785","<p>Presuming you are using an Azure website you should be storing your secrets in either App Settings or Connection Strings.  Both of these are available from the configure tab of the web site.</p>

<p><img src=""https://i.stack.imgur.com/sIl6X.png"" alt=""configure tab example""></p>

<p><img src=""https://i.stack.imgur.com/z6d0h.png"" alt=""settings and connection strings""></p>

<p>The connection strings acts just like a connection string in web config.  App settings act like app keys in webconfig apart from it is good practice to access them using the <a href=""http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.cloudconfigurationmanager.aspx"" rel=""nofollow noreferrer"">cloud configuration manager</a> and particularly the method <a href=""http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.cloudconfigurationmanager.getsetting.aspx"" rel=""nofollow noreferrer"">get settings</a>.</p>
"
"25692756","<p>Dotenv is excellent and does exactly what you want.  It's very common and a great way to keep secrets out of shared files. Combine it with env_bang-rails for some added goodness (defaults, failures if undefined, etc.)</p>

<p><a href=""https://github.com/bkeepers/dotenv"" rel=""nofollow"">https://github.com/bkeepers/dotenv</a></p>

<p><a href=""https://github.com/jcamenisch/ENV_BANG/"" rel=""nofollow"">https://github.com/jcamenisch/ENV_BANG/</a></p>
"
"25501861","<p>I think storing credentials inside another *py file is your safest bet. Then just import it. Example would look like this</p>

<p>config.py</p>

<pre><code>username = ""xy""
password = ""abcd""
</code></pre>

<p>main.py</p>

<pre><code>import config
login(config.username, config.password)
</code></pre>
"
"25267413","<p>I ended up going the route of having a second private repository to store configuration files after examining the security aspects of having a public-facing privately-accessible repository that has sensitive information. This technique is described <a href=""https://stackoverflow.com/a/6721391/1188008"">here</a>. </p>

<p>However, that link doesn't address a major issue with using multiple VCS roots - unless the checkout rules are modified, Teamcity copies the first VCS files to the checkout directory, deletes all the files, then copies the second VCS files to the same directory. I have no idea why this behavior was chosen as the default. This obviously fails the build because the original code files are no longer there. </p>

<p>The solution is described <a href=""https://stackoverflow.com/questions/13979467/setting-up-teamcity-to-pull-multiple-git-repos-with-named-locations"">here</a>. Basically I had to setup the checkout rules to move the files copied from the first VCS root to a subfolder, and then have checkout rules on the second VCS root to move the config files to the correct location within that subfolder. </p>

<p>Now to the core issue: security implications of storing sensitive information in a public-facing privately-accessible repository. The important adjective here is public-facing. My basic requirement for security in this scenario is that the repository should have as much security as a Windows folder that is secured using the Security tab. The argument I use to justify that it is even more secure as a private Git repository is that is uses either HTTP or SSH security, which one could argue is just as strong, if not stronger, than Windows folder security since these are more exposed than Windows folders. Since this is just going to be storing the login info for the test environment, I'm not too worried about it. All sensitive info for my production environment will be handled manually. But I'm open to opinions on this topic. Hope this solution helps other people. Please feel free to comment/ask questions.</p>
"
"24618274","<p>Since you should avoid storing private keys in source control, I would recommend that you instead add a <strong>config/secrets.sample.yml</strong> to your repository containing a template for the <em>secrets</em> like:</p>

<pre><code>development:
  secret_key_base:
  some_random_key:

test:
  secret_key_base:
  some_random_key:

production:
  secret_key_base: &lt;%= ENV[""SECRET_KEY_BASE""] %&gt;
  secret_key_base: &lt;%= ENV[""SOME_RANDOM_KEY""] %&gt;
</code></pre>

<p>Then you would just need to give them the values to fill in a secure way (voice, piece of paper, etc.)</p>

<p>There is an interesting blog post that you can read <a href=""https://intercityup.com/blog/deploying-app-env-variables-with-rbenv-passenger-and-capistrano/"" rel=""nofollow"">here</a> about how to deploy your app's ENV variables.</p>
"
"24086951","<p>I use an environment file that stays on my computer and contains some variables linked to my environment.</p>

<p>In my Django settings.py (which is uploaded on github):</p>

<pre><code># MANDRILL API KEY
MANDRILL_KEY = os.environ.get('DJANGO_MANDRILL_KEY')
</code></pre>

<p>On dev env, my .env file (which is excluded from my Git repo) contains:</p>

<pre><code>DJANGO_MANDRILL_KEY=PuoSacohjjshE8-5y-0pdqs
</code></pre>

<p>This is a ""pattern"" proposed by Heroku: <a href=""https://devcenter.heroku.com/articles/config-vars"" rel=""nofollow"">https://devcenter.heroku.com/articles/config-vars</a></p>

<p>I suppose there is a simple way to setit without using Heroku though :)</p>

<p>To be honest, the primary goal to me is not security-related, but rather related to environment splitting. But it can help for both I guess.</p>
"
"23354622","<p>Yes, you can create a folder outside of source control, put a file called app.properties in there, put your key in that properties file and add the folder to your build path. Then use a properties loader to load it from the classpath.</p>

<p>If you have many developers or more than one dev machine, you can set the local properties location as a variable in your build path so that each developer can configure their own.</p>
"
"22887953","<p>One possible approach is:</p>

<ol>
<li>fill the config file with dummy data, commit changes and push to GitHub</li>
<li><p>configure git to ignore changes in tracked file:</p>

<p>git update-index --assume-unchanged <strong><em>config-file</em></strong></p></li>
<li>fill the config file with sensitive information</li>
</ol>
"
"22742781","<p>To my best knowledge these are local client side configuration settings and not shared between repositories.</p>
"
"22537111","<p>You shouldn't store production passwords in git, no matter whether you use github or your own git server. It is just another potential point of failure/vulnerability. If you already have done this, you should remove the files containing them (also from the history) - there are numerous SO questions how to do this. If you already pushed these files to a remote server, you should change the passwords.</p>

<p>As for a best practice, you could use the dotenv gem (<a href=""https://github.com/bkeepers/dotenv"" rel=""nofollow"">https://github.com/bkeepers/dotenv</a>)
In this way you can extract all sensitive data for production in rails environment variables in one single file .env.production. This file should exist only on the production server and should be added to your git ignore file just to be sure. </p>

<p>Dotenv allows you to set variables for each environment in a file called .env.[development|production|test|whatever]. You can push your non-sensitive files/data for development, test, etc. but ignore the important ones. You can access these variables with <code>ENV['MY_ENV_VARIABLE']</code>. (In each of your .env files you will then have a line <code>MY_ENV_VARIABLE=""some super secret password""</code>)</p>

<p>One downside with this approach is that you have to make sure you edit the .env.production file every time you add a new sensitive data/field to your app on the server.</p>
"
"21814021","<p>I figured another solution now which is not perfect but still good enough for me, example:</p>

<p><code>APIKeys.cs</code> file:</p>

<pre><code>public static partial class APIKeys
{
    public static readonly string ImgurClientID = """";
    public static readonly string ImgurClientSecret = """";
    public static readonly string GoogleClientID = """";
    public static readonly string GoogleClientSecret = """";
    public static readonly string PastebinKey = """";
    ...
}
</code></pre>

<p><code>APIKeysLocal.cs</code> file:</p>

<pre><code>public static partial class APIKeys
{
    static APIKeys()
    {
        ImgurClientID = ""1234567890"";
        ImgurClientSecret = ""1234567890"";
        GoogleClientID = ""1234567890"";
        GoogleClientSecret = ""1234567890"";
        PastebinKey = ""1234567890"";
        ...
     }
}
</code></pre>

<p>Ignore <code>APIKeysLocal.cs</code> file in Git and people who don't have this file can still be able to compile project if they remove this file from solution explorer.</p>

<p>I also automatically create empty <code>APIKeysLocal.cs</code> file if it is not already exists using project pre build event:</p>

<pre><code>cd $(ProjectDir)APIKeys\

if not exist APIKeysLocal.cs (
    type nul &gt; APIKeysLocal.cs
)
</code></pre>

<p>That way user don't need to do anything to be able to compile project.</p>
"
"21761583","<p><strong>EDIT</strong>: For anyone looking at this. Just saw this excellent answer, it is well worth reading:<br>
<a href=""https://stackoverflow.com/questions/11575398/how-can-i-save-my-secret-keys-and-password-securely-in-my-version-control-system"">How can I save my secret keys and password securely in my version control system?</a></p>

<p>---Continue old answer---</p>

<p>Great question. See this post for a good start: <a href=""http://rosspenman.com/api-key-exposure/"" rel=""nofollow noreferrer"">Accidental API Key Exposure is a Major Problem</a></p>

<p>I generally try to keep all my api tokens in an external file.</p>

<p>I exclude that file in .gitignore:</p>

<pre><code>##################
#Ignore API token#
##################
token.txt
</code></pre>

<p>Then I read the token from the file (working in python):</p>

<pre><code>#import token from token.txt file in same directory
token_file = os.path.join(path, ""token.txt"")

with open(token_file, 'rb') as f:
    token = f.read().replace('\n', '')
</code></pre>

<p>Since I never push the token file it never gets exposed.</p>
"
"21399771","<p>It depends on the shell you are using.<br>
On Windows, with msysgit for instance, see <a href=""https://code.google.com/p/msysgit/issues/detail?id=477#c12"" rel=""noreferrer"">issue 477</a>:</p>

<blockquote>
  <p>Single quotes do not have a special meaning with CMD. Do not expect that they work 
  the same as with a POSIX shell. Call filter-branch like this:</p>
</blockquote>

<pre><code>git filter-branch --commit-filter ""GIT_COMMITTER_NAME=void GIT_AUTHOR_NAME=void GIT_COMMITTER_EMAIL=just.a.test@kernel.org GIT_AUTHOR_EMAIL=just.a.test@kernel.org; git commit-tree \""$@\"""" HEAD
</code></pre>

<p>Multiple lines:</p>

<pre><code>git filter-branch --commit-filter ""GIT_COMMITTER_NAME=void \
                                   GIT_AUTHOR_NAME=void \
                                   GIT_COMMITTER_EMAIL=just.a.test@kernel.org \
                                   GIT_AUTHOR_EMAIL=just.a.test@kernel.org; \
                                   git commit-tree \""$@\"""" HEAD
</code></pre>

<p>As mentioned in ""<a href=""https://stackoverflow.com/a/19507601/6309"">How to pass a programmatically generated list of files to <code>git filter-branch</code>?</a>""</p>

<blockquote>
  <p>Each argument to the various <code>...-filters</code> needs to be a single string. That string is saved as a shell variable.</p>
</blockquote>

<p>So make sure <code>'git rm --cached --ignore-unmatch filename.js'</code> is considered a string in the shell you are in.<br>
As <a href=""https://stackoverflow.com/users/7402089/constantine-ketskalo"">Constantine Ketskalo</a> points out <a href=""https://stackoverflow.com/questions/21394563/removing-sensitive-data-from-git-fatal-ambiguous-argument-rm/21399771#comment99357419_21399771"">in the comments</a>:</p>

<blockquote>
  <p>Windows 10, PyCharm, GitPython, same command as in question.<br>
  Simply changed <code>'</code> to <code>""</code> inside the string and it worked!</p>
</blockquote>
"
"15858767","<p>There's no strongly compelling reason to prefer environment variables over files, but I'm not sure I'd feel comfortable relying on <code>.gitignore</code> and keeping the files in the source tree.  If you opt for files, you might want to consider moving them outside the source tree to avoid any mistakes.</p>

<p>If you've committed the files at any point in the past (particularly to a public site like GitHub), then adding them to <code>.gitignore</code> later isn't going to remove the copies of previous versions that were committed; they'll still be in the repository, and someone could browse back to a version where they weren't ignored.</p>

<p>Additionally, depending on how you run your app, having them in the same directory as the app may make you more vulnerable to web-based security holes.  If you keep them outside the app tree, you may gain some limited protection from exploits that can read arbitrary data from the app tree.  I don't know that this is all that much of a concern (an exploit that can read within the app tree can probably read outside it too), but it wouldn't hurt to keep them in another directory.</p>

<p>I tend to prefer environment variables because it makes deploying to Heroku easier, so I use them in development too.  I'd probably use a file for anything more than simple login/password pairs (RSA keys, etc), and store it in my home directory or somewhere under <code>/var/lib</code> or <code>/etc</code> or <code>/usr/local</code> or something.</p>
"
"10851642","<p>PHP information is processed on the server before being sent to the browser so it can't be seen inside of a browser under normal circumstances. However, if your webserver is misconfigured the plain text version of your code may be sent to the browser thus rendering it visible to users. That's why important code should always be kept outside of your document root and included into files when needed.</p>
"
"10811170","<p>The classic way to do this is to have a default config file called <em>config.yml-dist</em> (let's pretend that your original file is called <em>config.yml</em>) ; you add the original file in .gitignore, and version only the <em>dist</em> one.<br>
After you deploy your app or re-clone the project, simply <code>cp config.yml-dist config.yml</code>, and change the settings you want. </p>

<p>This method is used by many people I met in the PHP <em>industry</em>. </p>

<p>But, there's one I like much more and that I find cleaner: using environment variables. 
Example:</p>

<pre><code>username: &lt;%= ENV['MONGOID_USERNAME'] %&gt;
password: &lt;%= ENV['MONGOID_PASSWORD'] %&gt;
database: &lt;%= ENV['MONGOID_DATABASE'] %&gt;
</code></pre>

<p>This way, you'll have one single versioned configuration file and won't have to edit a single one. </p>
"
"10441873","<p>Usually what I do is store my configuration in a <code>config.json</code>, add it to my <code>.gitignore</code>, and then include a <code>.npmignore</code> so that npm doesn't use the <code>.gitignore</code> to decide what to bundle. That way, git doesn't add the config.json yet jitsu bundles it on deploy.</p>

<p>env variables, as booyaa suggested, will also work.</p>
"
"10330006","<p>Depends on how secure you need that information to be.</p>

<p>In options listed by you, I believe option (1)</p>

<pre><code>public final static String API_KEY = ""my-api-key"";
</code></pre>

<p>is relatively safe as it the java file is compiled to class file and quick inspection of your distribution will not allow anyone to see the api-key, but downside is that it gets hard-coded and you cannot change it without a recompile.</p>

<p>I would suggest having a hard-coded password in code and then encrypt the key using something like DES. The encrypted key then can be stored as a properties file or whatever.</p>
"
"10045461","<p>You can use update-index to tell git that it should always assume that file is never changed:</p>

<pre><code>git update-index --assume-unchanged oath.class
</code></pre>

<p>You can toggle it back by using --no-assume-unchanged</p>

<pre><code>git update-index --no-assume-unchanged oath.class
</code></pre>

<p>Which will make git notice changes to the file again.</p>
"
"9719854","<p>You can add appsettings that are pumped into your application after it's been pushed to appharbor. These can be used for just about anything.</p>

<p>When looking at your Application on Appharbor.com, there will be a ""Configuration Variables"" on the left hand side. In that area you can add whatever AppSettings you need, and they will be injected when you do a build.</p>

<p>Once you add a setting (name of ""NewAppSetting"", value is ""We Rule!"") you can access them like this:</p>

<pre><code>ConfigurationManager.AppSettings[""NewAppSetting""];//Has a string value of ""We Rule!""
</code></pre>
"
"9708946","<p>I usually rename the <code>/application/config/database.php</code> file to <code>/application/config/database.default.php</code> (versioned) and add the original path to the <code>.gitignore</code> file.  Then, each developer copies the default (unversioned file) back to the original path and edits per their local settings.</p>

<p>This becomes an extra step in the server setup process, but it saves the grief you mention.</p>
"
"9636658","<p>It sounds like you should read up on git attributes. <a href=""https://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes#_merge_strategies"" rel=""noreferrer"">Check out the section at the bottom of this page</a></p>

<blockquote>
  <p>This is helpful if a branch in your project has diverged or is
  specialized, but you want to be able to merge changes back in from it,
  and you want to ignore certain files. Say you have a database settings
  file called database.xml that is different in two branches, and you
  want to merge in your other branch without messing up the database
  file.</p>
</blockquote>
"
"9631506","<p><strong><em>My new answer:</em></strong></p>

<p>Try not to use static passwords to access the back-end, period.  What happens if somebody you don't want determines what that password is.  Why not use usernames &amp; passwords?</p>

<p>You can also consider using a public key or embedded certificate to allow only your app access to the back end servers.</p>

<p><strong><em>My original answer:</em></strong></p>

<p>Sounds like you want to get to know the Keychain.</p>

<p>Here's a tutorial that talks about it:</p>

<p><a href=""http://maniacdev.com/2011/07/tutorial-how-to-use-the-ios-keychain-to-store-names-and-passwords/"" rel=""nofollow noreferrer"">http://maniacdev.com/2011/07/tutorial-how-to-use-the-ios-keychain-to-store-names-and-passwords/</a></p>

<p>And <a href=""https://stackoverflow.com/questions/3558252/ios-keychain-security"">here is a related question that talks about the security of Keychain under iOS</a>.</p>

<p>You shouldn't have programs a store static password for all users, but instead have each user set up his/her account &amp; password for authentication and then store <strong><em>that</em></strong> stuff in the keychain.</p>
"
"9565146","<p>Why not host the code for doing this on your own server, and have the client extend the token via a call to your server?</p>
"
"9505154","<p>You can't. If it was another type of file, you can always use S3 and pull it from there, but this is a file your app needs to start, so you need it on git.</p>
"
"9367704","<p>Customize the ant build script of your project to generate a mapskey.xml (strings) from local.properties (which you add to git ignore).
Those who fork just create their own local.properties with debug and release keys for Google Maps.</p>
"
"9343239","<p>Use symbolic links. </p>

<p>Take an example where you have a config file named ""config.ini"". In the working directory of your git repo, you would do the following:</p>

<ol>
<li><p>Create a version of the config file called ""config-sample.ini"". This is the file you'll do all your work on.</p></li>
<li><p>Create a symbolic link between ""config.ini"" and ""config-sample.ini"".</p>

<pre><code>ln -s config-sample.ini config.ini
</code></pre>

<p>This let's all your code point to ""config.ini"" even though you're really maintaining ""config-sample.ini"".</p></li>
<li><p>Update your .gitignore to prevent the ""config.ini"" from being stored. That is, add a  ""config.ini"" line:</p>

<pre><code>echo ""config.ini"" &gt;&gt; .gitignore
</code></pre></li>
<li><p>(Optional, but highly recommended) Create a .gitattributes file with the line ""config.ini export-ignore"".</p>

<pre><code>echo ""config.ini export-ignore"" &gt;&gt; .gitattributes
</code></pre></li>
<li><p>Do some coding and deploy....</p></li>
<li><p>After deploying your code to production, copy the ""config-sample.ini"" file over to ""config.ini"". You'll need to make any adjustments necessary to setup for production. You'll only need to do this the first time you deploy and any time you change the structure of your config file.</p></li>
</ol>

<p>A few benefits of this:</p>

<ul>
<li><p>The structure of your config file is maintained in the repo.</p></li>
<li><p>Reasonable defaults can be maintained for any config options that are the same between dev and production. </p></li>
<li><p>Your ""config-sample.ini"" will update whenever you push a new version to production. This makes it a lot easier to spot any changes you need to make in your ""config.ini"" file. </p></li>
<li><p>You will never overwrite the production version of ""config.ini"". (The optional step 4 with the .gitattributes file adds an extra guarantee that you'll never export your ""config.ini"" file even if you accidentally add it to the repo.)</p></li>
</ul>

<p>(This works great for me on Mac and Linux. I'm guessing there is a corresponding solution possible on Windows, but someone else will have to comment on that.) </p>
"
"9281390","<p>Well, I'm not really fond of using directly git to automatically deploy the last version of your code, but that's another question.</p>

<p>Regarding your security issue, a really basic solution would be to just remove access to your .git file (with htaccess files?).</p>

<p>Another thing would be to remove your passwords from the git repository, there is probably no use of then in your version control system.</p>
"
"9243638","<p>Github has a nice <a href=""http://help.github.com/remove-sensitive-data/"" rel=""noreferrer"">guide</a> on this exact topic.  It explains how to get it out of the repository, as well as how to deal with the data that may already be in public hands.</p>
"
"9215509","<p>Use a <a href=""http://msdn.microsoft.com/en-us/library/system.configuration.configurationmanager%28v=VS.80%29.aspx"" rel=""nofollow"">configuration file</a> or the <a href=""http://msdn.microsoft.com/en-us/library/microsoft.win32.registry.aspx"" rel=""nofollow"">Windows Registry</a>. </p>

<p>I'd also recommend encrypting it, on Windows you can use the Data Protection API (DPAPI). .Net 2.0+ has a class call <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.protecteddata.aspx"" rel=""nofollow"">ProtectedData</a> that's very simple to use. This way if you do commit your configuration the key is still encrypted and will only work on your machine or even for your user on that machine depending on how you scope your data protection. You'll want to make some way for people to enter in a key to use on their machines though.</p>
"
"8959977","<p>You cannot be 100% secure, you could store the email in a resource file and use an obsficator to make it much harder to get at the string but it is possible to break it (encrypted resource files and strings).  However Even if you used a different email address and setup a forwarding rule the password for that account could still be comprimised.  Anything you have access to in code a hacker could potentially break into as the key will be in clear text at some point.</p>

<p>You have a number of secure options:</p>

<ol>
<li><p>Setup a webservice to receive your messages and email them onto you/log them to a database</p></li>
<li><p>Log your messages to a 3rd Party system (irc? news? some p2p network, IM system), and pick um the messages later.</p></li>
<li><p>Setup a Source Control/issue site for your system, google code/bitbucket/something else that has the ability to receive issues via an api.</p></li>
</ol>
"
"8494885","<p><code>database.yml</code> is the proper place for configuring your database credentials. Normally you'd commit <code>database.yml</code> while only configured with your development and testing environments. </p>

<p>I don't have passwords on my local Postgres and MySQL instances so I can safely commit <code>database.yml</code>. If you want to ignore it, just add <code>database.yml</code> line to the end of your <code>.gitignore</code> file. You'll need to make sure it's cleaned up and committed before ignoring it. Then you can make your changes safely.</p>

<p>Once you deploy to production you would symlink it in from a copy already stored on that server with the sensitive credentials. </p>
"
"7921723","<p>What other permissions are you using?  If you're using ""publish_stream"" I'm sure you could imagine the shenanigans that could ensue!  Even worse, if the user has both your public and private key (which they will) they could create an entire spoof application that identifies itself as you!  </p>

<p>The ""domain"" options in facebook should prevent this, but if there's any chance an attacker could do an <a href=""http://en.wikipedia.org/wiki/Cross-site_scripting"" rel=""nofollow"">XSS attack</a> they could potentially write malicious apps that masquerade as your game.</p>

<p>Have you considered writing something <strong>very</strong> simple with <a href=""http://code.google.com/appengine/"" rel=""nofollow"">google app engine</a> for the sole purpose of dealing with the app authentication token?</p>
"
"7041247","<p>Since it is very easy to encrypt/decrypt a section of the web.config, I would go for this solution: <a href=""http://msdn.microsoft.com/en-us/library/dtkwfdky.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/dtkwfdky.aspx</a></p>
"
"6187506","<p>The binary is not even remotely safe. Whether through the iTunes download or on a jailbroken iPhone, there's nothing you can do other than obfuscation, which a determined adversary will always get past. Do not ever rely on the ""secrecy"" of something embedded in a client application, it is <em>not</em> secret. Ever. On any platform, in any language, with any technique.</p>

<p>If you need to limit who can access your system, you need per-user accounts. There is no other safe mechanism. Apple does provide ways to ""authenticate"" users via their iTunes accounts, you may want to look into that.</p>

<p>Also, ""MD5 encryption"" means nothing. MD5 is a hash function with cryptographic applications, but saying you're doing ""MD5 encryption"" and ""simple XOR"" is just meaningless. I can use XOR and MD5 to do any number of things, few if any would serve as a meaningful encryption scheme, and would have no advantages whatsoever over a real algorithm designed by experts, such as AES.</p>

<p>Use HTTPS (HTTP over SSL). There is no reason not to, the iPhone fully supports it. If you need to, you can get free SSL certificates for your server from at least <a href=""http://www.startssl.com/"" rel=""nofollow"">http://www.startssl.com/</a> . There are lots of cheap SSL certificate providers out there these days, too. Google a bit.</p>

<p>I'd strongly recommend you and your co-developer start reading up on information security, both in theory and practice, because it appears you have very little grounding in the subject, and probably several significant misconceptions that will lead to easily-broken systems.</p>
"
"6094164","<p>Put things like authentication data in a config file, then add that config file to the set of ignored files in your VCS (in Mercurial, that's <code>.hgignore</code>).</p>
"
"6090188","<p>The recommended way to do this is as follows:</p>

<ol>
<li>Create a copy of the public version of the file you'd like people to use <em>as a starting point</em>, and name it something other than the actual usable file. In your case, it could be <code>web.config.template</code>. Make sure the file would be usable if you just renamed it.</li>
<li>Instruct Mercurial to ignore the actual file, ie. <code>web.config</code></li>
<li>If possible, make the build process figure out if the actual file is present, and if not, make a copy from the template file into the actual file</li>
<li>If step 3 is not possible, a batch file to make the actual file is the next best thing, or simple instructions on how to make it.</li>
</ol>

<p>This ensures that:</p>

<ol>
<li>There is a simple way of getting the actual configuration file</li>
<li>You can edit your local actual configuration file without worrying about committing it (it is ignored)</li>
<li>If step 3 was possible, this is largely transparent unless you need to make modifications to the file</li>
</ol>

<p>Step 3 can be handled with a pre-build event for your project, something like:</p>

<pre><code>if not exist web.config copy web.config.template web.config
</code></pre>
"
"5978791","<p>Keep such things in a settings file that you do not commit to your versioning system or code repository in any way. Rather provide a template for the file with documentation on how to populate it with the needed settings (such as their application credentials).</p>
"
"5868746","<p>Create <code>filename.ext.sample</code> files with templates inside (probably filled with dummy data), which need to be copied and filled with actual data in the particular working directory.</p>

<p>That is what I usually do ;-)</p>
"
"5632304","<p>There is no such thing as complete protection with Flash.  Your keys have to be either in the code or loaded externally, and at some point anyone who is determined enough will be able to get them.  All you can do is make this process so complex that it's not worth the hassle.</p>

<p>Have a look at this question for ways to make your source harder to decompile and read: <a href=""https://stackoverflow.com/questions/2251651/how-to-protect-swf-file-from-being-decompiled"">How to protect swf file from being decompiled?</a></p>
"
"5630484","<p>I use Windows Auth with my databases, so the connection string contains a server name but not a username/password.</p>

<p>For Machines where I can't use Windows Auth, I use <a href=""http://msdn.microsoft.com/en-us/library/dd465326.aspx"" rel=""noreferrer"">web.config transforms</a> and add the web.dev.config to my .gitignore.</p>
"
"5586446","<p>Commit an example file, gitignore the real name, and have your contributors copy the example into the proper location, then configure it. Alternately, provide a setup script that copies the example and does those steps.</p>
"
"5525384","<p>There is no real perfect solution. No matter what you do, someone dedicated to it will be able to steal it.</p>

<p>Even Twitter for iPhone/iPad/Android/mac/etc. has a secret key in there, they've likely just obscured it somehow.</p>

<p>For example, you could break it up into different files or strings, etc.</p>

<p>Note: Using a hex editor you can read ascii strings in a binary, which is the easiest way. By breaking it up into different pieces or using function calls to create the secret key usually works to make that process more difficult.</p>
"
"5132569","<p>Add in your repo:</p>

<ul>
<li>a template of it (<code>secret_token.rb.template</code>),</li>
<li>a script able to generate a proper config file <code>secret_token.rb</code> based on local data found on the server (like an encrypted file with the secret value ready to be decoded and put in the <code>secret_token.rb</code> file)</li>
</ul>

<p>From there, add a <strong><a href=""https://stackoverflow.com/questions/2152841/git-how-maintain-mostly-parallel-branches-with-only-a-few-difference/2153000#2153000"">git attribute custom driver</a></strong>:</p>

<p><img src=""https://i.stack.imgur.com/D38UD.png"" alt=""enter image description here""></p>

<p>The script referenced above will be your '<strong><code>smudge</code></strong>' script which will, on checkout of the working tree, generate automatically the right file.</p>
"
"4674143","<p>I'd go about it this way:</p>

<p>Have the secret key in a separate file ""secret_key.py"". This file does not exist for a pristine installation. In your settings.py include something like:</p>

<pre><code>try:
    from .secret_key import SECRET_KEY
except ImportError:
    SETTINGS_DIR = os.path.abspath(os.path.dirname(__file__))
    generate_secret_key(os.path.join(SETTINGS_DIR, 'secret_key.py'))
    from .secret_key import SECRET_KEY
</code></pre>

<p>The function <code>generate_secret_key(filename)</code> that you will write generates a file called <code>filename</code> (which, as we call it, will be <code>secret_key.py</code> in the same dir as <code>settings.py</code>) with the contents:</p>

<pre><code>SECRET_KEY = '....random string....'
</code></pre>

<p>Where random string is the generated key based on a random number.</p>

<p>For key generation you can use Umang's suggestion <a href=""https://stackoverflow.com/a/16630719/166761"">https://stackoverflow.com/a/16630719/166761</a>.</p>
"
"4602883","<p>Create a file called <code>.secretpass</code> and add </p>

<blockquote>
  <p>let twitvim_login = ""user:pass""</p>
</blockquote>

<p>in that file, in your <code>.vimrc</code> do;</p>

<pre><code>source .secretpass
</code></pre>
"
"3686107","<p>For configuration or settings files, what you need to version is:</p>

<ul>
<li>a template files (<code>server=@USER_NAME@;database=@DATABASE_NAME@;</code>)</li>
<li>one or several value files</li>
<li>one script able to replace the variables by the right values</li>
</ul>
"
"3006243","<p>have a versioned template <code>key_template.py</code>:</p>

<pre><code>domain = 'example.com'
API_KEY = 
</code></pre>

<p>Check it out to local machine, fill sensitive fields (such as <code>API_KEY</code>) and save as <code>key.py</code>. Ignore <code>key.py</code> in your version-control software. It really doesn't matter if you keep it in Python files or use <code>ConfigParser</code>.</p>

<p>Automatic way might be to auto-merge on update with the existing <code>key.py</code> file.</p>
"
"2857512","<p>Using a file template is definitely the best solution.
For example, if you have a <code>database.ini</code> file, commit a <code>database.ini.template</code> file and ignore database.ini in <code>.hgignore</code></p>
"
"2851262","<p>Check out <a href=""http://docs.heroku.com/config-vars"" rel=""nofollow noreferrer"">http://docs.heroku.com/config-vars</a>, the first example on the page is exactly what you are trying to do.</p>

<p>Edit '2015:  page now at <a href=""https://devcenter.heroku.com/articles/config-vars"" rel=""nofollow noreferrer"">https://devcenter.heroku.com/articles/config-vars</a> and it's the second page you're looking for.</p>
"
"2397905","<p>The typical way to do this is to read the password info from a configuration file. If your configuration file is called <code>foobar.config</code>, then you would commit a file called <code>foobar.config.example</code> to the repository, containing sample data. To run your program, you would create a local (not tracked) file called <code>foobar.config</code> with your <em>real</em> password data.</p>

<p>To filter out your existing password from previous commits, see the GitHub help page on <a href=""http://help.github.com/removing-sensitive-data/"" rel=""noreferrer"">Removing sensitive data</a>.</p>
"